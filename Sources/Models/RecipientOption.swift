//
// RecipientOption.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/**  */
public final class RecipientOption: Content {
    /**  */
    public var email: String?
    /**  */
    public var name: String?
    /**  */
    public var recipientLabel: String?
    /** Optional element. Specifies the role name associated with the recipient.<br/><br/>This property is required when you are working with template recipients. */
    public var roleName: String?
    /** Optional. The ID of the [signing group](https://support.docusign.com/en/guides/ndse-user-guide-signing-groups).  **Note**: When you send an envelope to a signing group, anyone in the group can open it and sign it with their own signature. For this reason, we recommend that you do not include non-signer recipients (such as carbon copy recipients) in the same signing group as signer recipients. However, you could create a second signing group for the non-signer recipients and change the default action of Needs to Sign to a different value, such as Receives a Copy.  */
    public var signingGroupId: String?

    public init(email: String? = nil, name: String? = nil, recipientLabel: String? = nil, roleName: String? = nil, signingGroupId: String? = nil) {
        self.email = email
        self.name = name
        self.recipientLabel = recipientLabel
        self.roleName = roleName
        self.signingGroupId = signingGroupId
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case email
        case name
        case recipientLabel
        case roleName
        case signingGroupId
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(email, forKey: .email)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(recipientLabel, forKey: .recipientLabel)
        try container.encodeIfPresent(roleName, forKey: .roleName)
        try container.encodeIfPresent(signingGroupId, forKey: .signingGroupId)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        email = try container.decodeIfPresent(String.self, forKey: .email)
        name = try container.decodeIfPresent(String.self, forKey: .name)
        recipientLabel = try container.decodeIfPresent(String.self, forKey: .recipientLabel)
        roleName = try container.decodeIfPresent(String.self, forKey: .roleName)
        signingGroupId = try container.decodeIfPresent(String.self, forKey: .signingGroupId)
    }
}

extension RecipientOption: Hashable {
    public static func == (lhs: RecipientOption, rhs: RecipientOption) -> Bool {
        lhs.email == rhs.email &&
            lhs.name == rhs.name &&
            lhs.recipientLabel == rhs.recipientLabel &&
            lhs.roleName == rhs.roleName &&
            lhs.signingGroupId == rhs.signingGroupId
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(email?.hashValue)
        hasher.combine(name?.hashValue)
        hasher.combine(recipientLabel?.hashValue)
        hasher.combine(roleName?.hashValue)
        hasher.combine(signingGroupId?.hashValue)
    }
}
