//
// ConditionalRecipientRule.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/**  */
public final class ConditionalRecipientRule: Content {
    /** An array of conditions that satisfy the rule. */
    public var conditions: [ConditionalRecipientRuleCondition]?
    /** An integer that specifies the order in which rules are processed. Lower values are processed before higher values. */
    public var order: String?
    public var recipientGroup: RecipientGroup?
    /** A local reference that senders use to map recipients to other objects, such as specific document tabs. Within an envelope, each `recipientId` must be unique, but there is no uniqueness requirement across envelopes. For example, many envelopes assign the first recipient a `recipientId` of `1`. */
    public var recipientId: String?

    public init(conditions: [ConditionalRecipientRuleCondition]? = nil, order: String? = nil, recipientGroup: RecipientGroup? = nil, recipientId: String? = nil) {
        self.conditions = conditions
        self.order = order
        self.recipientGroup = recipientGroup
        self.recipientId = recipientId
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case conditions
        case order
        case recipientGroup
        case recipientId
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(conditions, forKey: .conditions)
        try container.encodeIfPresent(order, forKey: .order)
        try container.encodeIfPresent(recipientGroup, forKey: .recipientGroup)
        try container.encodeIfPresent(recipientId, forKey: .recipientId)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        conditions = try container.decodeIfPresent([ConditionalRecipientRuleCondition].self, forKey: .conditions)
        order = try container.decodeIfPresent(String.self, forKey: .order)
        recipientGroup = try container.decodeIfPresent(RecipientGroup.self, forKey: .recipientGroup)
        recipientId = try container.decodeIfPresent(String.self, forKey: .recipientId)
    }
}

extension ConditionalRecipientRule: Hashable {
    public static func == (lhs: ConditionalRecipientRule, rhs: ConditionalRecipientRule) -> Bool {
        lhs.conditions == rhs.conditions &&
            lhs.order == rhs.order &&
            lhs.recipientGroup == rhs.recipientGroup &&
            lhs.recipientId == rhs.recipientId
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(conditions?.hashValue)
        hasher.combine(order?.hashValue)
        hasher.combine(recipientGroup?.hashValue)
        hasher.combine(recipientId?.hashValue)
    }
}
