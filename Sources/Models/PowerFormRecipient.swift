//
// PowerFormRecipient.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/** **Note**: For a self-service PowerForm on a website, you can specify the intended recipients generically (for example, use &#x60;Member&#x60; as the &#x60;Name&#x60;), and omit personal details such as &#x60;email&#x60;. */
public final class PowerFormRecipient: Content {
    /** (Optional) The access code that the recipient must enter to access the PowerForm.  Maximum Length: 50 characters. The code must also conform to the account's access code format setting.  If blank but the signer accessCode property is set in the envelope, then that value is used.  If blank and the signer accessCode property is not set, then the access code is not required. */
    public var accessCode: String?
    /** When **true**, the `accessCode` property is locked and cannot be edited. */
    public var accessCodeLocked: String?
    /** When **true**, the recipient must enter the `accessCode` to access the PowerForm. */
    public var accessCodeRequired: String?
    /** The email address of the recipient.  **Note**: For self-service documents where you do not know who the recipients are in advance, you can leave this property blank. */
    public var email: String?
    /** When **true**, the recipient's email address is locked and cannot be edited. */
    public var emailLocked: String?
    /** The name of the authentication check to use. This value must match one of the authentication types that the account uses. The names of these authentication types appear in the web console sending interface in the Identify list for a recipient. This setting overrides any default authentication setting. Valid values are:  - `Phone Auth $`: The recipient must authenticate by using two-factor authentication (2FA). You provide the phone number to use for 2FA in the `phoneAuthentication` object. - `SMS Auth $`: The recipient must authenticate via SMS. You provide the phone number to use in the `smsAuthentication` object. - `ID Check $`: The  recipient must answer detailed security questions.   **Example**: Your account has ID Check and SMS Authentication available. In the web console Identify list, these appear as ID Check $ and SMS Auth $. To use ID Check in an envelope, the idCheckConfigurationName should be ID Check $. For SMS, you would use SMS Auth $, and you would also need to add a phone number to the smsAuthentication node. */
    public var idCheckConfigurationName: String?
    /** Indicates if authentication is configured for the account. Valid values are:  - `always`: Authentication checks are performed on every envelope.  - `never`: Authentication checks are not performed on any envelopes.  - `optional:` Authentication is configurable per envelope. */
    public var idCheckRequired: String?
    /** The name of the PowerForm recipient.  **Note**: For self-service documents where you do not know who the recipients are in advance, you can leave this property blank. */
    public var name: String?
    /** The recipient type, as specified by the following values: - `agent`: Agent recipients can add name and email information for recipients that appear after the agent in routing order. - `carbonCopy`: Carbon copy recipients get a copy of the envelope but don't need to sign, initial, date, or add information to any of the documents. This type of recipient can be used in any routing order. - `certifiedDelivery`: Certified delivery recipients must receive the completed documents for the envelope to be completed. They don't need to sign, initial, date, or add information to any of the documents. - `editor`: Editors have the same management and access rights for the envelope as the sender. Editors can add name and email information, add or change the routing order, set authentication options, and can edit signature/initial tabs and data fields for the remaining recipients. - `inPersonSigner`: In-person recipients are DocuSign users who act as signing hosts in the same physical location as the signer. - `intermediaries`: Intermediary recipients can optionally add name and email information for recipients at the same or subsequent level in the routing order. - `seal`: Electronic seal recipients represent legal entities. - `signer`: Signers are recipients who must sign, initial, date, or add data to form fields on the documents in the envelope. - `witness`: Witnesses are recipients whose signatures affirm that the identified signers have signed the documents in the envelope. */
    public var recipientType: String?
    /** The role associated with the recipient (for example, `Member`).  This property is required when you are working with template recipients and PowerForm recipients. */
    public var roleName: String?
    /** Specifies the routing order of the recipient in the envelope.  */
    public var routingOrder: String?
    /** When **true**, the template used to create the PowerForm requires ID lookup for the recipient. */
    public var templateRequiresIdLookup: String?
    /** When **true**, the `userName` property for the recipient is locked and cannot be edited. */
    public var userNameLocked: String?

    public init(accessCode: String? = nil, accessCodeLocked: String? = nil, accessCodeRequired: String? = nil, email: String? = nil, emailLocked: String? = nil, idCheckConfigurationName: String? = nil, idCheckRequired: String? = nil, name: String? = nil, recipientType: String? = nil, roleName: String? = nil, routingOrder: String? = nil, templateRequiresIdLookup: String? = nil, userNameLocked: String? = nil) {
        self.accessCode = accessCode
        self.accessCodeLocked = accessCodeLocked
        self.accessCodeRequired = accessCodeRequired
        self.email = email
        self.emailLocked = emailLocked
        self.idCheckConfigurationName = idCheckConfigurationName
        self.idCheckRequired = idCheckRequired
        self.name = name
        self.recipientType = recipientType
        self.roleName = roleName
        self.routingOrder = routingOrder
        self.templateRequiresIdLookup = templateRequiresIdLookup
        self.userNameLocked = userNameLocked
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case accessCode
        case accessCodeLocked
        case accessCodeRequired
        case email
        case emailLocked
        case idCheckConfigurationName
        case idCheckRequired
        case name
        case recipientType
        case roleName
        case routingOrder
        case templateRequiresIdLookup
        case userNameLocked
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(accessCode, forKey: .accessCode)
        try container.encodeIfPresent(accessCodeLocked, forKey: .accessCodeLocked)
        try container.encodeIfPresent(accessCodeRequired, forKey: .accessCodeRequired)
        try container.encodeIfPresent(email, forKey: .email)
        try container.encodeIfPresent(emailLocked, forKey: .emailLocked)
        try container.encodeIfPresent(idCheckConfigurationName, forKey: .idCheckConfigurationName)
        try container.encodeIfPresent(idCheckRequired, forKey: .idCheckRequired)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(recipientType, forKey: .recipientType)
        try container.encodeIfPresent(roleName, forKey: .roleName)
        try container.encodeIfPresent(routingOrder, forKey: .routingOrder)
        try container.encodeIfPresent(templateRequiresIdLookup, forKey: .templateRequiresIdLookup)
        try container.encodeIfPresent(userNameLocked, forKey: .userNameLocked)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        accessCode = try container.decodeIfPresent(String.self, forKey: .accessCode)
        accessCodeLocked = try container.decodeIfPresent(String.self, forKey: .accessCodeLocked)
        accessCodeRequired = try container.decodeIfPresent(String.self, forKey: .accessCodeRequired)
        email = try container.decodeIfPresent(String.self, forKey: .email)
        emailLocked = try container.decodeIfPresent(String.self, forKey: .emailLocked)
        idCheckConfigurationName = try container.decodeIfPresent(String.self, forKey: .idCheckConfigurationName)
        idCheckRequired = try container.decodeIfPresent(String.self, forKey: .idCheckRequired)
        name = try container.decodeIfPresent(String.self, forKey: .name)
        recipientType = try container.decodeIfPresent(String.self, forKey: .recipientType)
        roleName = try container.decodeIfPresent(String.self, forKey: .roleName)
        routingOrder = try container.decodeIfPresent(String.self, forKey: .routingOrder)
        templateRequiresIdLookup = try container.decodeIfPresent(String.self, forKey: .templateRequiresIdLookup)
        userNameLocked = try container.decodeIfPresent(String.self, forKey: .userNameLocked)
    }
}

extension PowerFormRecipient: Hashable {
    public static func == (lhs: PowerFormRecipient, rhs: PowerFormRecipient) -> Bool {
        lhs.accessCode == rhs.accessCode &&
            lhs.accessCodeLocked == rhs.accessCodeLocked &&
            lhs.accessCodeRequired == rhs.accessCodeRequired &&
            lhs.email == rhs.email &&
            lhs.emailLocked == rhs.emailLocked &&
            lhs.idCheckConfigurationName == rhs.idCheckConfigurationName &&
            lhs.idCheckRequired == rhs.idCheckRequired &&
            lhs.name == rhs.name &&
            lhs.recipientType == rhs.recipientType &&
            lhs.roleName == rhs.roleName &&
            lhs.routingOrder == rhs.routingOrder &&
            lhs.templateRequiresIdLookup == rhs.templateRequiresIdLookup &&
            lhs.userNameLocked == rhs.userNameLocked
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accessCode?.hashValue)
        hasher.combine(accessCodeLocked?.hashValue)
        hasher.combine(accessCodeRequired?.hashValue)
        hasher.combine(email?.hashValue)
        hasher.combine(emailLocked?.hashValue)
        hasher.combine(idCheckConfigurationName?.hashValue)
        hasher.combine(idCheckRequired?.hashValue)
        hasher.combine(name?.hashValue)
        hasher.combine(recipientType?.hashValue)
        hasher.combine(roleName?.hashValue)
        hasher.combine(routingOrder?.hashValue)
        hasher.combine(templateRequiresIdLookup?.hashValue)
        hasher.combine(userNameLocked?.hashValue)
    }
}
