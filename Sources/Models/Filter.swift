//
// Filter.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/** Use this object to create a filtered view of the items in a folder. */
public final class Filter: Content {
    /** When set to **true**, the current user needs to take action on the item. */
    public var actionRequired: String?
    /** The number of days a sent envelope remains active before it expires. */
    public var expires: String?
    /** Filters for any combination of folder ids and folder types. The possible folder types are:  - `awaiting_my_signature` - `completed` - `draft` - `drafts` - `expiring_soon` - `inbox` - `out_for_signature` - `recyclebin` - `sentitems` - `waiting_for_others` */
    public var folderIds: String?
    /** The UTC DateTime of the beginning of a date range. If no value is provided, the default search is the previous 30 days. */
    public var fromDateTime: String?
    /** When set to **true**, the item is a template. */
    public var isTemplate: String?
    /** (Optional) The order in which to sort the results.  Valid values are:    * `asc`: Ascending order. * `desc`: Descending order.  */
    public var order: String?
    /** The field used to sort the results.  Example: `Created` */
    public var orderBy: String?
    /** Reserved for DocuSign. */
    public var searchTarget: String?
    /** A free text search field for searching across the items in a folder. The search looks for the text that you enter in the recipient names and emails, envelope custom fields, sender name, and subject. */
    public var searchText: String?
    /** The status of the envelope. By default, all statuses are returned.  For details, see [Envelope Status Code Descriptions](https://developers.docusign.com/esign-rest-api/guides/status-and-error-codes#envelope-status-code-descriptions). */
    public var status: String?
    /** The UTC DateTime of the end of a date range. If no value is provided, the default search is to the current date. */
    public var toDateTime: String?

    public init(actionRequired: String? = nil, expires: String? = nil, folderIds: String? = nil, fromDateTime: String? = nil, isTemplate: String? = nil, order: String? = nil, orderBy: String? = nil, searchTarget: String? = nil, searchText: String? = nil, status: String? = nil, toDateTime: String? = nil) {
        self.actionRequired = actionRequired
        self.expires = expires
        self.folderIds = folderIds
        self.fromDateTime = fromDateTime
        self.isTemplate = isTemplate
        self.order = order
        self.orderBy = orderBy
        self.searchTarget = searchTarget
        self.searchText = searchText
        self.status = status
        self.toDateTime = toDateTime
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case actionRequired
        case expires
        case folderIds
        case fromDateTime
        case isTemplate
        case order
        case orderBy
        case searchTarget
        case searchText
        case status
        case toDateTime
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(actionRequired, forKey: .actionRequired)
        try container.encodeIfPresent(expires, forKey: .expires)
        try container.encodeIfPresent(folderIds, forKey: .folderIds)
        try container.encodeIfPresent(fromDateTime, forKey: .fromDateTime)
        try container.encodeIfPresent(isTemplate, forKey: .isTemplate)
        try container.encodeIfPresent(order, forKey: .order)
        try container.encodeIfPresent(orderBy, forKey: .orderBy)
        try container.encodeIfPresent(searchTarget, forKey: .searchTarget)
        try container.encodeIfPresent(searchText, forKey: .searchText)
        try container.encodeIfPresent(status, forKey: .status)
        try container.encodeIfPresent(toDateTime, forKey: .toDateTime)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        actionRequired = try container.decodeIfPresent(String.self, forKey: .actionRequired)
        expires = try container.decodeIfPresent(String.self, forKey: .expires)
        folderIds = try container.decodeIfPresent(String.self, forKey: .folderIds)
        fromDateTime = try container.decodeIfPresent(String.self, forKey: .fromDateTime)
        isTemplate = try container.decodeIfPresent(String.self, forKey: .isTemplate)
        order = try container.decodeIfPresent(String.self, forKey: .order)
        orderBy = try container.decodeIfPresent(String.self, forKey: .orderBy)
        searchTarget = try container.decodeIfPresent(String.self, forKey: .searchTarget)
        searchText = try container.decodeIfPresent(String.self, forKey: .searchText)
        status = try container.decodeIfPresent(String.self, forKey: .status)
        toDateTime = try container.decodeIfPresent(String.self, forKey: .toDateTime)
    }
}

extension Filter: Hashable {
    public static func == (lhs: Filter, rhs: Filter) -> Bool {
        lhs.actionRequired == rhs.actionRequired &&
            lhs.expires == rhs.expires &&
            lhs.folderIds == rhs.folderIds &&
            lhs.fromDateTime == rhs.fromDateTime &&
            lhs.isTemplate == rhs.isTemplate &&
            lhs.order == rhs.order &&
            lhs.orderBy == rhs.orderBy &&
            lhs.searchTarget == rhs.searchTarget &&
            lhs.searchText == rhs.searchText &&
            lhs.status == rhs.status &&
            lhs.toDateTime == rhs.toDateTime
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(actionRequired?.hashValue)
        hasher.combine(expires?.hashValue)
        hasher.combine(folderIds?.hashValue)
        hasher.combine(fromDateTime?.hashValue)
        hasher.combine(isTemplate?.hashValue)
        hasher.combine(order?.hashValue)
        hasher.combine(orderBy?.hashValue)
        hasher.combine(searchTarget?.hashValue)
        hasher.combine(searchText?.hashValue)
        hasher.combine(status?.hashValue)
        hasher.combine(toDateTime?.hashValue)
    }
}
