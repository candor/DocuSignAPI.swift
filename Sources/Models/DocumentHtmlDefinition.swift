//
// DocumentHtmlDefinition.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/** Holds the properties that define how to generate the responsive-formatted HTML for the document. */
public final class DocumentHtmlDefinition: Content {
    /** Contains text that all display anchors must start with. Using at least 4 characters will improve anchor processing performance. */
    public var displayAnchorPrefix: String?
    /** An object that defines how to handle a section of the HTML in signing. This property enables an incoming request to make a section of the HTML collapsible and expandable or hidden from view. A start anchor, end anchor, or both are required. If the anchors are not found, the display anchor will be ignored. For a list of the available types, see the `display` enum. */
    public var displayAnchors: [DocumentHtmlDisplayAnchor]?
    /** The position on the page where the display section appears. */
    public var displayOrder: String?
    /** The number of the page on which the display section appears. */
    public var displayPageNumber: String?
    /** The GUID of the document. */
    public var documentGuid: String?
    /** The `documentId` is set by the API client. It is an integer that falls between `1` and 2,147,483,647. The value is encoded as a string without commas. The values `1`, `2`, `3`, and so on are typically used to identify the first few documents in an envelope. Tab definitions include a `documentId` property that specifies the document on which to place the tab. */
    public var documentId: String?
    /** Header text or an HTML tag to place above the responsive HTML block. */
    public var headerLabel: String?
    /** If set, the responsive HTML version of the signing document will only display on screens with the specified pixel width or less. If the screen is larger than the value that you specify, the default PDF version of the content displays instead. */
    public var maxScreenWidth: String?
    /** Holds a comma-separated list of HTML tags to remove if they have no text within their node (including child nodes). */
    public var removeEmptyTags: String?
    /** When set to **true**, the **Mobile-Friendly** toggle displays at the top of the screen on the user's mobile device. This toggle enables the user to switch between the mobile-friendly and PDF versions of a document. For example, the recipient can use this toggle to review the document using the PDF view before they finish signing. */
    public var showMobileOptimizedToggle: String?
    /** Specifies the type of responsive signing that will be used with the document. Valid strings are:  - `document`: The HTML signing page will be generated from the provided document. For details, see [Converting a PDF to a signable HTML document](https://developers.docusign.com/esign-rest-api/guides/responsive-signing/converting-pdf). - `html`: The HTML signing page will be passed directly. For details, see [Converting a PDF to a signable HTML document](https://developers.docusign.com/esign-rest-api/guides/responsive-signing/converting-pdf). */
    public var source: String?

    public init(displayAnchorPrefix: String? = nil, displayAnchors: [DocumentHtmlDisplayAnchor]? = nil, displayOrder: String? = nil, displayPageNumber: String? = nil, documentGuid: String? = nil, documentId: String? = nil, headerLabel: String? = nil, maxScreenWidth: String? = nil, removeEmptyTags: String? = nil, showMobileOptimizedToggle: String? = nil, source: String? = nil) {
        self.displayAnchorPrefix = displayAnchorPrefix
        self.displayAnchors = displayAnchors
        self.displayOrder = displayOrder
        self.displayPageNumber = displayPageNumber
        self.documentGuid = documentGuid
        self.documentId = documentId
        self.headerLabel = headerLabel
        self.maxScreenWidth = maxScreenWidth
        self.removeEmptyTags = removeEmptyTags
        self.showMobileOptimizedToggle = showMobileOptimizedToggle
        self.source = source
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case displayAnchorPrefix
        case displayAnchors
        case displayOrder
        case displayPageNumber
        case documentGuid
        case documentId
        case headerLabel
        case maxScreenWidth
        case removeEmptyTags
        case showMobileOptimizedToggle
        case source
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(displayAnchorPrefix, forKey: .displayAnchorPrefix)
        try container.encodeIfPresent(displayAnchors, forKey: .displayAnchors)
        try container.encodeIfPresent(displayOrder, forKey: .displayOrder)
        try container.encodeIfPresent(displayPageNumber, forKey: .displayPageNumber)
        try container.encodeIfPresent(documentGuid, forKey: .documentGuid)
        try container.encodeIfPresent(documentId, forKey: .documentId)
        try container.encodeIfPresent(headerLabel, forKey: .headerLabel)
        try container.encodeIfPresent(maxScreenWidth, forKey: .maxScreenWidth)
        try container.encodeIfPresent(removeEmptyTags, forKey: .removeEmptyTags)
        try container.encodeIfPresent(showMobileOptimizedToggle, forKey: .showMobileOptimizedToggle)
        try container.encodeIfPresent(source, forKey: .source)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        displayAnchorPrefix = try container.decodeIfPresent(String.self, forKey: .displayAnchorPrefix)
        displayAnchors = try container.decodeIfPresent([DocumentHtmlDisplayAnchor].self, forKey: .displayAnchors)
        displayOrder = try container.decodeIfPresent(String.self, forKey: .displayOrder)
        displayPageNumber = try container.decodeIfPresent(String.self, forKey: .displayPageNumber)
        documentGuid = try container.decodeIfPresent(String.self, forKey: .documentGuid)
        documentId = try container.decodeIfPresent(String.self, forKey: .documentId)
        headerLabel = try container.decodeIfPresent(String.self, forKey: .headerLabel)
        maxScreenWidth = try container.decodeIfPresent(String.self, forKey: .maxScreenWidth)
        removeEmptyTags = try container.decodeIfPresent(String.self, forKey: .removeEmptyTags)
        showMobileOptimizedToggle = try container.decodeIfPresent(String.self, forKey: .showMobileOptimizedToggle)
        source = try container.decodeIfPresent(String.self, forKey: .source)
    }
}

extension DocumentHtmlDefinition: Hashable {
    public static func == (lhs: DocumentHtmlDefinition, rhs: DocumentHtmlDefinition) -> Bool {
        lhs.displayAnchorPrefix == rhs.displayAnchorPrefix &&
            lhs.displayAnchors == rhs.displayAnchors &&
            lhs.displayOrder == rhs.displayOrder &&
            lhs.displayPageNumber == rhs.displayPageNumber &&
            lhs.documentGuid == rhs.documentGuid &&
            lhs.documentId == rhs.documentId &&
            lhs.headerLabel == rhs.headerLabel &&
            lhs.maxScreenWidth == rhs.maxScreenWidth &&
            lhs.removeEmptyTags == rhs.removeEmptyTags &&
            lhs.showMobileOptimizedToggle == rhs.showMobileOptimizedToggle &&
            lhs.source == rhs.source
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(displayAnchorPrefix?.hashValue)
        hasher.combine(displayAnchors?.hashValue)
        hasher.combine(displayOrder?.hashValue)
        hasher.combine(displayPageNumber?.hashValue)
        hasher.combine(documentGuid?.hashValue)
        hasher.combine(documentId?.hashValue)
        hasher.combine(headerLabel?.hashValue)
        hasher.combine(maxScreenWidth?.hashValue)
        hasher.combine(removeEmptyTags?.hashValue)
        hasher.combine(showMobileOptimizedToggle?.hashValue)
        hasher.combine(source?.hashValue)
    }
}
