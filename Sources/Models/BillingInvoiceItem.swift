//
// BillingInvoiceItem.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/** Contains information about an item on a billing invoice. */
public final class BillingInvoiceItem: Content {
    /** Reserved: TBD */
    public var chargeAmount: String?
    /** Reserved: TBD */
    public var chargeName: String?
    /** Reserved: TBD */
    public var invoiceItemId: String?
    /** The quantity of envelopes to add to the account. */
    public var quantity: String?
    /** Reserved: TBD */
    public var unitPrice: String?

    public init(chargeAmount: String? = nil, chargeName: String? = nil, invoiceItemId: String? = nil, quantity: String? = nil, unitPrice: String? = nil) {
        self.chargeAmount = chargeAmount
        self.chargeName = chargeName
        self.invoiceItemId = invoiceItemId
        self.quantity = quantity
        self.unitPrice = unitPrice
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case chargeAmount
        case chargeName
        case invoiceItemId
        case quantity
        case unitPrice
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(chargeAmount, forKey: .chargeAmount)
        try container.encodeIfPresent(chargeName, forKey: .chargeName)
        try container.encodeIfPresent(invoiceItemId, forKey: .invoiceItemId)
        try container.encodeIfPresent(quantity, forKey: .quantity)
        try container.encodeIfPresent(unitPrice, forKey: .unitPrice)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        chargeAmount = try container.decodeIfPresent(String.self, forKey: .chargeAmount)
        chargeName = try container.decodeIfPresent(String.self, forKey: .chargeName)
        invoiceItemId = try container.decodeIfPresent(String.self, forKey: .invoiceItemId)
        quantity = try container.decodeIfPresent(String.self, forKey: .quantity)
        unitPrice = try container.decodeIfPresent(String.self, forKey: .unitPrice)
    }
}

extension BillingInvoiceItem: Hashable {
    public static func == (lhs: BillingInvoiceItem, rhs: BillingInvoiceItem) -> Bool {
        lhs.chargeAmount == rhs.chargeAmount &&
            lhs.chargeName == rhs.chargeName &&
            lhs.invoiceItemId == rhs.invoiceItemId &&
            lhs.quantity == rhs.quantity &&
            lhs.unitPrice == rhs.unitPrice
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(chargeAmount?.hashValue)
        hasher.combine(chargeName?.hashValue)
        hasher.combine(invoiceItemId?.hashValue)
        hasher.combine(quantity?.hashValue)
        hasher.combine(unitPrice?.hashValue)
    }
}
