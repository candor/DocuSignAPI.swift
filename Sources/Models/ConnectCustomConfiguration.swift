//
// ConnectCustomConfiguration.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/**  */
public final class ConnectCustomConfiguration: Content {
    /** When set to **true**, data is sent to the urlToPublishTo web address. This option can be set to false to stop sending data while maintaining the Connect configuration information. */
    public var allowEnvelopePublish: String?
    /** When set to **true**  (default), DocuSign sends data to the designated Salesforce account through Connect. */
    public var allowSalesforcePublish: String?
    /** When set to **true**, the tracked envelope and recipient events for all users, including users that are added a later time, are sent through Connect. */
    public var allUsers: String?
    /** If you are using merge fields, this property specifies the type of the merge field. The only supported value is `salesforce`. */
    public var configurationType: String?
    /** The ID of the custom Connect configuration being accessed. */
    public var connectId: String?
    /** When set to **true**, Connect logging is turned on. We recommend that you enable this functionality, which helps you troubleshoot any issues.   You can have a maximum of 100 active logs in your account. You can view the entries in active logs in the **Logs** tab in the console. */
    public var enableLog: String?
    /** A list of envelope-level event statuses that will trigger Connect to send updates to the endpoint specified in the `url` property.   To receive notifications, you must include either an `envelopeEvents` node or a `recipientEvents` node. You do not need to specify both. */
    public var envelopeEvents: [String]?
    public var eventData: ConnectEventData?
    /** The id of an external folder. */
    public var externalFolderId: String?
    /** The label for an external folder. */
    public var externalFolderLabel: String?
    /** When set to **true**, the Connect Service includes the Certificate of Completion with completed envelopes.  */
    public var includeCertificateOfCompletion: String?
    /**  */
    public var includeCertSoapHeader: String?
    /** When set to **true**, the Document Fields associated with the envelope's documents are included in the notification messages. Document Fields are optional custom name-value pairs added to documents using the API.  */
    public var includeDocumentFields: String?
    /** reserved */
    public var includeDocuments: String?
    /** When set to **true**, if the envelope is voided, the Connect Service notification will include the void reason, as entered by the person that voided the envelope.  */
    public var includeEnvelopeVoidReason: String?
    /**  */
    public var includeHMAC: String?
    /** When set to **true**, Connect will include the sender account as Custom Field in the data. */
    public var includeSenderAccountasCustomField: String?
    /** When set to **true**, Connect will include the envelope time zone information. */
    public var includeTimeZoneInformation: String?
    /**  */
    public var name: String?
    /** The user's encrypted password hash. */
    public var password: String?
    /** An array of recipient event statuses that will trigger Connect to send notifications to your webhook listener at the url endpoint specified in the `url` property.   To receive notifications, you must include either an `envelopeEvents` node or a `recipientEvents` node. You do not need to specify both. */
    public var recipientEvents: [String]?
    /** When set to **true**, [Mutual TLS](https://developers.docusign.com/esign-rest-api/guides/mutual-tls-intro) authentication is enabled. */
    public var requireMutualTls: String?
    /** When set to **true**, event delivery acknowledgements are enabled for your Connect configuration.  DocuSign Connect awaits a valid 200 response from your application acknowledging that it received a message. If you do not acknowledge receiving an event notification message within 100 seconds, DocuSign treats the message as a failure and places it into a failure queue. It is imperative that you acknowledge successful receipt of Connect events as they occur by sending a 200 event back.  #### When set to **true** and Send Individual Messages (SIM) mode is activated  If the HTTP status response to a notification message is not in the range of 200-299, then the message delivery failed, and the configuration is marked as down.  The message will be queued and retried once per day. While a Connect configuration is marked down, subsequent notifications will not be tried. Instead they will be immediately queued with the reason `Pending`. When a message succeeds, all queued messages for the configuration will be tried immediately, in order.  There is a maximum of ten retries. Alternately, you can use **Republish Connect Information** to manually republish the notification.  #### When set to **true** and SIM mode is not activated  If the HTTP Status response to a notification message is not in the range of 200-299,  then the message delivery failed, and the message is queued.  The message will be retried after at least a day the next time a subsequent message is successfully sent to this configuration (subscription).  Subsequent notifications will be tried when they occur. There is a maximum of ten retries. Alternately, you can use **Republish Connect Information** to manually republish the notification.  #### When set to **false**  When `requiresAcknowledgement` is set to **false** and you do not acknowledge receiving an event notification message within 100 seconds, DocuSign treats the message as a failure and determines that the server is unavailable. It does not retry to send the notification message, and you must handle the failure manually.   */
    public var requiresAcknowledgement: String?
    /** The version of the Salesforce API that you are using. */
    public var salesforceApiVersion: String?
    /**  */
    public var salesforceAuthcode: String?
    /**  */
    public var salesforceCallBackUrl: String?
    /** When set to **true**, DocuSign can use documents in your Salesforce account for sending and signing. */
    public var salesforceDocumentsAsContentFiles: String?
    /**  */
    public var senderOverride: String?
    /** This property sets the items that are available for selection when adding or editing Connect objects.  */
    public var senderSelectableItems: [String]?
    /** An array of Salesforce objects. */
    public var sfObjects: [ConnectSalesforceObject]?
    /** When set to **true**, Mutual TLS will be enabled for notifications. Mutual TLS must be initiated by the listener (the customer's web server) during the TLS handshake protocol.  */
    public var signMessageWithX509Certificate: String?
    /** The namespace of the SOAP interface.  **Note**: If `useSoapInterface` is set to **true**, you must set this value. */
    public var soapNamespace: String?
    /** This is the web address and name of your listener or Retrieving Service endpoint. You need to include HTTPS:// in the web address. */
    public var urlToPublishTo: String?
    /** A comma-separated list of userIds. This sets the users associated with the tracked envelope and recipient events. When a tracked event occurs for a set user, the a notification message is sent to your Connect listener.  **Note**: If allUsers is set to `false` then you must provide a list of user ids. */
    public var userIds: [String]?
    /** The name of the user. */
    public var userName: String?
    /** When set to **true**, the notifications are sent to your endpoint as SOAP requests.  */
    public var useSoapInterface: String?

    public init(allowEnvelopePublish: String? = nil, allowSalesforcePublish: String? = nil, allUsers: String? = nil, configurationType: String? = nil, connectId: String? = nil, enableLog: String? = nil, envelopeEvents: [String]? = nil, eventData: ConnectEventData? = nil, externalFolderId: String? = nil, externalFolderLabel: String? = nil, includeCertificateOfCompletion: String? = nil, includeCertSoapHeader: String? = nil, includeDocumentFields: String? = nil, includeDocuments: String? = nil, includeEnvelopeVoidReason: String? = nil, includeHMAC: String? = nil, includeSenderAccountasCustomField: String? = nil, includeTimeZoneInformation: String? = nil, name: String? = nil, password: String? = nil, recipientEvents: [String]? = nil, requireMutualTls: String? = nil, requiresAcknowledgement: String? = nil, salesforceApiVersion: String? = nil, salesforceAuthcode: String? = nil, salesforceCallBackUrl: String? = nil, salesforceDocumentsAsContentFiles: String? = nil, senderOverride: String? = nil, senderSelectableItems: [String]? = nil, sfObjects: [ConnectSalesforceObject]? = nil, signMessageWithX509Certificate: String? = nil, soapNamespace: String? = nil, urlToPublishTo: String? = nil, userIds: [String]? = nil, userName: String? = nil, useSoapInterface: String? = nil) {
        self.allowEnvelopePublish = allowEnvelopePublish
        self.allowSalesforcePublish = allowSalesforcePublish
        self.allUsers = allUsers
        self.configurationType = configurationType
        self.connectId = connectId
        self.enableLog = enableLog
        self.envelopeEvents = envelopeEvents
        self.eventData = eventData
        self.externalFolderId = externalFolderId
        self.externalFolderLabel = externalFolderLabel
        self.includeCertificateOfCompletion = includeCertificateOfCompletion
        self.includeCertSoapHeader = includeCertSoapHeader
        self.includeDocumentFields = includeDocumentFields
        self.includeDocuments = includeDocuments
        self.includeEnvelopeVoidReason = includeEnvelopeVoidReason
        self.includeHMAC = includeHMAC
        self.includeSenderAccountasCustomField = includeSenderAccountasCustomField
        self.includeTimeZoneInformation = includeTimeZoneInformation
        self.name = name
        self.password = password
        self.recipientEvents = recipientEvents
        self.requireMutualTls = requireMutualTls
        self.requiresAcknowledgement = requiresAcknowledgement
        self.salesforceApiVersion = salesforceApiVersion
        self.salesforceAuthcode = salesforceAuthcode
        self.salesforceCallBackUrl = salesforceCallBackUrl
        self.salesforceDocumentsAsContentFiles = salesforceDocumentsAsContentFiles
        self.senderOverride = senderOverride
        self.senderSelectableItems = senderSelectableItems
        self.sfObjects = sfObjects
        self.signMessageWithX509Certificate = signMessageWithX509Certificate
        self.soapNamespace = soapNamespace
        self.urlToPublishTo = urlToPublishTo
        self.userIds = userIds
        self.userName = userName
        self.useSoapInterface = useSoapInterface
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case allowEnvelopePublish
        case allowSalesforcePublish
        case allUsers
        case configurationType
        case connectId
        case enableLog
        case envelopeEvents
        case eventData
        case externalFolderId
        case externalFolderLabel
        case includeCertificateOfCompletion
        case includeCertSoapHeader
        case includeDocumentFields
        case includeDocuments
        case includeEnvelopeVoidReason
        case includeHMAC
        case includeSenderAccountasCustomField
        case includeTimeZoneInformation
        case name
        case password
        case recipientEvents
        case requireMutualTls
        case requiresAcknowledgement
        case salesforceApiVersion
        case salesforceAuthcode
        case salesforceCallBackUrl
        case salesforceDocumentsAsContentFiles
        case senderOverride
        case senderSelectableItems
        case sfObjects
        case signMessageWithX509Certificate
        case soapNamespace
        case urlToPublishTo
        case userIds
        case userName
        case useSoapInterface
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(allowEnvelopePublish, forKey: .allowEnvelopePublish)
        try container.encodeIfPresent(allowSalesforcePublish, forKey: .allowSalesforcePublish)
        try container.encodeIfPresent(allUsers, forKey: .allUsers)
        try container.encodeIfPresent(configurationType, forKey: .configurationType)
        try container.encodeIfPresent(connectId, forKey: .connectId)
        try container.encodeIfPresent(enableLog, forKey: .enableLog)
        try container.encodeIfPresent(envelopeEvents, forKey: .envelopeEvents)
        try container.encodeIfPresent(eventData, forKey: .eventData)
        try container.encodeIfPresent(externalFolderId, forKey: .externalFolderId)
        try container.encodeIfPresent(externalFolderLabel, forKey: .externalFolderLabel)
        try container.encodeIfPresent(includeCertificateOfCompletion, forKey: .includeCertificateOfCompletion)
        try container.encodeIfPresent(includeCertSoapHeader, forKey: .includeCertSoapHeader)
        try container.encodeIfPresent(includeDocumentFields, forKey: .includeDocumentFields)
        try container.encodeIfPresent(includeDocuments, forKey: .includeDocuments)
        try container.encodeIfPresent(includeEnvelopeVoidReason, forKey: .includeEnvelopeVoidReason)
        try container.encodeIfPresent(includeHMAC, forKey: .includeHMAC)
        try container.encodeIfPresent(includeSenderAccountasCustomField, forKey: .includeSenderAccountasCustomField)
        try container.encodeIfPresent(includeTimeZoneInformation, forKey: .includeTimeZoneInformation)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(password, forKey: .password)
        try container.encodeIfPresent(recipientEvents, forKey: .recipientEvents)
        try container.encodeIfPresent(requireMutualTls, forKey: .requireMutualTls)
        try container.encodeIfPresent(requiresAcknowledgement, forKey: .requiresAcknowledgement)
        try container.encodeIfPresent(salesforceApiVersion, forKey: .salesforceApiVersion)
        try container.encodeIfPresent(salesforceAuthcode, forKey: .salesforceAuthcode)
        try container.encodeIfPresent(salesforceCallBackUrl, forKey: .salesforceCallBackUrl)
        try container.encodeIfPresent(salesforceDocumentsAsContentFiles, forKey: .salesforceDocumentsAsContentFiles)
        try container.encodeIfPresent(senderOverride, forKey: .senderOverride)
        try container.encodeIfPresent(senderSelectableItems, forKey: .senderSelectableItems)
        try container.encodeIfPresent(sfObjects, forKey: .sfObjects)
        try container.encodeIfPresent(signMessageWithX509Certificate, forKey: .signMessageWithX509Certificate)
        try container.encodeIfPresent(soapNamespace, forKey: .soapNamespace)
        try container.encodeIfPresent(urlToPublishTo, forKey: .urlToPublishTo)
        try container.encodeIfPresent(userIds, forKey: .userIds)
        try container.encodeIfPresent(userName, forKey: .userName)
        try container.encodeIfPresent(useSoapInterface, forKey: .useSoapInterface)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        allowEnvelopePublish = try container.decodeIfPresent(String.self, forKey: .allowEnvelopePublish)
        allowSalesforcePublish = try container.decodeIfPresent(String.self, forKey: .allowSalesforcePublish)
        allUsers = try container.decodeIfPresent(String.self, forKey: .allUsers)
        configurationType = try container.decodeIfPresent(String.self, forKey: .configurationType)
        connectId = try container.decodeIfPresent(String.self, forKey: .connectId)
        enableLog = try container.decodeIfPresent(String.self, forKey: .enableLog)
        envelopeEvents = try container.decodeIfPresent([String].self, forKey: .envelopeEvents)
        eventData = try container.decodeIfPresent(ConnectEventData.self, forKey: .eventData)
        externalFolderId = try container.decodeIfPresent(String.self, forKey: .externalFolderId)
        externalFolderLabel = try container.decodeIfPresent(String.self, forKey: .externalFolderLabel)
        includeCertificateOfCompletion = try container.decodeIfPresent(String.self, forKey: .includeCertificateOfCompletion)
        includeCertSoapHeader = try container.decodeIfPresent(String.self, forKey: .includeCertSoapHeader)
        includeDocumentFields = try container.decodeIfPresent(String.self, forKey: .includeDocumentFields)
        includeDocuments = try container.decodeIfPresent(String.self, forKey: .includeDocuments)
        includeEnvelopeVoidReason = try container.decodeIfPresent(String.self, forKey: .includeEnvelopeVoidReason)
        includeHMAC = try container.decodeIfPresent(String.self, forKey: .includeHMAC)
        includeSenderAccountasCustomField = try container.decodeIfPresent(String.self, forKey: .includeSenderAccountasCustomField)
        includeTimeZoneInformation = try container.decodeIfPresent(String.self, forKey: .includeTimeZoneInformation)
        name = try container.decodeIfPresent(String.self, forKey: .name)
        password = try container.decodeIfPresent(String.self, forKey: .password)
        recipientEvents = try container.decodeIfPresent([String].self, forKey: .recipientEvents)
        requireMutualTls = try container.decodeIfPresent(String.self, forKey: .requireMutualTls)
        requiresAcknowledgement = try container.decodeIfPresent(String.self, forKey: .requiresAcknowledgement)
        salesforceApiVersion = try container.decodeIfPresent(String.self, forKey: .salesforceApiVersion)
        salesforceAuthcode = try container.decodeIfPresent(String.self, forKey: .salesforceAuthcode)
        salesforceCallBackUrl = try container.decodeIfPresent(String.self, forKey: .salesforceCallBackUrl)
        salesforceDocumentsAsContentFiles = try container.decodeIfPresent(String.self, forKey: .salesforceDocumentsAsContentFiles)
        senderOverride = try container.decodeIfPresent(String.self, forKey: .senderOverride)
        senderSelectableItems = try container.decodeIfPresent([String].self, forKey: .senderSelectableItems)
        sfObjects = try container.decodeIfPresent([ConnectSalesforceObject].self, forKey: .sfObjects)
        signMessageWithX509Certificate = try container.decodeIfPresent(String.self, forKey: .signMessageWithX509Certificate)
        soapNamespace = try container.decodeIfPresent(String.self, forKey: .soapNamespace)
        urlToPublishTo = try container.decodeIfPresent(String.self, forKey: .urlToPublishTo)
        userIds = try container.decodeIfPresent([String].self, forKey: .userIds)
        userName = try container.decodeIfPresent(String.self, forKey: .userName)
        useSoapInterface = try container.decodeIfPresent(String.self, forKey: .useSoapInterface)
    }
}

extension ConnectCustomConfiguration: Hashable {
    public static func == (lhs: ConnectCustomConfiguration, rhs: ConnectCustomConfiguration) -> Bool {
        lhs.allowEnvelopePublish == rhs.allowEnvelopePublish &&
            lhs.allowSalesforcePublish == rhs.allowSalesforcePublish &&
            lhs.allUsers == rhs.allUsers &&
            lhs.configurationType == rhs.configurationType &&
            lhs.connectId == rhs.connectId &&
            lhs.enableLog == rhs.enableLog &&
            lhs.envelopeEvents == rhs.envelopeEvents &&
            lhs.eventData == rhs.eventData &&
            lhs.externalFolderId == rhs.externalFolderId &&
            lhs.externalFolderLabel == rhs.externalFolderLabel &&
            lhs.includeCertificateOfCompletion == rhs.includeCertificateOfCompletion &&
            lhs.includeCertSoapHeader == rhs.includeCertSoapHeader &&
            lhs.includeDocumentFields == rhs.includeDocumentFields &&
            lhs.includeDocuments == rhs.includeDocuments &&
            lhs.includeEnvelopeVoidReason == rhs.includeEnvelopeVoidReason &&
            lhs.includeHMAC == rhs.includeHMAC &&
            lhs.includeSenderAccountasCustomField == rhs.includeSenderAccountasCustomField &&
            lhs.includeTimeZoneInformation == rhs.includeTimeZoneInformation &&
            lhs.name == rhs.name &&
            lhs.password == rhs.password &&
            lhs.recipientEvents == rhs.recipientEvents &&
            lhs.requireMutualTls == rhs.requireMutualTls &&
            lhs.requiresAcknowledgement == rhs.requiresAcknowledgement &&
            lhs.salesforceApiVersion == rhs.salesforceApiVersion &&
            lhs.salesforceAuthcode == rhs.salesforceAuthcode &&
            lhs.salesforceCallBackUrl == rhs.salesforceCallBackUrl &&
            lhs.salesforceDocumentsAsContentFiles == rhs.salesforceDocumentsAsContentFiles &&
            lhs.senderOverride == rhs.senderOverride &&
            lhs.senderSelectableItems == rhs.senderSelectableItems &&
            lhs.sfObjects == rhs.sfObjects &&
            lhs.signMessageWithX509Certificate == rhs.signMessageWithX509Certificate &&
            lhs.soapNamespace == rhs.soapNamespace &&
            lhs.urlToPublishTo == rhs.urlToPublishTo &&
            lhs.userIds == rhs.userIds &&
            lhs.userName == rhs.userName &&
            lhs.useSoapInterface == rhs.useSoapInterface
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(allowEnvelopePublish?.hashValue)
        hasher.combine(allowSalesforcePublish?.hashValue)
        hasher.combine(allUsers?.hashValue)
        hasher.combine(configurationType?.hashValue)
        hasher.combine(connectId?.hashValue)
        hasher.combine(enableLog?.hashValue)
        hasher.combine(envelopeEvents?.hashValue)
        hasher.combine(eventData?.hashValue)
        hasher.combine(externalFolderId?.hashValue)
        hasher.combine(externalFolderLabel?.hashValue)
        hasher.combine(includeCertificateOfCompletion?.hashValue)
        hasher.combine(includeCertSoapHeader?.hashValue)
        hasher.combine(includeDocumentFields?.hashValue)
        hasher.combine(includeDocuments?.hashValue)
        hasher.combine(includeEnvelopeVoidReason?.hashValue)
        hasher.combine(includeHMAC?.hashValue)
        hasher.combine(includeSenderAccountasCustomField?.hashValue)
        hasher.combine(includeTimeZoneInformation?.hashValue)
        hasher.combine(name?.hashValue)
        hasher.combine(password?.hashValue)
        hasher.combine(recipientEvents?.hashValue)
        hasher.combine(requireMutualTls?.hashValue)
        hasher.combine(requiresAcknowledgement?.hashValue)
        hasher.combine(salesforceApiVersion?.hashValue)
        hasher.combine(salesforceAuthcode?.hashValue)
        hasher.combine(salesforceCallBackUrl?.hashValue)
        hasher.combine(salesforceDocumentsAsContentFiles?.hashValue)
        hasher.combine(senderOverride?.hashValue)
        hasher.combine(senderSelectableItems?.hashValue)
        hasher.combine(sfObjects?.hashValue)
        hasher.combine(signMessageWithX509Certificate?.hashValue)
        hasher.combine(soapNamespace?.hashValue)
        hasher.combine(urlToPublishTo?.hashValue)
        hasher.combine(userIds?.hashValue)
        hasher.combine(userName?.hashValue)
        hasher.combine(useSoapInterface?.hashValue)
    }
}
