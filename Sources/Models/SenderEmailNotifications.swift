//
// SenderEmailNotifications.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/** Contains the settings for the email notifications that senders receive about the envelopes that they send. */
public final class SenderEmailNotifications: Content {
    /** When set to **true**, the sender receives an email notification if the signer changes. */
    public var changedSigner: String?
    /** When set to **true**, the user receives only comments that mention their own user name. */
    public var commentsOnlyPrivateAndMention: String?
    /** When set to **true**, the user receives all comments. */
    public var commentsReceiveAll: String?
    /** When set to **true**, the sender receives an email notification if envelope delivery fails. */
    public var deliveryFailed: String?
    /** When set to **true**, the user receives an email notification when the envelope has been completed. */
    public var envelopeComplete: String?
    /** When set to **true**, the user receives an email notification if offline signing failed. */
    public var offlineSigningFailed: String?
    /**  */
    public var powerformResponsesLimitNotificationEmail: String?
    /** When set to **true**, the user receives an email notification when a document purge occurs. */
    public var purgeDocuments: String?
    /** When set to **true**, the sender receives notification that a recipient viewed the envelope. */
    public var recipientViewed: String?
    /** When set to **true**, the sender receives notification that the envelope was declined. */
    public var senderEnvelopeDeclined: String?
    /** When set to **true**, the user receives an email notification if consent is withdrawn. */
    public var withdrawnConsent: String?

    public init(changedSigner: String? = nil, commentsOnlyPrivateAndMention: String? = nil, commentsReceiveAll: String? = nil, deliveryFailed: String? = nil, envelopeComplete: String? = nil, offlineSigningFailed: String? = nil, powerformResponsesLimitNotificationEmail: String? = nil, purgeDocuments: String? = nil, recipientViewed: String? = nil, senderEnvelopeDeclined: String? = nil, withdrawnConsent: String? = nil) {
        self.changedSigner = changedSigner
        self.commentsOnlyPrivateAndMention = commentsOnlyPrivateAndMention
        self.commentsReceiveAll = commentsReceiveAll
        self.deliveryFailed = deliveryFailed
        self.envelopeComplete = envelopeComplete
        self.offlineSigningFailed = offlineSigningFailed
        self.powerformResponsesLimitNotificationEmail = powerformResponsesLimitNotificationEmail
        self.purgeDocuments = purgeDocuments
        self.recipientViewed = recipientViewed
        self.senderEnvelopeDeclined = senderEnvelopeDeclined
        self.withdrawnConsent = withdrawnConsent
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case changedSigner
        case commentsOnlyPrivateAndMention
        case commentsReceiveAll
        case deliveryFailed
        case envelopeComplete
        case offlineSigningFailed
        case powerformResponsesLimitNotificationEmail
        case purgeDocuments
        case recipientViewed
        case senderEnvelopeDeclined
        case withdrawnConsent
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(changedSigner, forKey: .changedSigner)
        try container.encodeIfPresent(commentsOnlyPrivateAndMention, forKey: .commentsOnlyPrivateAndMention)
        try container.encodeIfPresent(commentsReceiveAll, forKey: .commentsReceiveAll)
        try container.encodeIfPresent(deliveryFailed, forKey: .deliveryFailed)
        try container.encodeIfPresent(envelopeComplete, forKey: .envelopeComplete)
        try container.encodeIfPresent(offlineSigningFailed, forKey: .offlineSigningFailed)
        try container.encodeIfPresent(powerformResponsesLimitNotificationEmail, forKey: .powerformResponsesLimitNotificationEmail)
        try container.encodeIfPresent(purgeDocuments, forKey: .purgeDocuments)
        try container.encodeIfPresent(recipientViewed, forKey: .recipientViewed)
        try container.encodeIfPresent(senderEnvelopeDeclined, forKey: .senderEnvelopeDeclined)
        try container.encodeIfPresent(withdrawnConsent, forKey: .withdrawnConsent)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        changedSigner = try container.decodeIfPresent(String.self, forKey: .changedSigner)
        commentsOnlyPrivateAndMention = try container.decodeIfPresent(String.self, forKey: .commentsOnlyPrivateAndMention)
        commentsReceiveAll = try container.decodeIfPresent(String.self, forKey: .commentsReceiveAll)
        deliveryFailed = try container.decodeIfPresent(String.self, forKey: .deliveryFailed)
        envelopeComplete = try container.decodeIfPresent(String.self, forKey: .envelopeComplete)
        offlineSigningFailed = try container.decodeIfPresent(String.self, forKey: .offlineSigningFailed)
        powerformResponsesLimitNotificationEmail = try container.decodeIfPresent(String.self, forKey: .powerformResponsesLimitNotificationEmail)
        purgeDocuments = try container.decodeIfPresent(String.self, forKey: .purgeDocuments)
        recipientViewed = try container.decodeIfPresent(String.self, forKey: .recipientViewed)
        senderEnvelopeDeclined = try container.decodeIfPresent(String.self, forKey: .senderEnvelopeDeclined)
        withdrawnConsent = try container.decodeIfPresent(String.self, forKey: .withdrawnConsent)
    }
}

extension SenderEmailNotifications: Hashable {
    public static func == (lhs: SenderEmailNotifications, rhs: SenderEmailNotifications) -> Bool {
        lhs.changedSigner == rhs.changedSigner &&
            lhs.commentsOnlyPrivateAndMention == rhs.commentsOnlyPrivateAndMention &&
            lhs.commentsReceiveAll == rhs.commentsReceiveAll &&
            lhs.deliveryFailed == rhs.deliveryFailed &&
            lhs.envelopeComplete == rhs.envelopeComplete &&
            lhs.offlineSigningFailed == rhs.offlineSigningFailed &&
            lhs.powerformResponsesLimitNotificationEmail == rhs.powerformResponsesLimitNotificationEmail &&
            lhs.purgeDocuments == rhs.purgeDocuments &&
            lhs.recipientViewed == rhs.recipientViewed &&
            lhs.senderEnvelopeDeclined == rhs.senderEnvelopeDeclined &&
            lhs.withdrawnConsent == rhs.withdrawnConsent
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(changedSigner?.hashValue)
        hasher.combine(commentsOnlyPrivateAndMention?.hashValue)
        hasher.combine(commentsReceiveAll?.hashValue)
        hasher.combine(deliveryFailed?.hashValue)
        hasher.combine(envelopeComplete?.hashValue)
        hasher.combine(offlineSigningFailed?.hashValue)
        hasher.combine(powerformResponsesLimitNotificationEmail?.hashValue)
        hasher.combine(purgeDocuments?.hashValue)
        hasher.combine(recipientViewed?.hashValue)
        hasher.combine(senderEnvelopeDeclined?.hashValue)
        hasher.combine(withdrawnConsent?.hashValue)
    }
}
