//
// PowerForms.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/** The PowerForms resource enables you to create fillable forms that you can email or make available for self service on the web. */
public final class PowerForms: Content {
    /** The id of the user who created the PowerForm. This property is returned in a response only when you set the `include_created_by` query parameter to **true**. */
    public var createdBy: String?
    /** The date and time that the PowerForm was created. */
    public var createdDateTime: String?
    /** For a PowerForm that is sent by email, this is the body of the email message sent to the recipients.  Maximum length: 10000 characters. */
    public var emailBody: String?
    /** Sets the envelope name for the envelopes that the PowerForm generates. One option is to make this property the same as the subject from the template.   You can customize the subject line to include a recipient's name or email address by using merge fields. For information about adding merge fields to the email subject, see [Template Email Subject Merge Fields](https://developers.docusign.com/esign-rest-api/reference/Templates/Templates/create#template-email-subject-merge-fields).  */
    public var emailSubject: String?
    /** An array of envelope objects that contain information about the envelopes that are associated with the PowerForm. */
    public var envelopes: [Envelope]?
    public var errorDetails: ErrorDetails?
    /** The instructions that display on the landing page for the first recipient. These instructions are important if the recipient accesses the PowerForm by a method other than email. When you include instructions, they display as an introduction after the recipient accesses the PowerForm. */
    public var instructions: String?
    /** When **true**, indicates that the PowerForm is active and can be sent to recipients. This is the default value.   When **false**, the PowerForm cannot be emailed or accessed by a recipient, even if they arrive at the PowerForm URL.   If a recipient attempts to sign an inactive PowerForm, an error message informs the recipient that the document is not active and suggests that they contact the sender. */
    public var isActive: String?
    /** The date and time that the PowerForm was last used. */
    public var lastUsed: String?
    /** The length of time before the same recipient can sign the same PowerForm again. This property is used in combination with the `limitUseIntervalUnits` property. */
    public var limitUseInterval: String?
    /** When **true**, the `limitUseInterval` is enabled. */
    public var limitUseIntervalEnabled: String?
    /** The units associated with the `limitUseInterval`. Valid values are:  - `minutes` - `hours` - `days` - `weeks` - `months`  For example, to limit a recipient to signing once per year, set the `limitUseInterval` to 365 and the `limitUseIntervalUnits` to `days`.  */
    public var limitUseIntervalUnits: String?
    /** When set to **true**, you can set a maximum number of uses for the PowerForm. */
    public var maxUseEnabled: String?
    /** The name of the PowerForm. */
    public var name: String?
    /** The id of the PowerForm. */
    public var powerFormId: String?
    /** The URL for the PowerForm. */
    public var powerFormUrl: String?
    /** An array of `powerFormRecipient` objects.  **Note**: For self-service documents where you do not know who the recipients are in advance, you can enter generic information for the `role` property and leave other details (such as `name` and `email`) blank. */
    public var recipients: [PowerFormRecipient]?
    /** The name of the sender.   **Note**: The default sender for a PowerForm is the PowerForm Administrator who created it. */
    public var senderName: String?
    /** The id of the sender. */
    public var senderUserId: String?
    /** The signing method to use. Valid values are:   - `email`: This mode verifies the recipient's identity by using email authentication before the recipient can sign a document.  - `direct`: This mode does not require any verification. We recommend that you use this signing method only when another form of authentication is in use.  **Note**: In the account settings, `enablePowerFormDirect` must be **true** to use `direct` as the `signingMode`.  For more information about signing modes, see the [overview of the Create method](https://developers.docusign.com/esign-rest-api/reference/PowerForms/PowerForms/create). */
    public var signingMode: String?
    /** The id of the template used to create the PowerForm. */
    public var templateId: String?
    /** The name of the template used to create the PowerForm. */
    public var templateName: String?
    /** The number of times the PowerForm has been used.  */
    public var timesUsed: String?
    /** The URI for the PowerForm. */
    public var uri: String?
    /** The number of times that the PowerForm can still be used. If no use limit is set, the value is `Unlimited`.  */
    public var usesRemaining: String?

    public init(createdBy: String? = nil, createdDateTime: String? = nil, emailBody: String? = nil, emailSubject: String? = nil, envelopes: [Envelope]? = nil, errorDetails: ErrorDetails? = nil, instructions: String? = nil, isActive: String? = nil, lastUsed: String? = nil, limitUseInterval: String? = nil, limitUseIntervalEnabled: String? = nil, limitUseIntervalUnits: String? = nil, maxUseEnabled: String? = nil, name: String? = nil, powerFormId: String? = nil, powerFormUrl: String? = nil, recipients: [PowerFormRecipient]? = nil, senderName: String? = nil, senderUserId: String? = nil, signingMode: String? = nil, templateId: String? = nil, templateName: String? = nil, timesUsed: String? = nil, uri: String? = nil, usesRemaining: String? = nil) {
        self.createdBy = createdBy
        self.createdDateTime = createdDateTime
        self.emailBody = emailBody
        self.emailSubject = emailSubject
        self.envelopes = envelopes
        self.errorDetails = errorDetails
        self.instructions = instructions
        self.isActive = isActive
        self.lastUsed = lastUsed
        self.limitUseInterval = limitUseInterval
        self.limitUseIntervalEnabled = limitUseIntervalEnabled
        self.limitUseIntervalUnits = limitUseIntervalUnits
        self.maxUseEnabled = maxUseEnabled
        self.name = name
        self.powerFormId = powerFormId
        self.powerFormUrl = powerFormUrl
        self.recipients = recipients
        self.senderName = senderName
        self.senderUserId = senderUserId
        self.signingMode = signingMode
        self.templateId = templateId
        self.templateName = templateName
        self.timesUsed = timesUsed
        self.uri = uri
        self.usesRemaining = usesRemaining
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case createdBy
        case createdDateTime
        case emailBody
        case emailSubject
        case envelopes
        case errorDetails
        case instructions
        case isActive
        case lastUsed
        case limitUseInterval
        case limitUseIntervalEnabled
        case limitUseIntervalUnits
        case maxUseEnabled
        case name
        case powerFormId
        case powerFormUrl
        case recipients
        case senderName
        case senderUserId
        case signingMode
        case templateId
        case templateName
        case timesUsed
        case uri
        case usesRemaining
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(createdBy, forKey: .createdBy)
        try container.encodeIfPresent(createdDateTime, forKey: .createdDateTime)
        try container.encodeIfPresent(emailBody, forKey: .emailBody)
        try container.encodeIfPresent(emailSubject, forKey: .emailSubject)
        try container.encodeIfPresent(envelopes, forKey: .envelopes)
        try container.encodeIfPresent(errorDetails, forKey: .errorDetails)
        try container.encodeIfPresent(instructions, forKey: .instructions)
        try container.encodeIfPresent(isActive, forKey: .isActive)
        try container.encodeIfPresent(lastUsed, forKey: .lastUsed)
        try container.encodeIfPresent(limitUseInterval, forKey: .limitUseInterval)
        try container.encodeIfPresent(limitUseIntervalEnabled, forKey: .limitUseIntervalEnabled)
        try container.encodeIfPresent(limitUseIntervalUnits, forKey: .limitUseIntervalUnits)
        try container.encodeIfPresent(maxUseEnabled, forKey: .maxUseEnabled)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(powerFormId, forKey: .powerFormId)
        try container.encodeIfPresent(powerFormUrl, forKey: .powerFormUrl)
        try container.encodeIfPresent(recipients, forKey: .recipients)
        try container.encodeIfPresent(senderName, forKey: .senderName)
        try container.encodeIfPresent(senderUserId, forKey: .senderUserId)
        try container.encodeIfPresent(signingMode, forKey: .signingMode)
        try container.encodeIfPresent(templateId, forKey: .templateId)
        try container.encodeIfPresent(templateName, forKey: .templateName)
        try container.encodeIfPresent(timesUsed, forKey: .timesUsed)
        try container.encodeIfPresent(uri, forKey: .uri)
        try container.encodeIfPresent(usesRemaining, forKey: .usesRemaining)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        createdBy = try container.decodeIfPresent(String.self, forKey: .createdBy)
        createdDateTime = try container.decodeIfPresent(String.self, forKey: .createdDateTime)
        emailBody = try container.decodeIfPresent(String.self, forKey: .emailBody)
        emailSubject = try container.decodeIfPresent(String.self, forKey: .emailSubject)
        envelopes = try container.decodeIfPresent([Envelope].self, forKey: .envelopes)
        errorDetails = try container.decodeIfPresent(ErrorDetails.self, forKey: .errorDetails)
        instructions = try container.decodeIfPresent(String.self, forKey: .instructions)
        isActive = try container.decodeIfPresent(String.self, forKey: .isActive)
        lastUsed = try container.decodeIfPresent(String.self, forKey: .lastUsed)
        limitUseInterval = try container.decodeIfPresent(String.self, forKey: .limitUseInterval)
        limitUseIntervalEnabled = try container.decodeIfPresent(String.self, forKey: .limitUseIntervalEnabled)
        limitUseIntervalUnits = try container.decodeIfPresent(String.self, forKey: .limitUseIntervalUnits)
        maxUseEnabled = try container.decodeIfPresent(String.self, forKey: .maxUseEnabled)
        name = try container.decodeIfPresent(String.self, forKey: .name)
        powerFormId = try container.decodeIfPresent(String.self, forKey: .powerFormId)
        powerFormUrl = try container.decodeIfPresent(String.self, forKey: .powerFormUrl)
        recipients = try container.decodeIfPresent([PowerFormRecipient].self, forKey: .recipients)
        senderName = try container.decodeIfPresent(String.self, forKey: .senderName)
        senderUserId = try container.decodeIfPresent(String.self, forKey: .senderUserId)
        signingMode = try container.decodeIfPresent(String.self, forKey: .signingMode)
        templateId = try container.decodeIfPresent(String.self, forKey: .templateId)
        templateName = try container.decodeIfPresent(String.self, forKey: .templateName)
        timesUsed = try container.decodeIfPresent(String.self, forKey: .timesUsed)
        uri = try container.decodeIfPresent(String.self, forKey: .uri)
        usesRemaining = try container.decodeIfPresent(String.self, forKey: .usesRemaining)
    }
}

extension PowerForms: Hashable {
    public static func == (lhs: PowerForms, rhs: PowerForms) -> Bool {
        lhs.createdBy == rhs.createdBy &&
            lhs.createdDateTime == rhs.createdDateTime &&
            lhs.emailBody == rhs.emailBody &&
            lhs.emailSubject == rhs.emailSubject &&
            lhs.envelopes == rhs.envelopes &&
            lhs.errorDetails == rhs.errorDetails &&
            lhs.instructions == rhs.instructions &&
            lhs.isActive == rhs.isActive &&
            lhs.lastUsed == rhs.lastUsed &&
            lhs.limitUseInterval == rhs.limitUseInterval &&
            lhs.limitUseIntervalEnabled == rhs.limitUseIntervalEnabled &&
            lhs.limitUseIntervalUnits == rhs.limitUseIntervalUnits &&
            lhs.maxUseEnabled == rhs.maxUseEnabled &&
            lhs.name == rhs.name &&
            lhs.powerFormId == rhs.powerFormId &&
            lhs.powerFormUrl == rhs.powerFormUrl &&
            lhs.recipients == rhs.recipients &&
            lhs.senderName == rhs.senderName &&
            lhs.senderUserId == rhs.senderUserId &&
            lhs.signingMode == rhs.signingMode &&
            lhs.templateId == rhs.templateId &&
            lhs.templateName == rhs.templateName &&
            lhs.timesUsed == rhs.timesUsed &&
            lhs.uri == rhs.uri &&
            lhs.usesRemaining == rhs.usesRemaining
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(createdBy?.hashValue)
        hasher.combine(createdDateTime?.hashValue)
        hasher.combine(emailBody?.hashValue)
        hasher.combine(emailSubject?.hashValue)
        hasher.combine(envelopes?.hashValue)
        hasher.combine(errorDetails?.hashValue)
        hasher.combine(instructions?.hashValue)
        hasher.combine(isActive?.hashValue)
        hasher.combine(lastUsed?.hashValue)
        hasher.combine(limitUseInterval?.hashValue)
        hasher.combine(limitUseIntervalEnabled?.hashValue)
        hasher.combine(limitUseIntervalUnits?.hashValue)
        hasher.combine(maxUseEnabled?.hashValue)
        hasher.combine(name?.hashValue)
        hasher.combine(powerFormId?.hashValue)
        hasher.combine(powerFormUrl?.hashValue)
        hasher.combine(recipients?.hashValue)
        hasher.combine(senderName?.hashValue)
        hasher.combine(senderUserId?.hashValue)
        hasher.combine(signingMode?.hashValue)
        hasher.combine(templateId?.hashValue)
        hasher.combine(templateName?.hashValue)
        hasher.combine(timesUsed?.hashValue)
        hasher.combine(uri?.hashValue)
        hasher.combine(usesRemaining?.hashValue)
    }
}
