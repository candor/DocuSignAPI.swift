//
// TemplateSharedItem.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/** Information about shared templates. */
public final class TemplateSharedItem: Content {
    public var errorDetails: ErrorDetails?
    public var owner: UserInfo?
    /** The user's encrypted password hash. */
    public var password: String?
    /** How the template is shared. One of:  - `not_shared` - `shared_to`  */
    public var shared: String?
    /** List of groups that share the template. */
    public var sharedGroups: [MemberGroupSharedItem]?
    /** List of users that share the template. */
    public var sharedUsers: [UserSharedItem]?
    /** The unique identifier of the template. If this is not provided, DocuSign will generate a value.  */
    public var templateId: String?
    /** The name of the shared template. */
    public var templateName: String?

    public init(errorDetails: ErrorDetails? = nil, owner: UserInfo? = nil, password: String? = nil, shared: String? = nil, sharedGroups: [MemberGroupSharedItem]? = nil, sharedUsers: [UserSharedItem]? = nil, templateId: String? = nil, templateName: String? = nil) {
        self.errorDetails = errorDetails
        self.owner = owner
        self.password = password
        self.shared = shared
        self.sharedGroups = sharedGroups
        self.sharedUsers = sharedUsers
        self.templateId = templateId
        self.templateName = templateName
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case errorDetails
        case owner
        case password
        case shared
        case sharedGroups
        case sharedUsers
        case templateId
        case templateName
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(errorDetails, forKey: .errorDetails)
        try container.encodeIfPresent(owner, forKey: .owner)
        try container.encodeIfPresent(password, forKey: .password)
        try container.encodeIfPresent(shared, forKey: .shared)
        try container.encodeIfPresent(sharedGroups, forKey: .sharedGroups)
        try container.encodeIfPresent(sharedUsers, forKey: .sharedUsers)
        try container.encodeIfPresent(templateId, forKey: .templateId)
        try container.encodeIfPresent(templateName, forKey: .templateName)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        errorDetails = try container.decodeIfPresent(ErrorDetails.self, forKey: .errorDetails)
        owner = try container.decodeIfPresent(UserInfo.self, forKey: .owner)
        password = try container.decodeIfPresent(String.self, forKey: .password)
        shared = try container.decodeIfPresent(String.self, forKey: .shared)
        sharedGroups = try container.decodeIfPresent([MemberGroupSharedItem].self, forKey: .sharedGroups)
        sharedUsers = try container.decodeIfPresent([UserSharedItem].self, forKey: .sharedUsers)
        templateId = try container.decodeIfPresent(String.self, forKey: .templateId)
        templateName = try container.decodeIfPresent(String.self, forKey: .templateName)
    }
}

extension TemplateSharedItem: Hashable {
    public static func == (lhs: TemplateSharedItem, rhs: TemplateSharedItem) -> Bool {
        lhs.errorDetails == rhs.errorDetails &&
            lhs.owner == rhs.owner &&
            lhs.password == rhs.password &&
            lhs.shared == rhs.shared &&
            lhs.sharedGroups == rhs.sharedGroups &&
            lhs.sharedUsers == rhs.sharedUsers &&
            lhs.templateId == rhs.templateId &&
            lhs.templateName == rhs.templateName
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(errorDetails?.hashValue)
        hasher.combine(owner?.hashValue)
        hasher.combine(password?.hashValue)
        hasher.combine(shared?.hashValue)
        hasher.combine(sharedGroups?.hashValue)
        hasher.combine(sharedUsers?.hashValue)
        hasher.combine(templateId?.hashValue)
        hasher.combine(templateName?.hashValue)
    }
}
