//
// PolyLine.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/**  */
public final class PolyLine: Content {
    /**  */
    public var x1: String?
    /**  */
    public var x2: String?
    /**  */
    public var y1: String?
    /**  */
    public var y2: String?

    public init(x1: String? = nil, x2: String? = nil, y1: String? = nil, y2: String? = nil) {
        self.x1 = x1
        self.x2 = x2
        self.y1 = y1
        self.y2 = y2
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case x1
        case x2
        case y1
        case y2
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(x1, forKey: .x1)
        try container.encodeIfPresent(x2, forKey: .x2)
        try container.encodeIfPresent(y1, forKey: .y1)
        try container.encodeIfPresent(y2, forKey: .y2)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        x1 = try container.decodeIfPresent(String.self, forKey: .x1)
        x2 = try container.decodeIfPresent(String.self, forKey: .x2)
        y1 = try container.decodeIfPresent(String.self, forKey: .y1)
        y2 = try container.decodeIfPresent(String.self, forKey: .y2)
    }
}

extension PolyLine: Hashable {
    public static func == (lhs: PolyLine, rhs: PolyLine) -> Bool {
        lhs.x1 == rhs.x1 &&
            lhs.x2 == rhs.x2 &&
            lhs.y1 == rhs.y1 &&
            lhs.y2 == rhs.y2
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(x1?.hashValue)
        hasher.combine(x2?.hashValue)
        hasher.combine(y1?.hashValue)
        hasher.combine(y2?.hashValue)
    }
}
