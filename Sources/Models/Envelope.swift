//
// Envelope.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/**  */
public final class Envelope: Content {
    /** Reserved for DocuSign. */
    public var accessControlListBase64: String?
    /** When set to **true**, users can add comments to the documents in the envelope. For example, if a signer has a question about the text in the document, they can add a comment to the document. */
    public var allowComments: String?
    /** When set to **true**, the Document Markup feature is enabled.  **Note**:  To use this feature, Document Markup must be enabled at both the account and envelope levels. Only Admin users can change this setting for at the account level. */
    public var allowMarkup: String?
    /** When **true**, the recipient can redirect an envelope to a more appropriate recipient. */
    public var allowReassign: String?
    /** When set to **true**, recipients can view the history of the envelope. */
    public var allowViewHistory: String?
    /** Deprecated. This feature has been replaced by signing groups. */
    public var anySigner: String?
    /** When **true**, the envelope is queued for processing and the value of the `status` property is set to `Processing`. Additionally, GET status calls return `Processing` until completed.    **Note**: A `transactionId` is required for this call to work correctly. When the envelope is created, the status is `Processing` and an `envelopeId` is not returned in the response. To get the `envelopeId`, use a GET envelope query by using the [transactionId](https://developers.docusign.com/esign-rest-api/reference/Envelopes/Envelopes/create/#envelopeDefinition) or by checking the Connect notification. */
    public var asynchronous: String?
    /** Contains a URL for retrieving the attachments that are associated with the envelope. */
    public var attachmentsUri: String?
    /** When **true**, marks all of the documents in the envelope as authoritative copies.  **Note**: You can override this value for a specific document. For example, you can set the `authoritativeCopy` property to **true** at the envelope level, but turn it off for a single document by setting the `authoritativeCopy` property for the document to **false**. */
    public var authoritativeCopy: String?
    /** The default `authoritativeCopy` setting for documents in this envelope that do not have `authoritativeCopy` set. If this property is not set, each document defaults to the envelope's `authoritativeCopy`. */
    public var authoritativeCopyDefault: String?
    /** When set to **true**, autonavigation is set for the recipient.  */
    public var autoNavigation: String?
    /** The id of the brand. */
    public var brandId: String?
    /** When **true**, the `brandId` for the envelope is locked and senders cannot change the brand used for the envelope. */
    public var brandLock: String?
    /** The URI for retrieving certificate information. */
    public var certificateUri: String?
    /** Specifies the date and time this item was completed. */
    public var completedDateTime: String?
    /**  */
    public var copyRecipientData: String?
    /** The UTC DateTime when the item was created. */
    public var createdDateTime: String?
    public var customFields: AccountCustomFields?
    /** The URI for retrieving custom fields. */
    public var customFieldsUri: String?
    /** The date and time the recipient declined the document. Read only. */
    public var declinedDateTime: String?
    /** Reserved for DocuSign. */
    public var deletedDateTime: String?
    /** The date and time that the envelope was delivered to the recipient. Read only. */
    public var deliveredDateTime: String?
    /** When set to **true**, responsive documents are disabled for the envelope. */
    public var disableResponsiveDocument: String?
    /** The URI for retrieving all of the documents associated with the envelope as a single PDF file. */
    public var documentsCombinedUri: String?
    /** The URI for retrieving all of the documents associated with the envelope as separate files. */
    public var documentsUri: String?
    /** This is the same as the email body. If the sender enters an email blurb, it is included in the email body for all envelope recipients. */
    public var emailBlurb: String?
    public var emailSettings: EmailSettings?
    /** The subject line of the email message that is sent to all recipients.  For information about adding merge field information to the email subject, see [Template Email Subject Merge Fields](https://developers.docusign.com/esign-rest-api/reference/Templates/Templates/create#template-email-subject-merge-fields).  */
    public var emailSubject: String?
    /** When set to **true**, the signer is allowed to print the document and sign it on paper. */
    public var enableWetSign: String?
    /** When set to **true**, signers can only view the documents on which they have tabs. Recipients that have an administrative role (Agent, Editor, or Intermediaries) or informational role (Certified Deliveries or Carbon Copies) can always see all of the documents in an envelope, unless they are specifically excluded by using this setting when an envelope is sent. Documents that do not have tabs are always visible to all recipients, unless they are specifically excluded by using this setting when an envelope is sent.  **Note**: To use this functionality, [Document Visibility][docviz] must be enabled for the account by making the account setting `allowDocumentVisibility` **true**.  [docviz]: /esign/restapi/Envelopes/EnvelopeDocumentVisibility */
    public var enforceSignerVisibility: String?
    /** An array of attachment objects that provide information about the attachments that are associated with the envelope. */
    public var envelopeAttachments: [Attachment]?
    /** An array containing information about the documents that are included in the envelope. */
    public var envelopeDocuments: [EnvelopeDocument]?
    /** The envelope's GUID.   Example: `93be49ab-xxxx-xxxx-xxxx-f752070d71ec`  */
    public var envelopeId: String?
    /** When set to **true**, [Envelope ID Stamping](https://support.docusign.com/en/guides/ndse-user-guide-set-advanced-document-options) is enabled. After a document or attachment is stamped with an Envelope ID, the ID is seen by all recipients and becomes a permanent part of the document and cannot be removed. */
    public var envelopeIdStamping: String?
    /** Reserved for DocuSign. */
    public var envelopeLocation: String?
    public var envelopeMetadata: EnvelopeMetadata?
    /** The URI for retrieving the envelope or envelopes. */
    public var envelopeUri: String?
    /** An integer specifying the number of days that a sent envelope remains active before it expires. A negative number in a response indicates that the envelope has already expired. */
    public var expireAfter: String?
    /** The date and time the envelope is set to expire. */
    public var expireDateTime: String?
    /** When set to **true**, the envelope expires (is no longer available for signing) after the specified number of days after it is sent (`sentDateTime`). Set  `expireAfter` to set the number of days until an envelope expires. When **false**, the account default setting is used. If the account does not have an expiration setting, the DocuSign default value of 120 days is used. */
    public var expireEnabled: String?
    /** May contain an external identifier for the envelope. */
    public var externalEnvelopeId: String?
    /** A list of folder objects. */
    public var folders: [Folder]?
    /** When set to **true**, indicates that users have added comments to the envelope. */
    public var hasComments: String?
    /** When set to **true**, indicates that the data collected through form fields on a document has changed. */
    public var hasFormDataChanged: String?
    /** When set to **true**, indicates that a .wav file used for voice authentication is included in the envelope.  */
    public var hasWavFile: String?
    /** Reserved for DocuSign. */
    public var holder: String?
    /** The date and time the envelope was initially sent. */
    public var initialSentDateTime: String?
    /** When **true**, indicates compliance with United States Food and Drug Administration (FDA) regulations on electronic records and electronic signatures (ERES). */
    public var is21CFRPart11: String?
    /** When set to **true**, indicates that the envelope is a dynamic envelope. */
    public var isDynamicEnvelope: String?
    /** When set to **true**, indicates that the envelope is a signature-provided envelope. */
    public var isSignatureProviderEnvelope: String?
    /** The date and time that the item was last modified. */
    public var lastModifiedDateTime: String?
    /** Reserved for DocuSign. */
    public var location: String?
    public var lockInformation: EnvelopeLocks?
    /** When set to **true**, prevents senders from changing the contents of `emailBlurb` and `emailSubject` properties for the envelope.   Additionally, this prevents users from making changes to the contents of `emailBlurb` and `emailSubject` properties when correcting envelopes.   However, if the `messageLock` node is set to **true** and the `emailSubject` property is empty, senders and correctors are able to add a subject to the envelope. */
    public var messageLock: String?
    public var notification: Notification?
    /** The URI for retrieving notifications. */
    public var notificationUri: String?
    public var powerForm: PowerForm?
    /** The date that a purge was completed. */
    public var purgeCompletedDate: String?
    /** The date that a purge was requested. */
    public var purgeRequestDate: String?
    /** Shows the current purge state for the envelope. The possible values are:  * `unpurged`: There has been no successful request to purge documents. * `documents_queued`: The envelope documents have been added to the purge queue, but have not been purged. * `documents_dequeued`: The envelope documents have been taken out of the purge queue. * `documents_and_metadata_queued`: The envelope documents and metadata have been added to the purge queue, but have not yet been purged. * `documents_purged`: The envelope documents have been successfully purged. * `documents_and_metadata_purged`: The envelope documents and metadata have been successfully purged.   */
    public var purgeState: String?
    public var recipients: EnvelopeRecipients?
    /** When set to **true**, prevents senders from changing, correcting, or deleting the recipient information for the envelope. */
    public var recipientsLock: String?
    /** Contains a URI for an endpoint that you can use to retrieve the recipients. */
    public var recipientsUri: String?
    public var sender: UserInfo?
    /** The UTC DateTime when the envelope was sent. Read only. */
    public var sentDateTime: String?
    /** When set to **true**, recipients can sign on a mobile device.  **Note**: Only Admin users can change this setting.  */
    public var signerCanSignOnMobile: String?
    /** Specifies the physical location where the signing takes place. It can have two enumeration values; `inPerson` and `online`. The default value is `online`. */
    public var signingLocation: String?
    /** Indicates the envelope status. Valid values are:  * `completed`: The recipients have finished working with the envelope: the documents are signed and all required tabs are filled in. * `created`: The envelope is created as a draft. It can be modified and sent later. * `declined`: The envelope has been declined by the recipients. * `delivered`: The envelope has been delivered to the recipients. * `sent`: The envelope will be sent to the recipients after the envelope is created. * `signed`: The envelope has been signed by the recipients. * `voided`: The envelope is no longer valid and recipients cannot access or sign the envelope.  */
    public var status: String?
    /** The data and time that the status changed. */
    public var statusChangedDateTime: String?
    /** The DateTime that the envelope changed status (i.e. was created or sent.) */
    public var statusDateTime: String?
    /** The URI for retrieving the templates. */
    public var templatesUri: String?
    /** Specifies the Transaction ID from the AppStore. */
    public var transactionId: String?
    /** When set to **true**, the disclosure is shown to recipients in accordance with the account's Electronic Record and Signature Disclosure frequency setting. When set to **false**, the Electronic Record and Signature Disclosure is not shown to any envelope recipients.   If the `useDisclosure` property is not set, then the account's normal disclosure setting is used and the value of the `useDisclosure` property is not returned in responses when getting envelope information. */
    public var useDisclosure: String?
    /** The date and time the envelope or template was voided. */
    public var voidedDateTime: String?
    /** The reason the envelope or template was voided. */
    public var voidedReason: String?
    public var workflow: Workflow?

    public init(accessControlListBase64: String? = nil, allowComments: String? = nil, allowMarkup: String? = nil, allowReassign: String? = nil, allowViewHistory: String? = nil, anySigner: String? = nil, asynchronous: String? = nil, attachmentsUri: String? = nil, authoritativeCopy: String? = nil, authoritativeCopyDefault: String? = nil, autoNavigation: String? = nil, brandId: String? = nil, brandLock: String? = nil, certificateUri: String? = nil, completedDateTime: String? = nil, copyRecipientData: String? = nil, createdDateTime: String? = nil, customFields: AccountCustomFields? = nil, customFieldsUri: String? = nil, declinedDateTime: String? = nil, deletedDateTime: String? = nil, deliveredDateTime: String? = nil, disableResponsiveDocument: String? = nil, documentsCombinedUri: String? = nil, documentsUri: String? = nil, emailBlurb: String? = nil, emailSettings: EmailSettings? = nil, emailSubject: String? = nil, enableWetSign: String? = nil, enforceSignerVisibility: String? = nil, envelopeAttachments: [Attachment]? = nil, envelopeDocuments: [EnvelopeDocument]? = nil, envelopeId: String? = nil, envelopeIdStamping: String? = nil, envelopeLocation: String? = nil, envelopeMetadata: EnvelopeMetadata? = nil, envelopeUri: String? = nil, expireAfter: String? = nil, expireDateTime: String? = nil, expireEnabled: String? = nil, externalEnvelopeId: String? = nil, folders: [Folder]? = nil, hasComments: String? = nil, hasFormDataChanged: String? = nil, hasWavFile: String? = nil, holder: String? = nil, initialSentDateTime: String? = nil, is21CFRPart11: String? = nil, isDynamicEnvelope: String? = nil, isSignatureProviderEnvelope: String? = nil, lastModifiedDateTime: String? = nil, location: String? = nil, lockInformation: EnvelopeLocks? = nil, messageLock: String? = nil, notification: Notification? = nil, notificationUri: String? = nil, powerForm: PowerForm? = nil, purgeCompletedDate: String? = nil, purgeRequestDate: String? = nil, purgeState: String? = nil, recipients: EnvelopeRecipients? = nil, recipientsLock: String? = nil, recipientsUri: String? = nil, sender: UserInfo? = nil, sentDateTime: String? = nil, signerCanSignOnMobile: String? = nil, signingLocation: String? = nil, status: String? = nil, statusChangedDateTime: String? = nil, statusDateTime: String? = nil, templatesUri: String? = nil, transactionId: String? = nil, useDisclosure: String? = nil, voidedDateTime: String? = nil, voidedReason: String? = nil, workflow: Workflow? = nil) {
        self.accessControlListBase64 = accessControlListBase64
        self.allowComments = allowComments
        self.allowMarkup = allowMarkup
        self.allowReassign = allowReassign
        self.allowViewHistory = allowViewHistory
        self.anySigner = anySigner
        self.asynchronous = asynchronous
        self.attachmentsUri = attachmentsUri
        self.authoritativeCopy = authoritativeCopy
        self.authoritativeCopyDefault = authoritativeCopyDefault
        self.autoNavigation = autoNavigation
        self.brandId = brandId
        self.brandLock = brandLock
        self.certificateUri = certificateUri
        self.completedDateTime = completedDateTime
        self.copyRecipientData = copyRecipientData
        self.createdDateTime = createdDateTime
        self.customFields = customFields
        self.customFieldsUri = customFieldsUri
        self.declinedDateTime = declinedDateTime
        self.deletedDateTime = deletedDateTime
        self.deliveredDateTime = deliveredDateTime
        self.disableResponsiveDocument = disableResponsiveDocument
        self.documentsCombinedUri = documentsCombinedUri
        self.documentsUri = documentsUri
        self.emailBlurb = emailBlurb
        self.emailSettings = emailSettings
        self.emailSubject = emailSubject
        self.enableWetSign = enableWetSign
        self.enforceSignerVisibility = enforceSignerVisibility
        self.envelopeAttachments = envelopeAttachments
        self.envelopeDocuments = envelopeDocuments
        self.envelopeId = envelopeId
        self.envelopeIdStamping = envelopeIdStamping
        self.envelopeLocation = envelopeLocation
        self.envelopeMetadata = envelopeMetadata
        self.envelopeUri = envelopeUri
        self.expireAfter = expireAfter
        self.expireDateTime = expireDateTime
        self.expireEnabled = expireEnabled
        self.externalEnvelopeId = externalEnvelopeId
        self.folders = folders
        self.hasComments = hasComments
        self.hasFormDataChanged = hasFormDataChanged
        self.hasWavFile = hasWavFile
        self.holder = holder
        self.initialSentDateTime = initialSentDateTime
        self.is21CFRPart11 = is21CFRPart11
        self.isDynamicEnvelope = isDynamicEnvelope
        self.isSignatureProviderEnvelope = isSignatureProviderEnvelope
        self.lastModifiedDateTime = lastModifiedDateTime
        self.location = location
        self.lockInformation = lockInformation
        self.messageLock = messageLock
        self.notification = notification
        self.notificationUri = notificationUri
        self.powerForm = powerForm
        self.purgeCompletedDate = purgeCompletedDate
        self.purgeRequestDate = purgeRequestDate
        self.purgeState = purgeState
        self.recipients = recipients
        self.recipientsLock = recipientsLock
        self.recipientsUri = recipientsUri
        self.sender = sender
        self.sentDateTime = sentDateTime
        self.signerCanSignOnMobile = signerCanSignOnMobile
        self.signingLocation = signingLocation
        self.status = status
        self.statusChangedDateTime = statusChangedDateTime
        self.statusDateTime = statusDateTime
        self.templatesUri = templatesUri
        self.transactionId = transactionId
        self.useDisclosure = useDisclosure
        self.voidedDateTime = voidedDateTime
        self.voidedReason = voidedReason
        self.workflow = workflow
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case accessControlListBase64
        case allowComments
        case allowMarkup
        case allowReassign
        case allowViewHistory
        case anySigner
        case asynchronous
        case attachmentsUri
        case authoritativeCopy
        case authoritativeCopyDefault
        case autoNavigation
        case brandId
        case brandLock
        case certificateUri
        case completedDateTime
        case copyRecipientData
        case createdDateTime
        case customFields
        case customFieldsUri
        case declinedDateTime
        case deletedDateTime
        case deliveredDateTime
        case disableResponsiveDocument
        case documentsCombinedUri
        case documentsUri
        case emailBlurb
        case emailSettings
        case emailSubject
        case enableWetSign
        case enforceSignerVisibility
        case envelopeAttachments
        case envelopeDocuments
        case envelopeId
        case envelopeIdStamping
        case envelopeLocation
        case envelopeMetadata
        case envelopeUri
        case expireAfter
        case expireDateTime
        case expireEnabled
        case externalEnvelopeId
        case folders
        case hasComments
        case hasFormDataChanged
        case hasWavFile
        case holder
        case initialSentDateTime
        case is21CFRPart11
        case isDynamicEnvelope
        case isSignatureProviderEnvelope
        case lastModifiedDateTime
        case location
        case lockInformation
        case messageLock
        case notification
        case notificationUri
        case powerForm
        case purgeCompletedDate
        case purgeRequestDate
        case purgeState
        case recipients
        case recipientsLock
        case recipientsUri
        case sender
        case sentDateTime
        case signerCanSignOnMobile
        case signingLocation
        case status
        case statusChangedDateTime
        case statusDateTime
        case templatesUri
        case transactionId
        case useDisclosure
        case voidedDateTime
        case voidedReason
        case workflow
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(accessControlListBase64, forKey: .accessControlListBase64)
        try container.encodeIfPresent(allowComments, forKey: .allowComments)
        try container.encodeIfPresent(allowMarkup, forKey: .allowMarkup)
        try container.encodeIfPresent(allowReassign, forKey: .allowReassign)
        try container.encodeIfPresent(allowViewHistory, forKey: .allowViewHistory)
        try container.encodeIfPresent(anySigner, forKey: .anySigner)
        try container.encodeIfPresent(asynchronous, forKey: .asynchronous)
        try container.encodeIfPresent(attachmentsUri, forKey: .attachmentsUri)
        try container.encodeIfPresent(authoritativeCopy, forKey: .authoritativeCopy)
        try container.encodeIfPresent(authoritativeCopyDefault, forKey: .authoritativeCopyDefault)
        try container.encodeIfPresent(autoNavigation, forKey: .autoNavigation)
        try container.encodeIfPresent(brandId, forKey: .brandId)
        try container.encodeIfPresent(brandLock, forKey: .brandLock)
        try container.encodeIfPresent(certificateUri, forKey: .certificateUri)
        try container.encodeIfPresent(completedDateTime, forKey: .completedDateTime)
        try container.encodeIfPresent(copyRecipientData, forKey: .copyRecipientData)
        try container.encodeIfPresent(createdDateTime, forKey: .createdDateTime)
        try container.encodeIfPresent(customFields, forKey: .customFields)
        try container.encodeIfPresent(customFieldsUri, forKey: .customFieldsUri)
        try container.encodeIfPresent(declinedDateTime, forKey: .declinedDateTime)
        try container.encodeIfPresent(deletedDateTime, forKey: .deletedDateTime)
        try container.encodeIfPresent(deliveredDateTime, forKey: .deliveredDateTime)
        try container.encodeIfPresent(disableResponsiveDocument, forKey: .disableResponsiveDocument)
        try container.encodeIfPresent(documentsCombinedUri, forKey: .documentsCombinedUri)
        try container.encodeIfPresent(documentsUri, forKey: .documentsUri)
        try container.encodeIfPresent(emailBlurb, forKey: .emailBlurb)
        try container.encodeIfPresent(emailSettings, forKey: .emailSettings)
        try container.encodeIfPresent(emailSubject, forKey: .emailSubject)
        try container.encodeIfPresent(enableWetSign, forKey: .enableWetSign)
        try container.encodeIfPresent(enforceSignerVisibility, forKey: .enforceSignerVisibility)
        try container.encodeIfPresent(envelopeAttachments, forKey: .envelopeAttachments)
        try container.encodeIfPresent(envelopeDocuments, forKey: .envelopeDocuments)
        try container.encodeIfPresent(envelopeId, forKey: .envelopeId)
        try container.encodeIfPresent(envelopeIdStamping, forKey: .envelopeIdStamping)
        try container.encodeIfPresent(envelopeLocation, forKey: .envelopeLocation)
        try container.encodeIfPresent(envelopeMetadata, forKey: .envelopeMetadata)
        try container.encodeIfPresent(envelopeUri, forKey: .envelopeUri)
        try container.encodeIfPresent(expireAfter, forKey: .expireAfter)
        try container.encodeIfPresent(expireDateTime, forKey: .expireDateTime)
        try container.encodeIfPresent(expireEnabled, forKey: .expireEnabled)
        try container.encodeIfPresent(externalEnvelopeId, forKey: .externalEnvelopeId)
        try container.encodeIfPresent(folders, forKey: .folders)
        try container.encodeIfPresent(hasComments, forKey: .hasComments)
        try container.encodeIfPresent(hasFormDataChanged, forKey: .hasFormDataChanged)
        try container.encodeIfPresent(hasWavFile, forKey: .hasWavFile)
        try container.encodeIfPresent(holder, forKey: .holder)
        try container.encodeIfPresent(initialSentDateTime, forKey: .initialSentDateTime)
        try container.encodeIfPresent(is21CFRPart11, forKey: .is21CFRPart11)
        try container.encodeIfPresent(isDynamicEnvelope, forKey: .isDynamicEnvelope)
        try container.encodeIfPresent(isSignatureProviderEnvelope, forKey: .isSignatureProviderEnvelope)
        try container.encodeIfPresent(lastModifiedDateTime, forKey: .lastModifiedDateTime)
        try container.encodeIfPresent(location, forKey: .location)
        try container.encodeIfPresent(lockInformation, forKey: .lockInformation)
        try container.encodeIfPresent(messageLock, forKey: .messageLock)
        try container.encodeIfPresent(notification, forKey: .notification)
        try container.encodeIfPresent(notificationUri, forKey: .notificationUri)
        try container.encodeIfPresent(powerForm, forKey: .powerForm)
        try container.encodeIfPresent(purgeCompletedDate, forKey: .purgeCompletedDate)
        try container.encodeIfPresent(purgeRequestDate, forKey: .purgeRequestDate)
        try container.encodeIfPresent(purgeState, forKey: .purgeState)
        try container.encodeIfPresent(recipients, forKey: .recipients)
        try container.encodeIfPresent(recipientsLock, forKey: .recipientsLock)
        try container.encodeIfPresent(recipientsUri, forKey: .recipientsUri)
        try container.encodeIfPresent(sender, forKey: .sender)
        try container.encodeIfPresent(sentDateTime, forKey: .sentDateTime)
        try container.encodeIfPresent(signerCanSignOnMobile, forKey: .signerCanSignOnMobile)
        try container.encodeIfPresent(signingLocation, forKey: .signingLocation)
        try container.encodeIfPresent(status, forKey: .status)
        try container.encodeIfPresent(statusChangedDateTime, forKey: .statusChangedDateTime)
        try container.encodeIfPresent(statusDateTime, forKey: .statusDateTime)
        try container.encodeIfPresent(templatesUri, forKey: .templatesUri)
        try container.encodeIfPresent(transactionId, forKey: .transactionId)
        try container.encodeIfPresent(useDisclosure, forKey: .useDisclosure)
        try container.encodeIfPresent(voidedDateTime, forKey: .voidedDateTime)
        try container.encodeIfPresent(voidedReason, forKey: .voidedReason)
        try container.encodeIfPresent(workflow, forKey: .workflow)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        accessControlListBase64 = try container.decodeIfPresent(String.self, forKey: .accessControlListBase64)
        allowComments = try container.decodeIfPresent(String.self, forKey: .allowComments)
        allowMarkup = try container.decodeIfPresent(String.self, forKey: .allowMarkup)
        allowReassign = try container.decodeIfPresent(String.self, forKey: .allowReassign)
        allowViewHistory = try container.decodeIfPresent(String.self, forKey: .allowViewHistory)
        anySigner = try container.decodeIfPresent(String.self, forKey: .anySigner)
        asynchronous = try container.decodeIfPresent(String.self, forKey: .asynchronous)
        attachmentsUri = try container.decodeIfPresent(String.self, forKey: .attachmentsUri)
        authoritativeCopy = try container.decodeIfPresent(String.self, forKey: .authoritativeCopy)
        authoritativeCopyDefault = try container.decodeIfPresent(String.self, forKey: .authoritativeCopyDefault)
        autoNavigation = try container.decodeIfPresent(String.self, forKey: .autoNavigation)
        brandId = try container.decodeIfPresent(String.self, forKey: .brandId)
        brandLock = try container.decodeIfPresent(String.self, forKey: .brandLock)
        certificateUri = try container.decodeIfPresent(String.self, forKey: .certificateUri)
        completedDateTime = try container.decodeIfPresent(String.self, forKey: .completedDateTime)
        copyRecipientData = try container.decodeIfPresent(String.self, forKey: .copyRecipientData)
        createdDateTime = try container.decodeIfPresent(String.self, forKey: .createdDateTime)
        customFields = try container.decodeIfPresent(AccountCustomFields.self, forKey: .customFields)
        customFieldsUri = try container.decodeIfPresent(String.self, forKey: .customFieldsUri)
        declinedDateTime = try container.decodeIfPresent(String.self, forKey: .declinedDateTime)
        deletedDateTime = try container.decodeIfPresent(String.self, forKey: .deletedDateTime)
        deliveredDateTime = try container.decodeIfPresent(String.self, forKey: .deliveredDateTime)
        disableResponsiveDocument = try container.decodeIfPresent(String.self, forKey: .disableResponsiveDocument)
        documentsCombinedUri = try container.decodeIfPresent(String.self, forKey: .documentsCombinedUri)
        documentsUri = try container.decodeIfPresent(String.self, forKey: .documentsUri)
        emailBlurb = try container.decodeIfPresent(String.self, forKey: .emailBlurb)
        emailSettings = try container.decodeIfPresent(EmailSettings.self, forKey: .emailSettings)
        emailSubject = try container.decodeIfPresent(String.self, forKey: .emailSubject)
        enableWetSign = try container.decodeIfPresent(String.self, forKey: .enableWetSign)
        enforceSignerVisibility = try container.decodeIfPresent(String.self, forKey: .enforceSignerVisibility)
        envelopeAttachments = try container.decodeIfPresent([Attachment].self, forKey: .envelopeAttachments)
        envelopeDocuments = try container.decodeIfPresent([EnvelopeDocument].self, forKey: .envelopeDocuments)
        envelopeId = try container.decodeIfPresent(String.self, forKey: .envelopeId)
        envelopeIdStamping = try container.decodeIfPresent(String.self, forKey: .envelopeIdStamping)
        envelopeLocation = try container.decodeIfPresent(String.self, forKey: .envelopeLocation)
        envelopeMetadata = try container.decodeIfPresent(EnvelopeMetadata.self, forKey: .envelopeMetadata)
        envelopeUri = try container.decodeIfPresent(String.self, forKey: .envelopeUri)
        expireAfter = try container.decodeIfPresent(String.self, forKey: .expireAfter)
        expireDateTime = try container.decodeIfPresent(String.self, forKey: .expireDateTime)
        expireEnabled = try container.decodeIfPresent(String.self, forKey: .expireEnabled)
        externalEnvelopeId = try container.decodeIfPresent(String.self, forKey: .externalEnvelopeId)
        folders = try container.decodeIfPresent([Folder].self, forKey: .folders)
        hasComments = try container.decodeIfPresent(String.self, forKey: .hasComments)
        hasFormDataChanged = try container.decodeIfPresent(String.self, forKey: .hasFormDataChanged)
        hasWavFile = try container.decodeIfPresent(String.self, forKey: .hasWavFile)
        holder = try container.decodeIfPresent(String.self, forKey: .holder)
        initialSentDateTime = try container.decodeIfPresent(String.self, forKey: .initialSentDateTime)
        is21CFRPart11 = try container.decodeIfPresent(String.self, forKey: .is21CFRPart11)
        isDynamicEnvelope = try container.decodeIfPresent(String.self, forKey: .isDynamicEnvelope)
        isSignatureProviderEnvelope = try container.decodeIfPresent(String.self, forKey: .isSignatureProviderEnvelope)
        lastModifiedDateTime = try container.decodeIfPresent(String.self, forKey: .lastModifiedDateTime)
        location = try container.decodeIfPresent(String.self, forKey: .location)
        lockInformation = try container.decodeIfPresent(EnvelopeLocks.self, forKey: .lockInformation)
        messageLock = try container.decodeIfPresent(String.self, forKey: .messageLock)
        notification = try container.decodeIfPresent(Notification.self, forKey: .notification)
        notificationUri = try container.decodeIfPresent(String.self, forKey: .notificationUri)
        powerForm = try container.decodeIfPresent(PowerForm.self, forKey: .powerForm)
        purgeCompletedDate = try container.decodeIfPresent(String.self, forKey: .purgeCompletedDate)
        purgeRequestDate = try container.decodeIfPresent(String.self, forKey: .purgeRequestDate)
        purgeState = try container.decodeIfPresent(String.self, forKey: .purgeState)
        recipients = try container.decodeIfPresent(EnvelopeRecipients.self, forKey: .recipients)
        recipientsLock = try container.decodeIfPresent(String.self, forKey: .recipientsLock)
        recipientsUri = try container.decodeIfPresent(String.self, forKey: .recipientsUri)
        sender = try container.decodeIfPresent(UserInfo.self, forKey: .sender)
        sentDateTime = try container.decodeIfPresent(String.self, forKey: .sentDateTime)
        signerCanSignOnMobile = try container.decodeIfPresent(String.self, forKey: .signerCanSignOnMobile)
        signingLocation = try container.decodeIfPresent(String.self, forKey: .signingLocation)
        status = try container.decodeIfPresent(String.self, forKey: .status)
        statusChangedDateTime = try container.decodeIfPresent(String.self, forKey: .statusChangedDateTime)
        statusDateTime = try container.decodeIfPresent(String.self, forKey: .statusDateTime)
        templatesUri = try container.decodeIfPresent(String.self, forKey: .templatesUri)
        transactionId = try container.decodeIfPresent(String.self, forKey: .transactionId)
        useDisclosure = try container.decodeIfPresent(String.self, forKey: .useDisclosure)
        voidedDateTime = try container.decodeIfPresent(String.self, forKey: .voidedDateTime)
        voidedReason = try container.decodeIfPresent(String.self, forKey: .voidedReason)
        workflow = try container.decodeIfPresent(Workflow.self, forKey: .workflow)
    }
}

extension Envelope: Hashable {
    public static func == (lhs: Envelope, rhs: Envelope) -> Bool {
        lhs.accessControlListBase64 == rhs.accessControlListBase64 &&
            lhs.allowComments == rhs.allowComments &&
            lhs.allowMarkup == rhs.allowMarkup &&
            lhs.allowReassign == rhs.allowReassign &&
            lhs.allowViewHistory == rhs.allowViewHistory &&
            lhs.anySigner == rhs.anySigner &&
            lhs.asynchronous == rhs.asynchronous &&
            lhs.attachmentsUri == rhs.attachmentsUri &&
            lhs.authoritativeCopy == rhs.authoritativeCopy &&
            lhs.authoritativeCopyDefault == rhs.authoritativeCopyDefault &&
            lhs.autoNavigation == rhs.autoNavigation &&
            lhs.brandId == rhs.brandId &&
            lhs.brandLock == rhs.brandLock &&
            lhs.certificateUri == rhs.certificateUri &&
            lhs.completedDateTime == rhs.completedDateTime &&
            lhs.copyRecipientData == rhs.copyRecipientData &&
            lhs.createdDateTime == rhs.createdDateTime &&
            lhs.customFields == rhs.customFields &&
            lhs.customFieldsUri == rhs.customFieldsUri &&
            lhs.declinedDateTime == rhs.declinedDateTime &&
            lhs.deletedDateTime == rhs.deletedDateTime &&
            lhs.deliveredDateTime == rhs.deliveredDateTime &&
            lhs.disableResponsiveDocument == rhs.disableResponsiveDocument &&
            lhs.documentsCombinedUri == rhs.documentsCombinedUri &&
            lhs.documentsUri == rhs.documentsUri &&
            lhs.emailBlurb == rhs.emailBlurb &&
            lhs.emailSettings == rhs.emailSettings &&
            lhs.emailSubject == rhs.emailSubject &&
            lhs.enableWetSign == rhs.enableWetSign &&
            lhs.enforceSignerVisibility == rhs.enforceSignerVisibility &&
            lhs.envelopeAttachments == rhs.envelopeAttachments &&
            lhs.envelopeDocuments == rhs.envelopeDocuments &&
            lhs.envelopeId == rhs.envelopeId &&
            lhs.envelopeIdStamping == rhs.envelopeIdStamping &&
            lhs.envelopeLocation == rhs.envelopeLocation &&
            lhs.envelopeMetadata == rhs.envelopeMetadata &&
            lhs.envelopeUri == rhs.envelopeUri &&
            lhs.expireAfter == rhs.expireAfter &&
            lhs.expireDateTime == rhs.expireDateTime &&
            lhs.expireEnabled == rhs.expireEnabled &&
            lhs.externalEnvelopeId == rhs.externalEnvelopeId &&
            lhs.folders == rhs.folders &&
            lhs.hasComments == rhs.hasComments &&
            lhs.hasFormDataChanged == rhs.hasFormDataChanged &&
            lhs.hasWavFile == rhs.hasWavFile &&
            lhs.holder == rhs.holder &&
            lhs.initialSentDateTime == rhs.initialSentDateTime &&
            lhs.is21CFRPart11 == rhs.is21CFRPart11 &&
            lhs.isDynamicEnvelope == rhs.isDynamicEnvelope &&
            lhs.isSignatureProviderEnvelope == rhs.isSignatureProviderEnvelope &&
            lhs.lastModifiedDateTime == rhs.lastModifiedDateTime &&
            lhs.location == rhs.location &&
            lhs.lockInformation == rhs.lockInformation &&
            lhs.messageLock == rhs.messageLock &&
            lhs.notification == rhs.notification &&
            lhs.notificationUri == rhs.notificationUri &&
            lhs.powerForm == rhs.powerForm &&
            lhs.purgeCompletedDate == rhs.purgeCompletedDate &&
            lhs.purgeRequestDate == rhs.purgeRequestDate &&
            lhs.purgeState == rhs.purgeState &&
            lhs.recipients == rhs.recipients &&
            lhs.recipientsLock == rhs.recipientsLock &&
            lhs.recipientsUri == rhs.recipientsUri &&
            lhs.sender == rhs.sender &&
            lhs.sentDateTime == rhs.sentDateTime &&
            lhs.signerCanSignOnMobile == rhs.signerCanSignOnMobile &&
            lhs.signingLocation == rhs.signingLocation &&
            lhs.status == rhs.status &&
            lhs.statusChangedDateTime == rhs.statusChangedDateTime &&
            lhs.statusDateTime == rhs.statusDateTime &&
            lhs.templatesUri == rhs.templatesUri &&
            lhs.transactionId == rhs.transactionId &&
            lhs.useDisclosure == rhs.useDisclosure &&
            lhs.voidedDateTime == rhs.voidedDateTime &&
            lhs.voidedReason == rhs.voidedReason &&
            lhs.workflow == rhs.workflow
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accessControlListBase64?.hashValue)
        hasher.combine(allowComments?.hashValue)
        hasher.combine(allowMarkup?.hashValue)
        hasher.combine(allowReassign?.hashValue)
        hasher.combine(allowViewHistory?.hashValue)
        hasher.combine(anySigner?.hashValue)
        hasher.combine(asynchronous?.hashValue)
        hasher.combine(attachmentsUri?.hashValue)
        hasher.combine(authoritativeCopy?.hashValue)
        hasher.combine(authoritativeCopyDefault?.hashValue)
        hasher.combine(autoNavigation?.hashValue)
        hasher.combine(brandId?.hashValue)
        hasher.combine(brandLock?.hashValue)
        hasher.combine(certificateUri?.hashValue)
        hasher.combine(completedDateTime?.hashValue)
        hasher.combine(copyRecipientData?.hashValue)
        hasher.combine(createdDateTime?.hashValue)
        hasher.combine(customFields?.hashValue)
        hasher.combine(customFieldsUri?.hashValue)
        hasher.combine(declinedDateTime?.hashValue)
        hasher.combine(deletedDateTime?.hashValue)
        hasher.combine(deliveredDateTime?.hashValue)
        hasher.combine(disableResponsiveDocument?.hashValue)
        hasher.combine(documentsCombinedUri?.hashValue)
        hasher.combine(documentsUri?.hashValue)
        hasher.combine(emailBlurb?.hashValue)
        hasher.combine(emailSettings?.hashValue)
        hasher.combine(emailSubject?.hashValue)
        hasher.combine(enableWetSign?.hashValue)
        hasher.combine(enforceSignerVisibility?.hashValue)
        hasher.combine(envelopeAttachments?.hashValue)
        hasher.combine(envelopeDocuments?.hashValue)
        hasher.combine(envelopeId?.hashValue)
        hasher.combine(envelopeIdStamping?.hashValue)
        hasher.combine(envelopeLocation?.hashValue)
        hasher.combine(envelopeMetadata?.hashValue)
        hasher.combine(envelopeUri?.hashValue)
        hasher.combine(expireAfter?.hashValue)
        hasher.combine(expireDateTime?.hashValue)
        hasher.combine(expireEnabled?.hashValue)
        hasher.combine(externalEnvelopeId?.hashValue)
        hasher.combine(folders?.hashValue)
        hasher.combine(hasComments?.hashValue)
        hasher.combine(hasFormDataChanged?.hashValue)
        hasher.combine(hasWavFile?.hashValue)
        hasher.combine(holder?.hashValue)
        hasher.combine(initialSentDateTime?.hashValue)
        hasher.combine(is21CFRPart11?.hashValue)
        hasher.combine(isDynamicEnvelope?.hashValue)
        hasher.combine(isSignatureProviderEnvelope?.hashValue)
        hasher.combine(lastModifiedDateTime?.hashValue)
        hasher.combine(location?.hashValue)
        hasher.combine(lockInformation?.hashValue)
        hasher.combine(messageLock?.hashValue)
        hasher.combine(notification?.hashValue)
        hasher.combine(notificationUri?.hashValue)
        hasher.combine(powerForm?.hashValue)
        hasher.combine(purgeCompletedDate?.hashValue)
        hasher.combine(purgeRequestDate?.hashValue)
        hasher.combine(purgeState?.hashValue)
        hasher.combine(recipients?.hashValue)
        hasher.combine(recipientsLock?.hashValue)
        hasher.combine(recipientsUri?.hashValue)
        hasher.combine(sender?.hashValue)
        hasher.combine(sentDateTime?.hashValue)
        hasher.combine(signerCanSignOnMobile?.hashValue)
        hasher.combine(signingLocation?.hashValue)
        hasher.combine(status?.hashValue)
        hasher.combine(statusChangedDateTime?.hashValue)
        hasher.combine(statusDateTime?.hashValue)
        hasher.combine(templatesUri?.hashValue)
        hasher.combine(transactionId?.hashValue)
        hasher.combine(useDisclosure?.hashValue)
        hasher.combine(voidedDateTime?.hashValue)
        hasher.combine(voidedReason?.hashValue)
        hasher.combine(workflow?.hashValue)
    }
}
