//
// BrandResourceUrls.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/** Brands use resource files to style the following experiences:   - Email - Sending - Signing - Captive (embedded) signing   You can modify these resource files to customize these experiences. */
public final class BrandResourceUrls: Content {
    /** The URI for the email resource file that the brand uses. */
    public var email: String?
    /** The URI for the sending resource file that the brand uses. */
    public var sending: String?
    /** The URI for the signing resource file that the brand uses. */
    public var signing: String?
    /** The URI for the captive (embedded) signing resource file that the brand uses. */
    public var signingCaptive: String?

    public init(email: String? = nil, sending: String? = nil, signing: String? = nil, signingCaptive: String? = nil) {
        self.email = email
        self.sending = sending
        self.signing = signing
        self.signingCaptive = signingCaptive
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case email
        case sending
        case signing
        case signingCaptive
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(email, forKey: .email)
        try container.encodeIfPresent(sending, forKey: .sending)
        try container.encodeIfPresent(signing, forKey: .signing)
        try container.encodeIfPresent(signingCaptive, forKey: .signingCaptive)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        email = try container.decodeIfPresent(String.self, forKey: .email)
        sending = try container.decodeIfPresent(String.self, forKey: .sending)
        signing = try container.decodeIfPresent(String.self, forKey: .signing)
        signingCaptive = try container.decodeIfPresent(String.self, forKey: .signingCaptive)
    }
}

extension BrandResourceUrls: Hashable {
    public static func == (lhs: BrandResourceUrls, rhs: BrandResourceUrls) -> Bool {
        lhs.email == rhs.email &&
            lhs.sending == rhs.sending &&
            lhs.signing == rhs.signing &&
            lhs.signingCaptive == rhs.signingCaptive
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(email?.hashValue)
        hasher.combine(sending?.hashValue)
        hasher.combine(signing?.hashValue)
        hasher.combine(signingCaptive?.hashValue)
    }
}
