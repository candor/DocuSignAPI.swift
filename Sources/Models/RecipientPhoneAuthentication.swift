//
// RecipientPhoneAuthentication.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/** A complex type that contains the elements:  * &#x60;recipMayProvideNumber&#x60;: A Boolean value that specifies whether the recipient can use the phone number of their choice. * &#x60;senderProvidedNumbers&#x60;: A list of phone numbers that the recipient can use. * &#x60;recordVoicePrint&#x60;: Reserved for DocuSign. * &#x60;validateRecipProvidedNumber&#x60;: Reserved for DocuSign. */
public final class RecipientPhoneAuthentication: Content {
    /** Boolean. When set to **true**, the recipient can supply a phone number their choice. */
    public var recipMayProvideNumber: String?
    public var recipMayProvideNumberMetadata: PropertyMetadata?
    /** Reserved for DocuSign. */
    public var recordVoicePrint: String?
    public var recordVoicePrintMetadata: PropertyMetadata?
    /** An array containing a list of phone numbers that the recipient can use for SMS text authentication.  */
    public var senderProvidedNumbers: [String]?
    public var senderProvidedNumbersMetadata: PropertyMetadata?
    /**  Reserved for DocuSign. */
    public var validateRecipProvidedNumber: String?
    public var validateRecipProvidedNumberMetadata: PropertyMetadata?

    public init(recipMayProvideNumber: String? = nil, recipMayProvideNumberMetadata: PropertyMetadata? = nil, recordVoicePrint: String? = nil, recordVoicePrintMetadata: PropertyMetadata? = nil, senderProvidedNumbers: [String]? = nil, senderProvidedNumbersMetadata: PropertyMetadata? = nil, validateRecipProvidedNumber: String? = nil, validateRecipProvidedNumberMetadata: PropertyMetadata? = nil) {
        self.recipMayProvideNumber = recipMayProvideNumber
        self.recipMayProvideNumberMetadata = recipMayProvideNumberMetadata
        self.recordVoicePrint = recordVoicePrint
        self.recordVoicePrintMetadata = recordVoicePrintMetadata
        self.senderProvidedNumbers = senderProvidedNumbers
        self.senderProvidedNumbersMetadata = senderProvidedNumbersMetadata
        self.validateRecipProvidedNumber = validateRecipProvidedNumber
        self.validateRecipProvidedNumberMetadata = validateRecipProvidedNumberMetadata
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case recipMayProvideNumber
        case recipMayProvideNumberMetadata
        case recordVoicePrint
        case recordVoicePrintMetadata
        case senderProvidedNumbers
        case senderProvidedNumbersMetadata
        case validateRecipProvidedNumber
        case validateRecipProvidedNumberMetadata
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(recipMayProvideNumber, forKey: .recipMayProvideNumber)
        try container.encodeIfPresent(recipMayProvideNumberMetadata, forKey: .recipMayProvideNumberMetadata)
        try container.encodeIfPresent(recordVoicePrint, forKey: .recordVoicePrint)
        try container.encodeIfPresent(recordVoicePrintMetadata, forKey: .recordVoicePrintMetadata)
        try container.encodeIfPresent(senderProvidedNumbers, forKey: .senderProvidedNumbers)
        try container.encodeIfPresent(senderProvidedNumbersMetadata, forKey: .senderProvidedNumbersMetadata)
        try container.encodeIfPresent(validateRecipProvidedNumber, forKey: .validateRecipProvidedNumber)
        try container.encodeIfPresent(validateRecipProvidedNumberMetadata, forKey: .validateRecipProvidedNumberMetadata)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        recipMayProvideNumber = try container.decodeIfPresent(String.self, forKey: .recipMayProvideNumber)
        recipMayProvideNumberMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .recipMayProvideNumberMetadata)
        recordVoicePrint = try container.decodeIfPresent(String.self, forKey: .recordVoicePrint)
        recordVoicePrintMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .recordVoicePrintMetadata)
        senderProvidedNumbers = try container.decodeIfPresent([String].self, forKey: .senderProvidedNumbers)
        senderProvidedNumbersMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .senderProvidedNumbersMetadata)
        validateRecipProvidedNumber = try container.decodeIfPresent(String.self, forKey: .validateRecipProvidedNumber)
        validateRecipProvidedNumberMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .validateRecipProvidedNumberMetadata)
    }
}

extension RecipientPhoneAuthentication: Hashable {
    public static func == (lhs: RecipientPhoneAuthentication, rhs: RecipientPhoneAuthentication) -> Bool {
        lhs.recipMayProvideNumber == rhs.recipMayProvideNumber &&
            lhs.recipMayProvideNumberMetadata == rhs.recipMayProvideNumberMetadata &&
            lhs.recordVoicePrint == rhs.recordVoicePrint &&
            lhs.recordVoicePrintMetadata == rhs.recordVoicePrintMetadata &&
            lhs.senderProvidedNumbers == rhs.senderProvidedNumbers &&
            lhs.senderProvidedNumbersMetadata == rhs.senderProvidedNumbersMetadata &&
            lhs.validateRecipProvidedNumber == rhs.validateRecipProvidedNumber &&
            lhs.validateRecipProvidedNumberMetadata == rhs.validateRecipProvidedNumberMetadata
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(recipMayProvideNumber?.hashValue)
        hasher.combine(recipMayProvideNumberMetadata?.hashValue)
        hasher.combine(recordVoicePrint?.hashValue)
        hasher.combine(recordVoicePrintMetadata?.hashValue)
        hasher.combine(senderProvidedNumbers?.hashValue)
        hasher.combine(senderProvidedNumbersMetadata?.hashValue)
        hasher.combine(validateRecipProvidedNumber?.hashValue)
        hasher.combine(validateRecipProvidedNumberMetadata?.hashValue)
    }
}
