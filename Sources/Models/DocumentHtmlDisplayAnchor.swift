//
// DocumentHtmlDisplayAnchor.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/**  */
public final class DocumentHtmlDisplayAnchor: Content {
    /** When set to **true**, the start or end anchor strings must match the strings specified by the start and end anchor settings in case as well as in content. */
    public var caseSensitive: Bool?
    public var displaySettings: DocumentHtmlDisplaySettings?
    /** Specifies the end of the area in the HTML where the display settings will be applied. If you do not specify an end anchor, the end of the document will be used by default.  **Note**: A start anchor, an end anchor, or both are required. */
    public var endAnchor: String?
    /** When **true**, removes the end anchor string for the Smart Section from the HTML, preventing it from displaying. */
    public var removeEndAnchor: Bool?
    /** When **true**, removes the start anchor string for the Smart Section from the HTML, preventing it from displaying. */
    public var removeStartAnchor: Bool?
    /** Specifies the beginning of the area in the HTML where the display settings will be applied. If you do not specify a start anchor, the beginning of the document will be used by default.  **Note**: A start anchor, an end anchor, or both are required. */
    public var startAnchor: String?

    public init(caseSensitive: Bool? = nil, displaySettings: DocumentHtmlDisplaySettings? = nil, endAnchor: String? = nil, removeEndAnchor: Bool? = nil, removeStartAnchor: Bool? = nil, startAnchor: String? = nil) {
        self.caseSensitive = caseSensitive
        self.displaySettings = displaySettings
        self.endAnchor = endAnchor
        self.removeEndAnchor = removeEndAnchor
        self.removeStartAnchor = removeStartAnchor
        self.startAnchor = startAnchor
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case caseSensitive
        case displaySettings
        case endAnchor
        case removeEndAnchor
        case removeStartAnchor
        case startAnchor
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(caseSensitive, forKey: .caseSensitive)
        try container.encodeIfPresent(displaySettings, forKey: .displaySettings)
        try container.encodeIfPresent(endAnchor, forKey: .endAnchor)
        try container.encodeIfPresent(removeEndAnchor, forKey: .removeEndAnchor)
        try container.encodeIfPresent(removeStartAnchor, forKey: .removeStartAnchor)
        try container.encodeIfPresent(startAnchor, forKey: .startAnchor)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        caseSensitive = try container.decodeIfPresent(Bool.self, forKey: .caseSensitive)
        displaySettings = try container.decodeIfPresent(DocumentHtmlDisplaySettings.self, forKey: .displaySettings)
        endAnchor = try container.decodeIfPresent(String.self, forKey: .endAnchor)
        removeEndAnchor = try container.decodeIfPresent(Bool.self, forKey: .removeEndAnchor)
        removeStartAnchor = try container.decodeIfPresent(Bool.self, forKey: .removeStartAnchor)
        startAnchor = try container.decodeIfPresent(String.self, forKey: .startAnchor)
    }
}

extension DocumentHtmlDisplayAnchor: Hashable {
    public static func == (lhs: DocumentHtmlDisplayAnchor, rhs: DocumentHtmlDisplayAnchor) -> Bool {
        lhs.caseSensitive == rhs.caseSensitive &&
            lhs.displaySettings == rhs.displaySettings &&
            lhs.endAnchor == rhs.endAnchor &&
            lhs.removeEndAnchor == rhs.removeEndAnchor &&
            lhs.removeStartAnchor == rhs.removeStartAnchor &&
            lhs.startAnchor == rhs.startAnchor
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(caseSensitive?.hashValue)
        hasher.combine(displaySettings?.hashValue)
        hasher.combine(endAnchor?.hashValue)
        hasher.combine(removeEndAnchor?.hashValue)
        hasher.combine(removeStartAnchor?.hashValue)
        hasher.combine(startAnchor?.hashValue)
    }
}
