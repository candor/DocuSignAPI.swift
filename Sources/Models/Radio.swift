//
// Radio.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/** One of the selectable radio buttons in the &#x60;radios&#x60; property of a [&#x60;radioGroup&#x60;](https://developers.docusign.com/esign-rest-api/reference/Envelopes/EnvelopeRecipientTabs/create/#/definitions/radioGroup) tab.  */
public final class Radio: Content {
    /**  */
    public var anchorAllowWhiteSpaceInCharacters: String?
    public var anchorAllowWhiteSpaceInCharactersMetadata: PropertyMetadata?
    /** This property controls how [anchor tabs][AnchorTabs] are placed. When **true**, the text string in a document must match the case of the `anchorString` property for an anchor tab to be created. The default value is **false**.  For example, when set to **true**, if the anchor string is `DocuSign`, then `DocuSign` will match but `Docusign`, `docusign`, `DoCuSiGn`, etc. will not match. When set to **false**, `DocuSign`, `Docusign`, `docusign`, `DoCuSiGn`, etc. will all match.  This functionality uses the following rules:  - Unless punctuation is specified in the `anchorString`, this functionality ignores punctuation and the following characters:    $~><|^+=    For example, the `anchorString` `water` will match on the string `Fetch a pail of water.`  - Strings embedded in other strings are ignored during the matching process.  - In words that have dashes, the parts separated by dashes are treated as distinct words.    Example: If the anchor string is `forget`, then an anchor tab is placed on the `forget` in `forget-me-not`, even when `anchorMatchWholeWord` is set to **true**.  - Letters with accent marks are treated as distinct characters from their unaccented counterparts.  - For single-character anchor strings, if the two characters appear right next to each other in the document, a single anchor tab is placed for both of them.    Example: If the anchor string is `i`, then only one anchor tab is placed in `skiing`.  - Unlike punctuation, numbers are not ignored when finding anchor words.    Example: If the anchor string is `cat`, then `-cat-` is matched but `1cat2` is not when `anchorMatchWholeWord` is set to **true** (its default value).  **Note**: You can only specify the value of this property in POST requests.  [AnchorTabs]: https://developers.docusign.com/esign-rest-api/guides/concepts/tabs#autoplace */
    public var anchorCaseSensitive: String?
    public var anchorCaseSensitiveMetadata: PropertyMetadata?
    /** This property controls how [anchor tabs][AnchorTabs] are aligned in relation to the anchor text. Possible values are :  - `left`: Aligns the left side of the tab with the beginning of the first character of the matching anchor word. This is the default value. - `right`: Aligns the tab’s left side with the last character of the matching anchor word.  **Note**: You can only specify the value of this property in POST requests.  [AnchorTabs]: https://developers.docusign.com/esign-rest-api/guides/concepts/tabs#autoplace  */
    public var anchorHorizontalAlignment: String?
    public var anchorHorizontalAlignmentMetadata: PropertyMetadata?
    /** When set to **true**, this tab is ignored if the `anchorString` is not found in the document. */
    public var anchorIgnoreIfNotPresent: String?
    public var anchorIgnoreIfNotPresentMetadata: PropertyMetadata?
    /** When set to **true**, the text string in a document must match the value of the `anchorString` property in its entirety for an [anchor tab][AnchorTab] to be created. The default value is **false**.  For example, when set to **true**, if the input is `man` then `man` will match but `manpower`, `fireman`, and `penmanship` will not. When set to **false**, if the input is `man` then `man`, `manpower`, `fireman`, and `penmanship` will all match.  This functionality uses the following rules:  - Unless punctuation is specified in the `anchorString`, this functionality ignores punctuation and the following characters:    $~><|^+=    For example, the `anchorString` `water` will match on the string `Fetch a pail of water.`  - Strings embedded in other strings are ignored during the matching process.  - In words that have dashes, the parts separated by dashes are treated as distinct words.    Example: If the anchor string is `forget`, then an anchor tab is placed on the `forget` in `forget-me-not`, even when `anchorMatchWholeWord` is set to **true**.  - Letters with accent marks are treated as distinct characters from their unaccented counterparts.  - For single-character anchor strings, if the two characters appear right next to each other in the document, a single anchor tab is placed for both of them.    Example: If the anchor string is `i`, then only one anchor tab is placed in `skiing`.  - Unlike punctuation, numbers are not ignored when finding anchor words.    Example: If the anchor string is `cat`, then `-cat-` is matched but `1cat2` is not when `anchorMatchWholeWord` is set to **true** (its default value).   **Note**: You can only specify the value of this property in POST requests.  [AnchorTab]: https://developers.docusign.com/esign-rest-api/guides/concepts/tabs#autoplace  */
    public var anchorMatchWholeWord: String?
    public var anchorMatchWholeWordMetadata: PropertyMetadata?
    /** Specifies the string to find in the document and use as the basis for tab placement. */
    public var anchorString: String?
    public var anchorStringMetadata: PropertyMetadata?
    /** Reserved for DocuSign. */
    public var anchorTabProcessorVersion: String?
    public var anchorTabProcessorVersionMetadata: PropertyMetadata?
    /** Specifies units of the `anchorXOffset` and `anchorYOffset`. Valid units are:  - `pixels` - `inches` - `mms` - `cms`  */
    public var anchorUnits: String?
    public var anchorUnitsMetadata: PropertyMetadata?
    /** Specifies the X axis location of the tab in `anchorUnits` relative to the `anchorString`.  */
    public var anchorXOffset: String?
    public var anchorXOffsetMetadata: PropertyMetadata?
    /** Specifies the Y axis location of the tab in `anchorUnits` relative to the `anchorString`.  */
    public var anchorYOffset: String?
    public var anchorYOffsetMetadata: PropertyMetadata?
    /** When set to **true**, the information in the tab is bold. */
    public var bold: String?
    public var boldMetadata: PropertyMetadata?
    public var errorDetails: ErrorDetails?
    /** The font to be used for the tab value. Supported fonts include:  - Default - Arial - ArialNarrow - Calibri - CourierNew - Garamond - Georgia - Helvetica - LucidaConsole - MSGothic - MSMincho - OCR-A - Tahoma - TimesNewRoman - Trebuchet - Verdana  */
    public var font: String?
    /** The font color to use for the information in the tab. Possible values are:   - Black - BrightBlue - BrightRed - DarkGreen - DarkRed - Gold - Green - NavyBlue - Purple - White  */
    public var fontColor: String?
    public var fontColorMetadata: PropertyMetadata?
    public var fontMetadata: PropertyMetadata?
    /** The font size used for the information in the tab. Possible values are:  - Size7 - Size8 - Size9 - Size10 - Size11 - Size12 - Size14 - Size16 - Size18 - Size20 - Size22 - Size24 - Size26 - Size28 - Size36 - Size48 - Size72 */
    public var fontSize: String?
    public var fontSizeMetadata: PropertyMetadata?
    /** When set to **true**, the information in the tab is italic. */
    public var italic: String?
    public var italicMetadata: PropertyMetadata?
    /** When set to **true**, the signer cannot change the data of the custom tab. */
    public var locked: String?
    public var lockedMetadata: PropertyMetadata?
    /** Specifies the page number on which the tab is located. Must be 1 for supplemental documents.  */
    public var pageNumber: String?
    public var pageNumberMetadata: PropertyMetadata?
    /** When set to **true**, the signer is required to fill out this tab. */
    public var required: String?
    public var requiredMetadata: PropertyMetadata?
    /** When set to **true**, the radio button is selected. */
    public var selected: String?
    public var selectedMetadata: PropertyMetadata?
    /** The status of the item. */
    public var status: String?
    public var statusMetadata: PropertyMetadata?
    /** The unique identifier for the tab. */
    public var tabId: String?
    public var tabIdMetadata: PropertyMetadata?
    /** A positive integer that sets the order the tab is navigated to during signing.  Tabs on a page are navigated to in ascending order, starting with the lowest number and moving to the highest. If two or more tabs have the same `tabOrder` value, the normal auto-navigation setting behavior for the envelope is used. */
    public var tabOrder: String?
    public var tabOrderMetadata: PropertyMetadata?
    /** When set to **true**, the information in the tab is underlined. */
    public var underline: String?
    public var underlineMetadata: PropertyMetadata?
    /** Specifies the value of the tab.  */
    public var value: String?
    public var valueMetadata: PropertyMetadata?
    /** This property indicates the horizontal offset of the object on the page. DocuSign uses 72 DPI when determining position. Required. May be zero.  */
    public var xPosition: String?
    public var xPositionMetadata: PropertyMetadata?
    /** This property indicates the vertical offset of the object on the page. DocuSign uses 72 DPI when determining position. Required. May be zero.  */
    public var yPosition: String?
    public var yPositionMetadata: PropertyMetadata?

    public init(anchorAllowWhiteSpaceInCharacters: String? = nil, anchorAllowWhiteSpaceInCharactersMetadata: PropertyMetadata? = nil, anchorCaseSensitive: String? = nil, anchorCaseSensitiveMetadata: PropertyMetadata? = nil, anchorHorizontalAlignment: String? = nil, anchorHorizontalAlignmentMetadata: PropertyMetadata? = nil, anchorIgnoreIfNotPresent: String? = nil, anchorIgnoreIfNotPresentMetadata: PropertyMetadata? = nil, anchorMatchWholeWord: String? = nil, anchorMatchWholeWordMetadata: PropertyMetadata? = nil, anchorString: String? = nil, anchorStringMetadata: PropertyMetadata? = nil, anchorTabProcessorVersion: String? = nil, anchorTabProcessorVersionMetadata: PropertyMetadata? = nil, anchorUnits: String? = nil, anchorUnitsMetadata: PropertyMetadata? = nil, anchorXOffset: String? = nil, anchorXOffsetMetadata: PropertyMetadata? = nil, anchorYOffset: String? = nil, anchorYOffsetMetadata: PropertyMetadata? = nil, bold: String? = nil, boldMetadata: PropertyMetadata? = nil, errorDetails: ErrorDetails? = nil, font: String? = nil, fontColor: String? = nil, fontColorMetadata: PropertyMetadata? = nil, fontMetadata: PropertyMetadata? = nil, fontSize: String? = nil, fontSizeMetadata: PropertyMetadata? = nil, italic: String? = nil, italicMetadata: PropertyMetadata? = nil, locked: String? = nil, lockedMetadata: PropertyMetadata? = nil, pageNumber: String? = nil, pageNumberMetadata: PropertyMetadata? = nil, required: String? = nil, requiredMetadata: PropertyMetadata? = nil, selected: String? = nil, selectedMetadata: PropertyMetadata? = nil, status: String? = nil, statusMetadata: PropertyMetadata? = nil, tabId: String? = nil, tabIdMetadata: PropertyMetadata? = nil, tabOrder: String? = nil, tabOrderMetadata: PropertyMetadata? = nil, underline: String? = nil, underlineMetadata: PropertyMetadata? = nil, value: String? = nil, valueMetadata: PropertyMetadata? = nil, xPosition: String? = nil, xPositionMetadata: PropertyMetadata? = nil, yPosition: String? = nil, yPositionMetadata: PropertyMetadata? = nil) {
        self.anchorAllowWhiteSpaceInCharacters = anchorAllowWhiteSpaceInCharacters
        self.anchorAllowWhiteSpaceInCharactersMetadata = anchorAllowWhiteSpaceInCharactersMetadata
        self.anchorCaseSensitive = anchorCaseSensitive
        self.anchorCaseSensitiveMetadata = anchorCaseSensitiveMetadata
        self.anchorHorizontalAlignment = anchorHorizontalAlignment
        self.anchorHorizontalAlignmentMetadata = anchorHorizontalAlignmentMetadata
        self.anchorIgnoreIfNotPresent = anchorIgnoreIfNotPresent
        self.anchorIgnoreIfNotPresentMetadata = anchorIgnoreIfNotPresentMetadata
        self.anchorMatchWholeWord = anchorMatchWholeWord
        self.anchorMatchWholeWordMetadata = anchorMatchWholeWordMetadata
        self.anchorString = anchorString
        self.anchorStringMetadata = anchorStringMetadata
        self.anchorTabProcessorVersion = anchorTabProcessorVersion
        self.anchorTabProcessorVersionMetadata = anchorTabProcessorVersionMetadata
        self.anchorUnits = anchorUnits
        self.anchorUnitsMetadata = anchorUnitsMetadata
        self.anchorXOffset = anchorXOffset
        self.anchorXOffsetMetadata = anchorXOffsetMetadata
        self.anchorYOffset = anchorYOffset
        self.anchorYOffsetMetadata = anchorYOffsetMetadata
        self.bold = bold
        self.boldMetadata = boldMetadata
        self.errorDetails = errorDetails
        self.font = font
        self.fontColor = fontColor
        self.fontColorMetadata = fontColorMetadata
        self.fontMetadata = fontMetadata
        self.fontSize = fontSize
        self.fontSizeMetadata = fontSizeMetadata
        self.italic = italic
        self.italicMetadata = italicMetadata
        self.locked = locked
        self.lockedMetadata = lockedMetadata
        self.pageNumber = pageNumber
        self.pageNumberMetadata = pageNumberMetadata
        self.required = required
        self.requiredMetadata = requiredMetadata
        self.selected = selected
        self.selectedMetadata = selectedMetadata
        self.status = status
        self.statusMetadata = statusMetadata
        self.tabId = tabId
        self.tabIdMetadata = tabIdMetadata
        self.tabOrder = tabOrder
        self.tabOrderMetadata = tabOrderMetadata
        self.underline = underline
        self.underlineMetadata = underlineMetadata
        self.value = value
        self.valueMetadata = valueMetadata
        self.xPosition = xPosition
        self.xPositionMetadata = xPositionMetadata
        self.yPosition = yPosition
        self.yPositionMetadata = yPositionMetadata
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case anchorAllowWhiteSpaceInCharacters
        case anchorAllowWhiteSpaceInCharactersMetadata
        case anchorCaseSensitive
        case anchorCaseSensitiveMetadata
        case anchorHorizontalAlignment
        case anchorHorizontalAlignmentMetadata
        case anchorIgnoreIfNotPresent
        case anchorIgnoreIfNotPresentMetadata
        case anchorMatchWholeWord
        case anchorMatchWholeWordMetadata
        case anchorString
        case anchorStringMetadata
        case anchorTabProcessorVersion
        case anchorTabProcessorVersionMetadata
        case anchorUnits
        case anchorUnitsMetadata
        case anchorXOffset
        case anchorXOffsetMetadata
        case anchorYOffset
        case anchorYOffsetMetadata
        case bold
        case boldMetadata
        case errorDetails
        case font
        case fontColor
        case fontColorMetadata
        case fontMetadata
        case fontSize
        case fontSizeMetadata
        case italic
        case italicMetadata
        case locked
        case lockedMetadata
        case pageNumber
        case pageNumberMetadata
        case required
        case requiredMetadata
        case selected
        case selectedMetadata
        case status
        case statusMetadata
        case tabId
        case tabIdMetadata
        case tabOrder
        case tabOrderMetadata
        case underline
        case underlineMetadata
        case value
        case valueMetadata
        case xPosition
        case xPositionMetadata
        case yPosition
        case yPositionMetadata
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(anchorAllowWhiteSpaceInCharacters, forKey: .anchorAllowWhiteSpaceInCharacters)
        try container.encodeIfPresent(anchorAllowWhiteSpaceInCharactersMetadata, forKey: .anchorAllowWhiteSpaceInCharactersMetadata)
        try container.encodeIfPresent(anchorCaseSensitive, forKey: .anchorCaseSensitive)
        try container.encodeIfPresent(anchorCaseSensitiveMetadata, forKey: .anchorCaseSensitiveMetadata)
        try container.encodeIfPresent(anchorHorizontalAlignment, forKey: .anchorHorizontalAlignment)
        try container.encodeIfPresent(anchorHorizontalAlignmentMetadata, forKey: .anchorHorizontalAlignmentMetadata)
        try container.encodeIfPresent(anchorIgnoreIfNotPresent, forKey: .anchorIgnoreIfNotPresent)
        try container.encodeIfPresent(anchorIgnoreIfNotPresentMetadata, forKey: .anchorIgnoreIfNotPresentMetadata)
        try container.encodeIfPresent(anchorMatchWholeWord, forKey: .anchorMatchWholeWord)
        try container.encodeIfPresent(anchorMatchWholeWordMetadata, forKey: .anchorMatchWholeWordMetadata)
        try container.encodeIfPresent(anchorString, forKey: .anchorString)
        try container.encodeIfPresent(anchorStringMetadata, forKey: .anchorStringMetadata)
        try container.encodeIfPresent(anchorTabProcessorVersion, forKey: .anchorTabProcessorVersion)
        try container.encodeIfPresent(anchorTabProcessorVersionMetadata, forKey: .anchorTabProcessorVersionMetadata)
        try container.encodeIfPresent(anchorUnits, forKey: .anchorUnits)
        try container.encodeIfPresent(anchorUnitsMetadata, forKey: .anchorUnitsMetadata)
        try container.encodeIfPresent(anchorXOffset, forKey: .anchorXOffset)
        try container.encodeIfPresent(anchorXOffsetMetadata, forKey: .anchorXOffsetMetadata)
        try container.encodeIfPresent(anchorYOffset, forKey: .anchorYOffset)
        try container.encodeIfPresent(anchorYOffsetMetadata, forKey: .anchorYOffsetMetadata)
        try container.encodeIfPresent(bold, forKey: .bold)
        try container.encodeIfPresent(boldMetadata, forKey: .boldMetadata)
        try container.encodeIfPresent(errorDetails, forKey: .errorDetails)
        try container.encodeIfPresent(font, forKey: .font)
        try container.encodeIfPresent(fontColor, forKey: .fontColor)
        try container.encodeIfPresent(fontColorMetadata, forKey: .fontColorMetadata)
        try container.encodeIfPresent(fontMetadata, forKey: .fontMetadata)
        try container.encodeIfPresent(fontSize, forKey: .fontSize)
        try container.encodeIfPresent(fontSizeMetadata, forKey: .fontSizeMetadata)
        try container.encodeIfPresent(italic, forKey: .italic)
        try container.encodeIfPresent(italicMetadata, forKey: .italicMetadata)
        try container.encodeIfPresent(locked, forKey: .locked)
        try container.encodeIfPresent(lockedMetadata, forKey: .lockedMetadata)
        try container.encodeIfPresent(pageNumber, forKey: .pageNumber)
        try container.encodeIfPresent(pageNumberMetadata, forKey: .pageNumberMetadata)
        try container.encodeIfPresent(required, forKey: .required)
        try container.encodeIfPresent(requiredMetadata, forKey: .requiredMetadata)
        try container.encodeIfPresent(selected, forKey: .selected)
        try container.encodeIfPresent(selectedMetadata, forKey: .selectedMetadata)
        try container.encodeIfPresent(status, forKey: .status)
        try container.encodeIfPresent(statusMetadata, forKey: .statusMetadata)
        try container.encodeIfPresent(tabId, forKey: .tabId)
        try container.encodeIfPresent(tabIdMetadata, forKey: .tabIdMetadata)
        try container.encodeIfPresent(tabOrder, forKey: .tabOrder)
        try container.encodeIfPresent(tabOrderMetadata, forKey: .tabOrderMetadata)
        try container.encodeIfPresent(underline, forKey: .underline)
        try container.encodeIfPresent(underlineMetadata, forKey: .underlineMetadata)
        try container.encodeIfPresent(value, forKey: .value)
        try container.encodeIfPresent(valueMetadata, forKey: .valueMetadata)
        try container.encodeIfPresent(xPosition, forKey: .xPosition)
        try container.encodeIfPresent(xPositionMetadata, forKey: .xPositionMetadata)
        try container.encodeIfPresent(yPosition, forKey: .yPosition)
        try container.encodeIfPresent(yPositionMetadata, forKey: .yPositionMetadata)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        anchorAllowWhiteSpaceInCharacters = try container.decodeIfPresent(String.self, forKey: .anchorAllowWhiteSpaceInCharacters)
        anchorAllowWhiteSpaceInCharactersMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .anchorAllowWhiteSpaceInCharactersMetadata)
        anchorCaseSensitive = try container.decodeIfPresent(String.self, forKey: .anchorCaseSensitive)
        anchorCaseSensitiveMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .anchorCaseSensitiveMetadata)
        anchorHorizontalAlignment = try container.decodeIfPresent(String.self, forKey: .anchorHorizontalAlignment)
        anchorHorizontalAlignmentMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .anchorHorizontalAlignmentMetadata)
        anchorIgnoreIfNotPresent = try container.decodeIfPresent(String.self, forKey: .anchorIgnoreIfNotPresent)
        anchorIgnoreIfNotPresentMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .anchorIgnoreIfNotPresentMetadata)
        anchorMatchWholeWord = try container.decodeIfPresent(String.self, forKey: .anchorMatchWholeWord)
        anchorMatchWholeWordMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .anchorMatchWholeWordMetadata)
        anchorString = try container.decodeIfPresent(String.self, forKey: .anchorString)
        anchorStringMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .anchorStringMetadata)
        anchorTabProcessorVersion = try container.decodeIfPresent(String.self, forKey: .anchorTabProcessorVersion)
        anchorTabProcessorVersionMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .anchorTabProcessorVersionMetadata)
        anchorUnits = try container.decodeIfPresent(String.self, forKey: .anchorUnits)
        anchorUnitsMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .anchorUnitsMetadata)
        anchorXOffset = try container.decodeIfPresent(String.self, forKey: .anchorXOffset)
        anchorXOffsetMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .anchorXOffsetMetadata)
        anchorYOffset = try container.decodeIfPresent(String.self, forKey: .anchorYOffset)
        anchorYOffsetMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .anchorYOffsetMetadata)
        bold = try container.decodeIfPresent(String.self, forKey: .bold)
        boldMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .boldMetadata)
        errorDetails = try container.decodeIfPresent(ErrorDetails.self, forKey: .errorDetails)
        font = try container.decodeIfPresent(String.self, forKey: .font)
        fontColor = try container.decodeIfPresent(String.self, forKey: .fontColor)
        fontColorMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .fontColorMetadata)
        fontMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .fontMetadata)
        fontSize = try container.decodeIfPresent(String.self, forKey: .fontSize)
        fontSizeMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .fontSizeMetadata)
        italic = try container.decodeIfPresent(String.self, forKey: .italic)
        italicMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .italicMetadata)
        locked = try container.decodeIfPresent(String.self, forKey: .locked)
        lockedMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .lockedMetadata)
        pageNumber = try container.decodeIfPresent(String.self, forKey: .pageNumber)
        pageNumberMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .pageNumberMetadata)
        required = try container.decodeIfPresent(String.self, forKey: .required)
        requiredMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .requiredMetadata)
        selected = try container.decodeIfPresent(String.self, forKey: .selected)
        selectedMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .selectedMetadata)
        status = try container.decodeIfPresent(String.self, forKey: .status)
        statusMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .statusMetadata)
        tabId = try container.decodeIfPresent(String.self, forKey: .tabId)
        tabIdMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .tabIdMetadata)
        tabOrder = try container.decodeIfPresent(String.self, forKey: .tabOrder)
        tabOrderMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .tabOrderMetadata)
        underline = try container.decodeIfPresent(String.self, forKey: .underline)
        underlineMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .underlineMetadata)
        value = try container.decodeIfPresent(String.self, forKey: .value)
        valueMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .valueMetadata)
        xPosition = try container.decodeIfPresent(String.self, forKey: .xPosition)
        xPositionMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .xPositionMetadata)
        yPosition = try container.decodeIfPresent(String.self, forKey: .yPosition)
        yPositionMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .yPositionMetadata)
    }
}

extension Radio: Hashable {
    public static func == (lhs: Radio, rhs: Radio) -> Bool {
        lhs.anchorAllowWhiteSpaceInCharacters == rhs.anchorAllowWhiteSpaceInCharacters &&
            lhs.anchorAllowWhiteSpaceInCharactersMetadata == rhs.anchorAllowWhiteSpaceInCharactersMetadata &&
            lhs.anchorCaseSensitive == rhs.anchorCaseSensitive &&
            lhs.anchorCaseSensitiveMetadata == rhs.anchorCaseSensitiveMetadata &&
            lhs.anchorHorizontalAlignment == rhs.anchorHorizontalAlignment &&
            lhs.anchorHorizontalAlignmentMetadata == rhs.anchorHorizontalAlignmentMetadata &&
            lhs.anchorIgnoreIfNotPresent == rhs.anchorIgnoreIfNotPresent &&
            lhs.anchorIgnoreIfNotPresentMetadata == rhs.anchorIgnoreIfNotPresentMetadata &&
            lhs.anchorMatchWholeWord == rhs.anchorMatchWholeWord &&
            lhs.anchorMatchWholeWordMetadata == rhs.anchorMatchWholeWordMetadata &&
            lhs.anchorString == rhs.anchorString &&
            lhs.anchorStringMetadata == rhs.anchorStringMetadata &&
            lhs.anchorTabProcessorVersion == rhs.anchorTabProcessorVersion &&
            lhs.anchorTabProcessorVersionMetadata == rhs.anchorTabProcessorVersionMetadata &&
            lhs.anchorUnits == rhs.anchorUnits &&
            lhs.anchorUnitsMetadata == rhs.anchorUnitsMetadata &&
            lhs.anchorXOffset == rhs.anchorXOffset &&
            lhs.anchorXOffsetMetadata == rhs.anchorXOffsetMetadata &&
            lhs.anchorYOffset == rhs.anchorYOffset &&
            lhs.anchorYOffsetMetadata == rhs.anchorYOffsetMetadata &&
            lhs.bold == rhs.bold &&
            lhs.boldMetadata == rhs.boldMetadata &&
            lhs.errorDetails == rhs.errorDetails &&
            lhs.font == rhs.font &&
            lhs.fontColor == rhs.fontColor &&
            lhs.fontColorMetadata == rhs.fontColorMetadata &&
            lhs.fontMetadata == rhs.fontMetadata &&
            lhs.fontSize == rhs.fontSize &&
            lhs.fontSizeMetadata == rhs.fontSizeMetadata &&
            lhs.italic == rhs.italic &&
            lhs.italicMetadata == rhs.italicMetadata &&
            lhs.locked == rhs.locked &&
            lhs.lockedMetadata == rhs.lockedMetadata &&
            lhs.pageNumber == rhs.pageNumber &&
            lhs.pageNumberMetadata == rhs.pageNumberMetadata &&
            lhs.required == rhs.required &&
            lhs.requiredMetadata == rhs.requiredMetadata &&
            lhs.selected == rhs.selected &&
            lhs.selectedMetadata == rhs.selectedMetadata &&
            lhs.status == rhs.status &&
            lhs.statusMetadata == rhs.statusMetadata &&
            lhs.tabId == rhs.tabId &&
            lhs.tabIdMetadata == rhs.tabIdMetadata &&
            lhs.tabOrder == rhs.tabOrder &&
            lhs.tabOrderMetadata == rhs.tabOrderMetadata &&
            lhs.underline == rhs.underline &&
            lhs.underlineMetadata == rhs.underlineMetadata &&
            lhs.value == rhs.value &&
            lhs.valueMetadata == rhs.valueMetadata &&
            lhs.xPosition == rhs.xPosition &&
            lhs.xPositionMetadata == rhs.xPositionMetadata &&
            lhs.yPosition == rhs.yPosition &&
            lhs.yPositionMetadata == rhs.yPositionMetadata
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(anchorAllowWhiteSpaceInCharacters?.hashValue)
        hasher.combine(anchorAllowWhiteSpaceInCharactersMetadata?.hashValue)
        hasher.combine(anchorCaseSensitive?.hashValue)
        hasher.combine(anchorCaseSensitiveMetadata?.hashValue)
        hasher.combine(anchorHorizontalAlignment?.hashValue)
        hasher.combine(anchorHorizontalAlignmentMetadata?.hashValue)
        hasher.combine(anchorIgnoreIfNotPresent?.hashValue)
        hasher.combine(anchorIgnoreIfNotPresentMetadata?.hashValue)
        hasher.combine(anchorMatchWholeWord?.hashValue)
        hasher.combine(anchorMatchWholeWordMetadata?.hashValue)
        hasher.combine(anchorString?.hashValue)
        hasher.combine(anchorStringMetadata?.hashValue)
        hasher.combine(anchorTabProcessorVersion?.hashValue)
        hasher.combine(anchorTabProcessorVersionMetadata?.hashValue)
        hasher.combine(anchorUnits?.hashValue)
        hasher.combine(anchorUnitsMetadata?.hashValue)
        hasher.combine(anchorXOffset?.hashValue)
        hasher.combine(anchorXOffsetMetadata?.hashValue)
        hasher.combine(anchorYOffset?.hashValue)
        hasher.combine(anchorYOffsetMetadata?.hashValue)
        hasher.combine(bold?.hashValue)
        hasher.combine(boldMetadata?.hashValue)
        hasher.combine(errorDetails?.hashValue)
        hasher.combine(font?.hashValue)
        hasher.combine(fontColor?.hashValue)
        hasher.combine(fontColorMetadata?.hashValue)
        hasher.combine(fontMetadata?.hashValue)
        hasher.combine(fontSize?.hashValue)
        hasher.combine(fontSizeMetadata?.hashValue)
        hasher.combine(italic?.hashValue)
        hasher.combine(italicMetadata?.hashValue)
        hasher.combine(locked?.hashValue)
        hasher.combine(lockedMetadata?.hashValue)
        hasher.combine(pageNumber?.hashValue)
        hasher.combine(pageNumberMetadata?.hashValue)
        hasher.combine(required?.hashValue)
        hasher.combine(requiredMetadata?.hashValue)
        hasher.combine(selected?.hashValue)
        hasher.combine(selectedMetadata?.hashValue)
        hasher.combine(status?.hashValue)
        hasher.combine(statusMetadata?.hashValue)
        hasher.combine(tabId?.hashValue)
        hasher.combine(tabIdMetadata?.hashValue)
        hasher.combine(tabOrder?.hashValue)
        hasher.combine(tabOrderMetadata?.hashValue)
        hasher.combine(underline?.hashValue)
        hasher.combine(underlineMetadata?.hashValue)
        hasher.combine(value?.hashValue)
        hasher.combine(valueMetadata?.hashValue)
        hasher.combine(xPosition?.hashValue)
        hasher.combine(xPositionMetadata?.hashValue)
        hasher.combine(yPosition?.hashValue)
        hasher.combine(yPositionMetadata?.hashValue)
    }
}
