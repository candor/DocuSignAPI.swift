//
// RecipientNamesResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/** This response object contains a list of recipients. */
public final class RecipientNamesResponse: Content {
    /** When set to **true**, the email address is used by more than one user. */
    public var multipleUsers: String?
    /** The names of the recipients associated with the email address. */
    public var recipientNames: [String]?
    /** When set to **true**, new names cannot be added to the email address. */
    public var reservedRecipientEmail: String?

    public init(multipleUsers: String? = nil, recipientNames: [String]? = nil, reservedRecipientEmail: String? = nil) {
        self.multipleUsers = multipleUsers
        self.recipientNames = recipientNames
        self.reservedRecipientEmail = reservedRecipientEmail
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case multipleUsers
        case recipientNames
        case reservedRecipientEmail
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(multipleUsers, forKey: .multipleUsers)
        try container.encodeIfPresent(recipientNames, forKey: .recipientNames)
        try container.encodeIfPresent(reservedRecipientEmail, forKey: .reservedRecipientEmail)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        multipleUsers = try container.decodeIfPresent(String.self, forKey: .multipleUsers)
        recipientNames = try container.decodeIfPresent([String].self, forKey: .recipientNames)
        reservedRecipientEmail = try container.decodeIfPresent(String.self, forKey: .reservedRecipientEmail)
    }
}

extension RecipientNamesResponse: Hashable {
    public static func == (lhs: RecipientNamesResponse, rhs: RecipientNamesResponse) -> Bool {
        lhs.multipleUsers == rhs.multipleUsers &&
            lhs.recipientNames == rhs.recipientNames &&
            lhs.reservedRecipientEmail == rhs.reservedRecipientEmail
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(multipleUsers?.hashValue)
        hasher.combine(recipientNames?.hashValue)
        hasher.combine(reservedRecipientEmail?.hashValue)
    }
}
