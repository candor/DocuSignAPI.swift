//
// BccEmailArchive.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/** This object contains information abut a BCC email archive configuration (a BCC email address used to archive DocuSign-generated emails). */
public final class BccEmailArchive: Content {
    /** The id of the account that owns the BCC email archive configuration. */
    public var accountId: String?
    /** The id of the BCC email archive configuration. */
    public var bccEmailArchiveId: String?
    /** The UTC DateTime when the BCC email archive configuration was created. */
    public var created: String?
    public var createdBy: UserInfo?
    /** The BCC email address to use for archiving DocuSign messages.  Example: customer_bcc@example.com */
    public var email: String?
    /** The GUID of the activation email message sent to the BCC email address. */
    public var emailNotificationId: String?
    /** The UTC DateTime when the BCC email archive configuration was last modified. */
    public var modified: String?
    public var modifiedBy: UserInfo?
    /** The status of the BCC email address. Possible values are:  - `activation_sent`: An activation link has been sent to the BCC email address. - `active`: The BCC email address is actively used for archiving. - `closed`: The BCC email address is no longer used for archiving. */
    public var status: String?
    /** The helper URI for retrieving the BCC email archive. */
    public var uri: String?

    public init(accountId: String? = nil, bccEmailArchiveId: String? = nil, created: String? = nil, createdBy: UserInfo? = nil, email: String? = nil, emailNotificationId: String? = nil, modified: String? = nil, modifiedBy: UserInfo? = nil, status: String? = nil, uri: String? = nil) {
        self.accountId = accountId
        self.bccEmailArchiveId = bccEmailArchiveId
        self.created = created
        self.createdBy = createdBy
        self.email = email
        self.emailNotificationId = emailNotificationId
        self.modified = modified
        self.modifiedBy = modifiedBy
        self.status = status
        self.uri = uri
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case accountId
        case bccEmailArchiveId
        case created
        case createdBy
        case email
        case emailNotificationId
        case modified
        case modifiedBy
        case status
        case uri
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(accountId, forKey: .accountId)
        try container.encodeIfPresent(bccEmailArchiveId, forKey: .bccEmailArchiveId)
        try container.encodeIfPresent(created, forKey: .created)
        try container.encodeIfPresent(createdBy, forKey: .createdBy)
        try container.encodeIfPresent(email, forKey: .email)
        try container.encodeIfPresent(emailNotificationId, forKey: .emailNotificationId)
        try container.encodeIfPresent(modified, forKey: .modified)
        try container.encodeIfPresent(modifiedBy, forKey: .modifiedBy)
        try container.encodeIfPresent(status, forKey: .status)
        try container.encodeIfPresent(uri, forKey: .uri)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        accountId = try container.decodeIfPresent(String.self, forKey: .accountId)
        bccEmailArchiveId = try container.decodeIfPresent(String.self, forKey: .bccEmailArchiveId)
        created = try container.decodeIfPresent(String.self, forKey: .created)
        createdBy = try container.decodeIfPresent(UserInfo.self, forKey: .createdBy)
        email = try container.decodeIfPresent(String.self, forKey: .email)
        emailNotificationId = try container.decodeIfPresent(String.self, forKey: .emailNotificationId)
        modified = try container.decodeIfPresent(String.self, forKey: .modified)
        modifiedBy = try container.decodeIfPresent(UserInfo.self, forKey: .modifiedBy)
        status = try container.decodeIfPresent(String.self, forKey: .status)
        uri = try container.decodeIfPresent(String.self, forKey: .uri)
    }
}

extension BccEmailArchive: Hashable {
    public static func == (lhs: BccEmailArchive, rhs: BccEmailArchive) -> Bool {
        lhs.accountId == rhs.accountId &&
            lhs.bccEmailArchiveId == rhs.bccEmailArchiveId &&
            lhs.created == rhs.created &&
            lhs.createdBy == rhs.createdBy &&
            lhs.email == rhs.email &&
            lhs.emailNotificationId == rhs.emailNotificationId &&
            lhs.modified == rhs.modified &&
            lhs.modifiedBy == rhs.modifiedBy &&
            lhs.status == rhs.status &&
            lhs.uri == rhs.uri
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accountId?.hashValue)
        hasher.combine(bccEmailArchiveId?.hashValue)
        hasher.combine(created?.hashValue)
        hasher.combine(createdBy?.hashValue)
        hasher.combine(email?.hashValue)
        hasher.combine(emailNotificationId?.hashValue)
        hasher.combine(modified?.hashValue)
        hasher.combine(modifiedBy?.hashValue)
        hasher.combine(status?.hashValue)
        hasher.combine(uri?.hashValue)
    }
}
