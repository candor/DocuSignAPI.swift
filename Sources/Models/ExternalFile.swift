//
// ExternalFile.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/** This object contains information about a file or folder in cloud storage. */
public final class ExternalFile: Content {
    /** The UTC date and time that the file or folder was last modified. */
    public var date: String?
    /** The storage provider's id for the file or folder. */
    public var id: String?
    /** The file extension for a file.  **Note**: If the item is a folder, this value is null. */
    public var img: String?
    /** The full name of a file. */
    public var name: String?
    /** The size of the file. The file size limit varies based on the cloud storage provider. */
    public var size: String?
    /** When set to **true**, DocuSign supports the file type for upload. */
    public var supported: String?
    /** The type of cloud storage item. Valid values are:  - `file` - `folder` */
    public var type: String?
    /** The URI for the file or folder. */
    public var uri: String?

    public init(date: String? = nil, id: String? = nil, img: String? = nil, name: String? = nil, size: String? = nil, supported: String? = nil, type: String? = nil, uri: String? = nil) {
        self.date = date
        self.id = id
        self.img = img
        self.name = name
        self.size = size
        self.supported = supported
        self.type = type
        self.uri = uri
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case date
        case id
        case img
        case name
        case size
        case supported
        case type
        case uri
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(date, forKey: .date)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(img, forKey: .img)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(size, forKey: .size)
        try container.encodeIfPresent(supported, forKey: .supported)
        try container.encodeIfPresent(type, forKey: .type)
        try container.encodeIfPresent(uri, forKey: .uri)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        date = try container.decodeIfPresent(String.self, forKey: .date)
        id = try container.decodeIfPresent(String.self, forKey: .id)
        img = try container.decodeIfPresent(String.self, forKey: .img)
        name = try container.decodeIfPresent(String.self, forKey: .name)
        size = try container.decodeIfPresent(String.self, forKey: .size)
        supported = try container.decodeIfPresent(String.self, forKey: .supported)
        type = try container.decodeIfPresent(String.self, forKey: .type)
        uri = try container.decodeIfPresent(String.self, forKey: .uri)
    }
}

extension ExternalFile: Hashable {
    public static func == (lhs: ExternalFile, rhs: ExternalFile) -> Bool {
        lhs.date == rhs.date &&
            lhs.id == rhs.id &&
            lhs.img == rhs.img &&
            lhs.name == rhs.name &&
            lhs.size == rhs.size &&
            lhs.supported == rhs.supported &&
            lhs.type == rhs.type &&
            lhs.uri == rhs.uri
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(date?.hashValue)
        hasher.combine(id?.hashValue)
        hasher.combine(img?.hashValue)
        hasher.combine(name?.hashValue)
        hasher.combine(size?.hashValue)
        hasher.combine(supported?.hashValue)
        hasher.combine(type?.hashValue)
        hasher.combine(uri?.hashValue)
    }
}
