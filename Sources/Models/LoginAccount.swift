//
// LoginAccount.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/**  */
public final class LoginAccount: Content {
    /** The account ID associated with the envelope. */
    public var accountId: String?
    /** The GUID associated with the account ID. */
    public var accountIdGuid: String?
    /** The URL that should be used for successive calls to this account. It includes the protocal (https), the DocuSign server where the account is located, and the account number. Use this Url to make API calls against this account. Many of the API calls provide Uri's that are relative to this baseUrl. */
    public var baseUrl: String?
    /** The email address for the user. */
    public var email: String?
    /** This value is true if this is the default account for the user, otherwise false is returned. */
    public var isDefault: String?
    /** A list of settings on the acccount that indicate what features are available. */
    public var loginAccountSettings: [NameValue]?
    /** A list of user-level settings that indicate what user-specific features are available. */
    public var loginUserSettings: [NameValue]?
    /** The name associated with the account. */
    public var name: String?
    /** An optional descirption of the site that hosts the account. */
    public var siteDescription: String?
    /** The ID of the user to access. Generally this is the ID of the current authenticated user, but if the authenticated user is an Administrator on the account, `userId` can represent another user whom the Administrator is accessing.  */
    public var userId: String?
    /** The name of this user as defined by the account. */
    public var userName: String?

    public init(accountId: String? = nil, accountIdGuid: String? = nil, baseUrl: String? = nil, email: String? = nil, isDefault: String? = nil, loginAccountSettings: [NameValue]? = nil, loginUserSettings: [NameValue]? = nil, name: String? = nil, siteDescription: String? = nil, userId: String? = nil, userName: String? = nil) {
        self.accountId = accountId
        self.accountIdGuid = accountIdGuid
        self.baseUrl = baseUrl
        self.email = email
        self.isDefault = isDefault
        self.loginAccountSettings = loginAccountSettings
        self.loginUserSettings = loginUserSettings
        self.name = name
        self.siteDescription = siteDescription
        self.userId = userId
        self.userName = userName
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case accountId
        case accountIdGuid
        case baseUrl
        case email
        case isDefault
        case loginAccountSettings
        case loginUserSettings
        case name
        case siteDescription
        case userId
        case userName
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(accountId, forKey: .accountId)
        try container.encodeIfPresent(accountIdGuid, forKey: .accountIdGuid)
        try container.encodeIfPresent(baseUrl, forKey: .baseUrl)
        try container.encodeIfPresent(email, forKey: .email)
        try container.encodeIfPresent(isDefault, forKey: .isDefault)
        try container.encodeIfPresent(loginAccountSettings, forKey: .loginAccountSettings)
        try container.encodeIfPresent(loginUserSettings, forKey: .loginUserSettings)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(siteDescription, forKey: .siteDescription)
        try container.encodeIfPresent(userId, forKey: .userId)
        try container.encodeIfPresent(userName, forKey: .userName)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        accountId = try container.decodeIfPresent(String.self, forKey: .accountId)
        accountIdGuid = try container.decodeIfPresent(String.self, forKey: .accountIdGuid)
        baseUrl = try container.decodeIfPresent(String.self, forKey: .baseUrl)
        email = try container.decodeIfPresent(String.self, forKey: .email)
        isDefault = try container.decodeIfPresent(String.self, forKey: .isDefault)
        loginAccountSettings = try container.decodeIfPresent([NameValue].self, forKey: .loginAccountSettings)
        loginUserSettings = try container.decodeIfPresent([NameValue].self, forKey: .loginUserSettings)
        name = try container.decodeIfPresent(String.self, forKey: .name)
        siteDescription = try container.decodeIfPresent(String.self, forKey: .siteDescription)
        userId = try container.decodeIfPresent(String.self, forKey: .userId)
        userName = try container.decodeIfPresent(String.self, forKey: .userName)
    }
}

extension LoginAccount: Hashable {
    public static func == (lhs: LoginAccount, rhs: LoginAccount) -> Bool {
        lhs.accountId == rhs.accountId &&
            lhs.accountIdGuid == rhs.accountIdGuid &&
            lhs.baseUrl == rhs.baseUrl &&
            lhs.email == rhs.email &&
            lhs.isDefault == rhs.isDefault &&
            lhs.loginAccountSettings == rhs.loginAccountSettings &&
            lhs.loginUserSettings == rhs.loginUserSettings &&
            lhs.name == rhs.name &&
            lhs.siteDescription == rhs.siteDescription &&
            lhs.userId == rhs.userId &&
            lhs.userName == rhs.userName
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accountId?.hashValue)
        hasher.combine(accountIdGuid?.hashValue)
        hasher.combine(baseUrl?.hashValue)
        hasher.combine(email?.hashValue)
        hasher.combine(isDefault?.hashValue)
        hasher.combine(loginAccountSettings?.hashValue)
        hasher.combine(loginUserSettings?.hashValue)
        hasher.combine(name?.hashValue)
        hasher.combine(siteDescription?.hashValue)
        hasher.combine(userId?.hashValue)
        hasher.combine(userName?.hashValue)
    }
}
