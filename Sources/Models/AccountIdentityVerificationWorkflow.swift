//
// AccountIdentityVerificationWorkflow.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/** Specifies an Identity Verification workflow. */
public final class AccountIdentityVerificationWorkflow: Content {
    /** Text describing the purpose of the Identity Verification workflow. */
    public var defaultDescription: String?
    /** The name of the Identity Verification workflow. */
    public var defaultName: String?
    /**  */
    public var inputOptions: [AccountIdentityInputOption]?
    public var signatureProvider: AccountSignatureProvider?
    /** Workflow unique ID</br>This is the ID you must specify when setting ID Verification in an envelope using the `identityVerification` [core recipient parameter](https://developers.docusign.com/esign-rest-api/reference/Envelopes/EnvelopeRecipients#core-recipient-parameters) */
    public var workflowId: String?
    /** Reserved for DocuSign. */
    public var workflowResourceKey: String?

    public init(defaultDescription: String? = nil, defaultName: String? = nil, inputOptions: [AccountIdentityInputOption]? = nil, signatureProvider: AccountSignatureProvider? = nil, workflowId: String? = nil, workflowResourceKey: String? = nil) {
        self.defaultDescription = defaultDescription
        self.defaultName = defaultName
        self.inputOptions = inputOptions
        self.signatureProvider = signatureProvider
        self.workflowId = workflowId
        self.workflowResourceKey = workflowResourceKey
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case defaultDescription
        case defaultName
        case inputOptions
        case signatureProvider
        case workflowId
        case workflowResourceKey
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(defaultDescription, forKey: .defaultDescription)
        try container.encodeIfPresent(defaultName, forKey: .defaultName)
        try container.encodeIfPresent(inputOptions, forKey: .inputOptions)
        try container.encodeIfPresent(signatureProvider, forKey: .signatureProvider)
        try container.encodeIfPresent(workflowId, forKey: .workflowId)
        try container.encodeIfPresent(workflowResourceKey, forKey: .workflowResourceKey)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        defaultDescription = try container.decodeIfPresent(String.self, forKey: .defaultDescription)
        defaultName = try container.decodeIfPresent(String.self, forKey: .defaultName)
        inputOptions = try container.decodeIfPresent([AccountIdentityInputOption].self, forKey: .inputOptions)
        signatureProvider = try container.decodeIfPresent(AccountSignatureProvider.self, forKey: .signatureProvider)
        workflowId = try container.decodeIfPresent(String.self, forKey: .workflowId)
        workflowResourceKey = try container.decodeIfPresent(String.self, forKey: .workflowResourceKey)
    }
}

extension AccountIdentityVerificationWorkflow: Hashable {
    public static func == (lhs: AccountIdentityVerificationWorkflow, rhs: AccountIdentityVerificationWorkflow) -> Bool {
        lhs.defaultDescription == rhs.defaultDescription &&
            lhs.defaultName == rhs.defaultName &&
            lhs.inputOptions == rhs.inputOptions &&
            lhs.signatureProvider == rhs.signatureProvider &&
            lhs.workflowId == rhs.workflowId &&
            lhs.workflowResourceKey == rhs.workflowResourceKey
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(defaultDescription?.hashValue)
        hasher.combine(defaultName?.hashValue)
        hasher.combine(inputOptions?.hashValue)
        hasher.combine(signatureProvider?.hashValue)
        hasher.combine(workflowId?.hashValue)
        hasher.combine(workflowResourceKey?.hashValue)
    }
}
