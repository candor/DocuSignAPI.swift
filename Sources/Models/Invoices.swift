//
// Invoices.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/** Invoices */
public final class Invoices: Content {
    /** Reserved: TBD */
    public var amount: String?
    /** Reserved: TBD */
    public var balance: String?
    /** Reserved: TBD */
    public var dueDate: String?
    /** Reserved: TBD */
    public var invoiceId: String?
    /** Reserved: TBD */
    public var invoiceItems: [BillingInvoiceItem]?
    /** Reserved: TBD */
    public var invoiceNumber: String?
    /** Contains a URI for an endpoint that you can use to retrieve invoice information. */
    public var invoiceUri: String?
    /**  */
    public var nonTaxableAmount: String?
    /**  */
    public var pdfAvailable: String?
    /**  */
    public var taxableAmount: String?

    public init(amount: String? = nil, balance: String? = nil, dueDate: String? = nil, invoiceId: String? = nil, invoiceItems: [BillingInvoiceItem]? = nil, invoiceNumber: String? = nil, invoiceUri: String? = nil, nonTaxableAmount: String? = nil, pdfAvailable: String? = nil, taxableAmount: String? = nil) {
        self.amount = amount
        self.balance = balance
        self.dueDate = dueDate
        self.invoiceId = invoiceId
        self.invoiceItems = invoiceItems
        self.invoiceNumber = invoiceNumber
        self.invoiceUri = invoiceUri
        self.nonTaxableAmount = nonTaxableAmount
        self.pdfAvailable = pdfAvailable
        self.taxableAmount = taxableAmount
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case amount
        case balance
        case dueDate
        case invoiceId
        case invoiceItems
        case invoiceNumber
        case invoiceUri
        case nonTaxableAmount
        case pdfAvailable
        case taxableAmount
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(amount, forKey: .amount)
        try container.encodeIfPresent(balance, forKey: .balance)
        try container.encodeIfPresent(dueDate, forKey: .dueDate)
        try container.encodeIfPresent(invoiceId, forKey: .invoiceId)
        try container.encodeIfPresent(invoiceItems, forKey: .invoiceItems)
        try container.encodeIfPresent(invoiceNumber, forKey: .invoiceNumber)
        try container.encodeIfPresent(invoiceUri, forKey: .invoiceUri)
        try container.encodeIfPresent(nonTaxableAmount, forKey: .nonTaxableAmount)
        try container.encodeIfPresent(pdfAvailable, forKey: .pdfAvailable)
        try container.encodeIfPresent(taxableAmount, forKey: .taxableAmount)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        amount = try container.decodeIfPresent(String.self, forKey: .amount)
        balance = try container.decodeIfPresent(String.self, forKey: .balance)
        dueDate = try container.decodeIfPresent(String.self, forKey: .dueDate)
        invoiceId = try container.decodeIfPresent(String.self, forKey: .invoiceId)
        invoiceItems = try container.decodeIfPresent([BillingInvoiceItem].self, forKey: .invoiceItems)
        invoiceNumber = try container.decodeIfPresent(String.self, forKey: .invoiceNumber)
        invoiceUri = try container.decodeIfPresent(String.self, forKey: .invoiceUri)
        nonTaxableAmount = try container.decodeIfPresent(String.self, forKey: .nonTaxableAmount)
        pdfAvailable = try container.decodeIfPresent(String.self, forKey: .pdfAvailable)
        taxableAmount = try container.decodeIfPresent(String.self, forKey: .taxableAmount)
    }
}

extension Invoices: Hashable {
    public static func == (lhs: Invoices, rhs: Invoices) -> Bool {
        lhs.amount == rhs.amount &&
            lhs.balance == rhs.balance &&
            lhs.dueDate == rhs.dueDate &&
            lhs.invoiceId == rhs.invoiceId &&
            lhs.invoiceItems == rhs.invoiceItems &&
            lhs.invoiceNumber == rhs.invoiceNumber &&
            lhs.invoiceUri == rhs.invoiceUri &&
            lhs.nonTaxableAmount == rhs.nonTaxableAmount &&
            lhs.pdfAvailable == rhs.pdfAvailable &&
            lhs.taxableAmount == rhs.taxableAmount
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(amount?.hashValue)
        hasher.combine(balance?.hashValue)
        hasher.combine(dueDate?.hashValue)
        hasher.combine(invoiceId?.hashValue)
        hasher.combine(invoiceItems?.hashValue)
        hasher.combine(invoiceNumber?.hashValue)
        hasher.combine(invoiceUri?.hashValue)
        hasher.combine(nonTaxableAmount?.hashValue)
        hasher.combine(pdfAvailable?.hashValue)
        hasher.combine(taxableAmount?.hashValue)
    }
}
