//
// EnvelopeDocument.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/** This object contains details about the envelope document. */
public final class EnvelopeDocument: Content {
    /** If recipients were added by converting form fields into tabs, their ids appear here. Read only. */
    public var addedRecipientIds: [String]?
    /** If this document is an attachment to another document in the envelope, this is the id of the attachment tab it is associated with on the other document. */
    public var attachmentTabId: String?
    /** When **true**, marks all of the documents in the envelope as authoritative copies.  **Note**: You can override this value for a specific document. For example, you can set the `authoritativeCopy` property to **true** at the envelope level, but turn it off for a single document by setting the `authoritativeCopy` property for the document to **false**. */
    public var authoritativeCopy: String?
    public var authoritativeCopyMetadata: PropertyMetadata?
    /**  */
    public var availableDocumentTypes: [SignatureType]?
    /** When **true**, the document has editable form fields that are made available through a PDF format. */
    public var containsPdfFormFields: String?
    /** This string sets the display and behavior properties of the document during signing. The possible values are:  * `modal`<br>   The document is shown as a supplement action strip   and can be viewed, downloaded, or printed in a modal window.   This is the recommended value for supplemental documents.   * `download`<br>   The document is shown as a supplement action strip   and can be viewed, downloaded, or printed in a new browser window.   * `inline`<br>   The document is shown in the normal signing window.   This value is not used with supplemental documents,   but is the default value for all other documents.  */
    public var display: String?
    public var displayMetadata: PropertyMetadata?
    /** An object containing information about the custom fields on the document. */
    public var documentFields: [NameValue]?
    /** The id of the document that the tab is placed on. This value must refer to the id of an existing document. */
    public var documentId: String?
    /** The GUID of the document. */
    public var documentIdGuid: String?
    public var errorDetails: ErrorDetails?
    /** When set to **true**, the document is included in the combined document download (`documentsCombinedUri`).  The default value is **true**.  */
    public var includeInDownload: String?
    public var includeInDownloadMetadata: PropertyMetadata?
    /** The document's file name.   Example: `Q1-Report.docx` */
    public var name: String?
    public var nameMetadata: PropertyMetadata?
    /** (Optional) The order in which to sort the results.  Valid values are:    * `asc`: Ascending order. * `desc`: Descending order.  */
    public var order: String?
    /** An array of page objects that contain information about the pages in the document. */
    public var pages: [Page]?
    /** Sets how the signer interacts with the supplemental document. The possible values are:   * `no_interaction`<br>   No recipient action is required.   * `view`<br>   The recipient is required to view the document.   * `accept`<br>   The recipient is required to accept the document by selecting accept during signing, but is not required to view the document.   * `view_accept`<br>   The recipient is required to view and accept the document.     */
    public var signerMustAcknowledge: String?
    public var signerMustAcknowledgeMetadata: PropertyMetadata?
    /**  */
    public var sizeBytes: String?
    /** When set to **true**, the sender cannot change any attributes of the recipient. Used only when working with template recipients.  */
    public var templateLocked: String?
    /** When set to **true**, the sender may not remove the recipient. Used only when working with template recipients. */
    public var templateRequired: String?
    /**  */
    public var type: String?
    /** The URI for retrieving the document. */
    public var uri: String?

    public init(addedRecipientIds: [String]? = nil, attachmentTabId: String? = nil, authoritativeCopy: String? = nil, authoritativeCopyMetadata: PropertyMetadata? = nil, availableDocumentTypes: [SignatureType]? = nil, containsPdfFormFields: String? = nil, display: String? = nil, displayMetadata: PropertyMetadata? = nil, documentFields: [NameValue]? = nil, documentId: String? = nil, documentIdGuid: String? = nil, errorDetails: ErrorDetails? = nil, includeInDownload: String? = nil, includeInDownloadMetadata: PropertyMetadata? = nil, name: String? = nil, nameMetadata: PropertyMetadata? = nil, order: String? = nil, pages: [Page]? = nil, signerMustAcknowledge: String? = nil, signerMustAcknowledgeMetadata: PropertyMetadata? = nil, sizeBytes: String? = nil, templateLocked: String? = nil, templateRequired: String? = nil, type: String? = nil, uri: String? = nil) {
        self.addedRecipientIds = addedRecipientIds
        self.attachmentTabId = attachmentTabId
        self.authoritativeCopy = authoritativeCopy
        self.authoritativeCopyMetadata = authoritativeCopyMetadata
        self.availableDocumentTypes = availableDocumentTypes
        self.containsPdfFormFields = containsPdfFormFields
        self.display = display
        self.displayMetadata = displayMetadata
        self.documentFields = documentFields
        self.documentId = documentId
        self.documentIdGuid = documentIdGuid
        self.errorDetails = errorDetails
        self.includeInDownload = includeInDownload
        self.includeInDownloadMetadata = includeInDownloadMetadata
        self.name = name
        self.nameMetadata = nameMetadata
        self.order = order
        self.pages = pages
        self.signerMustAcknowledge = signerMustAcknowledge
        self.signerMustAcknowledgeMetadata = signerMustAcknowledgeMetadata
        self.sizeBytes = sizeBytes
        self.templateLocked = templateLocked
        self.templateRequired = templateRequired
        self.type = type
        self.uri = uri
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case addedRecipientIds
        case attachmentTabId
        case authoritativeCopy
        case authoritativeCopyMetadata
        case availableDocumentTypes
        case containsPdfFormFields
        case display
        case displayMetadata
        case documentFields
        case documentId
        case documentIdGuid
        case errorDetails
        case includeInDownload
        case includeInDownloadMetadata
        case name
        case nameMetadata
        case order
        case pages
        case signerMustAcknowledge
        case signerMustAcknowledgeMetadata
        case sizeBytes
        case templateLocked
        case templateRequired
        case type
        case uri
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(addedRecipientIds, forKey: .addedRecipientIds)
        try container.encodeIfPresent(attachmentTabId, forKey: .attachmentTabId)
        try container.encodeIfPresent(authoritativeCopy, forKey: .authoritativeCopy)
        try container.encodeIfPresent(authoritativeCopyMetadata, forKey: .authoritativeCopyMetadata)
        try container.encodeIfPresent(availableDocumentTypes, forKey: .availableDocumentTypes)
        try container.encodeIfPresent(containsPdfFormFields, forKey: .containsPdfFormFields)
        try container.encodeIfPresent(display, forKey: .display)
        try container.encodeIfPresent(displayMetadata, forKey: .displayMetadata)
        try container.encodeIfPresent(documentFields, forKey: .documentFields)
        try container.encodeIfPresent(documentId, forKey: .documentId)
        try container.encodeIfPresent(documentIdGuid, forKey: .documentIdGuid)
        try container.encodeIfPresent(errorDetails, forKey: .errorDetails)
        try container.encodeIfPresent(includeInDownload, forKey: .includeInDownload)
        try container.encodeIfPresent(includeInDownloadMetadata, forKey: .includeInDownloadMetadata)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(nameMetadata, forKey: .nameMetadata)
        try container.encodeIfPresent(order, forKey: .order)
        try container.encodeIfPresent(pages, forKey: .pages)
        try container.encodeIfPresent(signerMustAcknowledge, forKey: .signerMustAcknowledge)
        try container.encodeIfPresent(signerMustAcknowledgeMetadata, forKey: .signerMustAcknowledgeMetadata)
        try container.encodeIfPresent(sizeBytes, forKey: .sizeBytes)
        try container.encodeIfPresent(templateLocked, forKey: .templateLocked)
        try container.encodeIfPresent(templateRequired, forKey: .templateRequired)
        try container.encodeIfPresent(type, forKey: .type)
        try container.encodeIfPresent(uri, forKey: .uri)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        addedRecipientIds = try container.decodeIfPresent([String].self, forKey: .addedRecipientIds)
        attachmentTabId = try container.decodeIfPresent(String.self, forKey: .attachmentTabId)
        authoritativeCopy = try container.decodeIfPresent(String.self, forKey: .authoritativeCopy)
        authoritativeCopyMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .authoritativeCopyMetadata)
        availableDocumentTypes = try container.decodeIfPresent([SignatureType].self, forKey: .availableDocumentTypes)
        containsPdfFormFields = try container.decodeIfPresent(String.self, forKey: .containsPdfFormFields)
        display = try container.decodeIfPresent(String.self, forKey: .display)
        displayMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .displayMetadata)
        documentFields = try container.decodeIfPresent([NameValue].self, forKey: .documentFields)
        documentId = try container.decodeIfPresent(String.self, forKey: .documentId)
        documentIdGuid = try container.decodeIfPresent(String.self, forKey: .documentIdGuid)
        errorDetails = try container.decodeIfPresent(ErrorDetails.self, forKey: .errorDetails)
        includeInDownload = try container.decodeIfPresent(String.self, forKey: .includeInDownload)
        includeInDownloadMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .includeInDownloadMetadata)
        name = try container.decodeIfPresent(String.self, forKey: .name)
        nameMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .nameMetadata)
        order = try container.decodeIfPresent(String.self, forKey: .order)
        pages = try container.decodeIfPresent([Page].self, forKey: .pages)
        signerMustAcknowledge = try container.decodeIfPresent(String.self, forKey: .signerMustAcknowledge)
        signerMustAcknowledgeMetadata = try container.decodeIfPresent(PropertyMetadata.self, forKey: .signerMustAcknowledgeMetadata)
        sizeBytes = try container.decodeIfPresent(String.self, forKey: .sizeBytes)
        templateLocked = try container.decodeIfPresent(String.self, forKey: .templateLocked)
        templateRequired = try container.decodeIfPresent(String.self, forKey: .templateRequired)
        type = try container.decodeIfPresent(String.self, forKey: .type)
        uri = try container.decodeIfPresent(String.self, forKey: .uri)
    }
}

extension EnvelopeDocument: Hashable {
    public static func == (lhs: EnvelopeDocument, rhs: EnvelopeDocument) -> Bool {
        lhs.addedRecipientIds == rhs.addedRecipientIds &&
            lhs.attachmentTabId == rhs.attachmentTabId &&
            lhs.authoritativeCopy == rhs.authoritativeCopy &&
            lhs.authoritativeCopyMetadata == rhs.authoritativeCopyMetadata &&
            lhs.availableDocumentTypes == rhs.availableDocumentTypes &&
            lhs.containsPdfFormFields == rhs.containsPdfFormFields &&
            lhs.display == rhs.display &&
            lhs.displayMetadata == rhs.displayMetadata &&
            lhs.documentFields == rhs.documentFields &&
            lhs.documentId == rhs.documentId &&
            lhs.documentIdGuid == rhs.documentIdGuid &&
            lhs.errorDetails == rhs.errorDetails &&
            lhs.includeInDownload == rhs.includeInDownload &&
            lhs.includeInDownloadMetadata == rhs.includeInDownloadMetadata &&
            lhs.name == rhs.name &&
            lhs.nameMetadata == rhs.nameMetadata &&
            lhs.order == rhs.order &&
            lhs.pages == rhs.pages &&
            lhs.signerMustAcknowledge == rhs.signerMustAcknowledge &&
            lhs.signerMustAcknowledgeMetadata == rhs.signerMustAcknowledgeMetadata &&
            lhs.sizeBytes == rhs.sizeBytes &&
            lhs.templateLocked == rhs.templateLocked &&
            lhs.templateRequired == rhs.templateRequired &&
            lhs.type == rhs.type &&
            lhs.uri == rhs.uri
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(addedRecipientIds?.hashValue)
        hasher.combine(attachmentTabId?.hashValue)
        hasher.combine(authoritativeCopy?.hashValue)
        hasher.combine(authoritativeCopyMetadata?.hashValue)
        hasher.combine(availableDocumentTypes?.hashValue)
        hasher.combine(containsPdfFormFields?.hashValue)
        hasher.combine(display?.hashValue)
        hasher.combine(displayMetadata?.hashValue)
        hasher.combine(documentFields?.hashValue)
        hasher.combine(documentId?.hashValue)
        hasher.combine(documentIdGuid?.hashValue)
        hasher.combine(errorDetails?.hashValue)
        hasher.combine(includeInDownload?.hashValue)
        hasher.combine(includeInDownloadMetadata?.hashValue)
        hasher.combine(name?.hashValue)
        hasher.combine(nameMetadata?.hashValue)
        hasher.combine(order?.hashValue)
        hasher.combine(pages?.hashValue)
        hasher.combine(signerMustAcknowledge?.hashValue)
        hasher.combine(signerMustAcknowledgeMetadata?.hashValue)
        hasher.combine(sizeBytes?.hashValue)
        hasher.combine(templateLocked?.hashValue)
        hasher.combine(templateRequired?.hashValue)
        hasher.combine(type?.hashValue)
        hasher.combine(uri?.hashValue)
    }
}
