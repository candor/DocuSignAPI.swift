//
// EnvelopeFormData.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/** This object contains the data that recipients have entered into the form fields associated with an envelope. */
public final class EnvelopeFormData: Content {
    /** The subject line of the email message that is sent to all recipients.  For information about adding merge field information to the email subject, see [Template Email Subject Merge Fields](https://developers.docusign.com/esign-rest-api/reference/Templates/Templates/create#template-email-subject-merge-fields).  */
    public var emailSubject: String?
    /** The id of the envelope. */
    public var envelopeId: String?
    /** An array of form data objects. */
    public var formData: [FormDataItem]?
    /** An array of form data objects that are associated with specific recipients. */
    public var recipientFormData: [RecipientFormData]?
    /** The UTC DateTime when the envelope was sent. Read only. */
    public var sentDateTime: String?
    /** Indicates the envelope status. Valid values are:  * `completed`: The recipients have finished working with the envelope: the documents are signed and all required tabs are filled in. * `created`: The envelope is created as a draft. It can be modified and sent later. * `declined`: The envelope has been declined by the recipients. * `delivered`: The envelope has been delivered to the recipients. * `sent`: The envelope will be sent to the recipients after the envelope is created. * `signed`: The envelope has been signed by the recipients. * `voided`: The envelope is no longer valid and recipients cannot access or sign the envelope.  */
    public var status: String?

    public init(emailSubject: String? = nil, envelopeId: String? = nil, formData: [FormDataItem]? = nil, recipientFormData: [RecipientFormData]? = nil, sentDateTime: String? = nil, status: String? = nil) {
        self.emailSubject = emailSubject
        self.envelopeId = envelopeId
        self.formData = formData
        self.recipientFormData = recipientFormData
        self.sentDateTime = sentDateTime
        self.status = status
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case emailSubject
        case envelopeId
        case formData
        case recipientFormData
        case sentDateTime
        case status
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(emailSubject, forKey: .emailSubject)
        try container.encodeIfPresent(envelopeId, forKey: .envelopeId)
        try container.encodeIfPresent(formData, forKey: .formData)
        try container.encodeIfPresent(recipientFormData, forKey: .recipientFormData)
        try container.encodeIfPresent(sentDateTime, forKey: .sentDateTime)
        try container.encodeIfPresent(status, forKey: .status)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        emailSubject = try container.decodeIfPresent(String.self, forKey: .emailSubject)
        envelopeId = try container.decodeIfPresent(String.self, forKey: .envelopeId)
        formData = try container.decodeIfPresent([FormDataItem].self, forKey: .formData)
        recipientFormData = try container.decodeIfPresent([RecipientFormData].self, forKey: .recipientFormData)
        sentDateTime = try container.decodeIfPresent(String.self, forKey: .sentDateTime)
        status = try container.decodeIfPresent(String.self, forKey: .status)
    }
}

extension EnvelopeFormData: Hashable {
    public static func == (lhs: EnvelopeFormData, rhs: EnvelopeFormData) -> Bool {
        lhs.emailSubject == rhs.emailSubject &&
            lhs.envelopeId == rhs.envelopeId &&
            lhs.formData == rhs.formData &&
            lhs.recipientFormData == rhs.recipientFormData &&
            lhs.sentDateTime == rhs.sentDateTime &&
            lhs.status == rhs.status
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(emailSubject?.hashValue)
        hasher.combine(envelopeId?.hashValue)
        hasher.combine(formData?.hashValue)
        hasher.combine(recipientFormData?.hashValue)
        hasher.combine(sentDateTime?.hashValue)
        hasher.combine(status?.hashValue)
    }
}
