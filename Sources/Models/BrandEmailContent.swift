//
// BrandEmailContent.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/** Deprecated. */
public final class BrandEmailContent: Content {
    /** Deprecated. */
    public var content: String?
    /** Deprecated. */
    public var emailContentType: String?
    /** Deprecated. */
    public var emailToLink: String?
    /** Deprecated. */
    public var linkText: String?

    public init(content: String? = nil, emailContentType: String? = nil, emailToLink: String? = nil, linkText: String? = nil) {
        self.content = content
        self.emailContentType = emailContentType
        self.emailToLink = emailToLink
        self.linkText = linkText
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case content
        case emailContentType
        case emailToLink
        case linkText
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(content, forKey: .content)
        try container.encodeIfPresent(emailContentType, forKey: .emailContentType)
        try container.encodeIfPresent(emailToLink, forKey: .emailToLink)
        try container.encodeIfPresent(linkText, forKey: .linkText)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        content = try container.decodeIfPresent(String.self, forKey: .content)
        emailContentType = try container.decodeIfPresent(String.self, forKey: .emailContentType)
        emailToLink = try container.decodeIfPresent(String.self, forKey: .emailToLink)
        linkText = try container.decodeIfPresent(String.self, forKey: .linkText)
    }
}

extension BrandEmailContent: Hashable {
    public static func == (lhs: BrandEmailContent, rhs: BrandEmailContent) -> Bool {
        lhs.content == rhs.content &&
            lhs.emailContentType == rhs.emailContentType &&
            lhs.emailToLink == rhs.emailToLink &&
            lhs.linkText == rhs.linkText
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(content?.hashValue)
        hasher.combine(emailContentType?.hashValue)
        hasher.combine(emailToLink?.hashValue)
        hasher.combine(linkText?.hashValue)
    }
}
