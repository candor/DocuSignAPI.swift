//
// WorkspaceUser.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/** This object represents the workspace user. This property is only returned in response to user specific GET call.  */
public final class WorkspaceUser: Content {
    /** The account ID associated with the workspace user. */
    public var accountId: String?
    /** The name on the account. */
    public var accountName: String?
    /** The UTC DateTime when the user joined the workspace. */
    public var activeSince: String?
    /** The UTC DateTime when the workspace user was created. */
    public var created: String?
    /** The id of the user who created this workspace user. */
    public var createdById: String?
    /** The workspace user's email address. */
    public var email: String?
    public var errorDetails: ErrorDetails?
    /** The text of the workspace invitation email message sent to the user. */
    public var invitationEmailBlurb: String?
    /** The subject line of the workspace invitation email message sent to the user. */
    public var invitationEmailSubject: String?
    /** The UTC DateTime that the workspace user was last modified. */
    public var lastModified: String?
    /** The id of the user who last modified the workspace user. */
    public var lastModifiedById: String?
    /** Filters the results by user status. You can specify a comma-separated list of the following statuses:  * ActivationRequired  * ActivationSent  * Active * Closed  * Disabled */
    public var status: String?
    /**  */
    public var type: String?
    /** The id of the workspace user. */
    public var userId: String?
    /** The name of workspace user. */
    public var userName: String?
    /** The id of the workspace. */
    public var workspaceId: String?
    /** The URL for accessing the workspace user. */
    public var workspaceUserBaseUrl: String?
    /** The id of the workspace user. */
    public var workspaceUserId: String?
    /** The URI for accessing the workspace user. */
    public var workspaceUserUri: String?

    public init(accountId: String? = nil, accountName: String? = nil, activeSince: String? = nil, created: String? = nil, createdById: String? = nil, email: String? = nil, errorDetails: ErrorDetails? = nil, invitationEmailBlurb: String? = nil, invitationEmailSubject: String? = nil, lastModified: String? = nil, lastModifiedById: String? = nil, status: String? = nil, type: String? = nil, userId: String? = nil, userName: String? = nil, workspaceId: String? = nil, workspaceUserBaseUrl: String? = nil, workspaceUserId: String? = nil, workspaceUserUri: String? = nil) {
        self.accountId = accountId
        self.accountName = accountName
        self.activeSince = activeSince
        self.created = created
        self.createdById = createdById
        self.email = email
        self.errorDetails = errorDetails
        self.invitationEmailBlurb = invitationEmailBlurb
        self.invitationEmailSubject = invitationEmailSubject
        self.lastModified = lastModified
        self.lastModifiedById = lastModifiedById
        self.status = status
        self.type = type
        self.userId = userId
        self.userName = userName
        self.workspaceId = workspaceId
        self.workspaceUserBaseUrl = workspaceUserBaseUrl
        self.workspaceUserId = workspaceUserId
        self.workspaceUserUri = workspaceUserUri
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case accountId
        case accountName
        case activeSince
        case created
        case createdById
        case email
        case errorDetails
        case invitationEmailBlurb
        case invitationEmailSubject
        case lastModified
        case lastModifiedById
        case status
        case type
        case userId
        case userName
        case workspaceId
        case workspaceUserBaseUrl
        case workspaceUserId
        case workspaceUserUri
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(accountId, forKey: .accountId)
        try container.encodeIfPresent(accountName, forKey: .accountName)
        try container.encodeIfPresent(activeSince, forKey: .activeSince)
        try container.encodeIfPresent(created, forKey: .created)
        try container.encodeIfPresent(createdById, forKey: .createdById)
        try container.encodeIfPresent(email, forKey: .email)
        try container.encodeIfPresent(errorDetails, forKey: .errorDetails)
        try container.encodeIfPresent(invitationEmailBlurb, forKey: .invitationEmailBlurb)
        try container.encodeIfPresent(invitationEmailSubject, forKey: .invitationEmailSubject)
        try container.encodeIfPresent(lastModified, forKey: .lastModified)
        try container.encodeIfPresent(lastModifiedById, forKey: .lastModifiedById)
        try container.encodeIfPresent(status, forKey: .status)
        try container.encodeIfPresent(type, forKey: .type)
        try container.encodeIfPresent(userId, forKey: .userId)
        try container.encodeIfPresent(userName, forKey: .userName)
        try container.encodeIfPresent(workspaceId, forKey: .workspaceId)
        try container.encodeIfPresent(workspaceUserBaseUrl, forKey: .workspaceUserBaseUrl)
        try container.encodeIfPresent(workspaceUserId, forKey: .workspaceUserId)
        try container.encodeIfPresent(workspaceUserUri, forKey: .workspaceUserUri)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        accountId = try container.decodeIfPresent(String.self, forKey: .accountId)
        accountName = try container.decodeIfPresent(String.self, forKey: .accountName)
        activeSince = try container.decodeIfPresent(String.self, forKey: .activeSince)
        created = try container.decodeIfPresent(String.self, forKey: .created)
        createdById = try container.decodeIfPresent(String.self, forKey: .createdById)
        email = try container.decodeIfPresent(String.self, forKey: .email)
        errorDetails = try container.decodeIfPresent(ErrorDetails.self, forKey: .errorDetails)
        invitationEmailBlurb = try container.decodeIfPresent(String.self, forKey: .invitationEmailBlurb)
        invitationEmailSubject = try container.decodeIfPresent(String.self, forKey: .invitationEmailSubject)
        lastModified = try container.decodeIfPresent(String.self, forKey: .lastModified)
        lastModifiedById = try container.decodeIfPresent(String.self, forKey: .lastModifiedById)
        status = try container.decodeIfPresent(String.self, forKey: .status)
        type = try container.decodeIfPresent(String.self, forKey: .type)
        userId = try container.decodeIfPresent(String.self, forKey: .userId)
        userName = try container.decodeIfPresent(String.self, forKey: .userName)
        workspaceId = try container.decodeIfPresent(String.self, forKey: .workspaceId)
        workspaceUserBaseUrl = try container.decodeIfPresent(String.self, forKey: .workspaceUserBaseUrl)
        workspaceUserId = try container.decodeIfPresent(String.self, forKey: .workspaceUserId)
        workspaceUserUri = try container.decodeIfPresent(String.self, forKey: .workspaceUserUri)
    }
}

extension WorkspaceUser: Hashable {
    public static func == (lhs: WorkspaceUser, rhs: WorkspaceUser) -> Bool {
        lhs.accountId == rhs.accountId &&
            lhs.accountName == rhs.accountName &&
            lhs.activeSince == rhs.activeSince &&
            lhs.created == rhs.created &&
            lhs.createdById == rhs.createdById &&
            lhs.email == rhs.email &&
            lhs.errorDetails == rhs.errorDetails &&
            lhs.invitationEmailBlurb == rhs.invitationEmailBlurb &&
            lhs.invitationEmailSubject == rhs.invitationEmailSubject &&
            lhs.lastModified == rhs.lastModified &&
            lhs.lastModifiedById == rhs.lastModifiedById &&
            lhs.status == rhs.status &&
            lhs.type == rhs.type &&
            lhs.userId == rhs.userId &&
            lhs.userName == rhs.userName &&
            lhs.workspaceId == rhs.workspaceId &&
            lhs.workspaceUserBaseUrl == rhs.workspaceUserBaseUrl &&
            lhs.workspaceUserId == rhs.workspaceUserId &&
            lhs.workspaceUserUri == rhs.workspaceUserUri
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accountId?.hashValue)
        hasher.combine(accountName?.hashValue)
        hasher.combine(activeSince?.hashValue)
        hasher.combine(created?.hashValue)
        hasher.combine(createdById?.hashValue)
        hasher.combine(email?.hashValue)
        hasher.combine(errorDetails?.hashValue)
        hasher.combine(invitationEmailBlurb?.hashValue)
        hasher.combine(invitationEmailSubject?.hashValue)
        hasher.combine(lastModified?.hashValue)
        hasher.combine(lastModifiedById?.hashValue)
        hasher.combine(status?.hashValue)
        hasher.combine(type?.hashValue)
        hasher.combine(userId?.hashValue)
        hasher.combine(userName?.hashValue)
        hasher.combine(workspaceId?.hashValue)
        hasher.combine(workspaceUserBaseUrl?.hashValue)
        hasher.combine(workspaceUserId?.hashValue)
        hasher.combine(workspaceUserUri?.hashValue)
    }
}
