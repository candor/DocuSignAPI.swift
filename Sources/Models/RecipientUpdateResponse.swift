//
// RecipientUpdateResponse.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/** The recipient details that are returned after you update the recipient. */
public final class RecipientUpdateResponse: Content {
    /** When you use the query parameter `combine_same_order_recipients` on the PUT Recipients call, the `recipientUpdateResponse` returns this property. When set to **true**, it indicates that the recipient has been combined or merged with a matching recipient. Recipient matching occurs as part of template matching, and is based on Recipient Role and Routing Order. */
    public var combined: String?
    public var errorDetails: ErrorDetails?
    /** A local reference that senders use to map recipients to other objects, such as specific document tabs. Within an envelope, each `recipientId` must be unique, but there is no uniqueness requirement across envelopes. For example, many envelopes assign the first recipient a `recipientId` of `1`. */
    public var recipientId: String?
    /** The globally-unique identifier (GUID) for a specific recipient on a specific envelope. If the same recipient is associated with multiple envelopes, they will have a different GUID for each one. Read only. */
    public var recipientIdGuid: String?
    public var tabs: EnvelopeRecipientTabs?

    public init(combined: String? = nil, errorDetails: ErrorDetails? = nil, recipientId: String? = nil, recipientIdGuid: String? = nil, tabs: EnvelopeRecipientTabs? = nil) {
        self.combined = combined
        self.errorDetails = errorDetails
        self.recipientId = recipientId
        self.recipientIdGuid = recipientIdGuid
        self.tabs = tabs
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case combined
        case errorDetails
        case recipientId
        case recipientIdGuid
        case tabs
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(combined, forKey: .combined)
        try container.encodeIfPresent(errorDetails, forKey: .errorDetails)
        try container.encodeIfPresent(recipientId, forKey: .recipientId)
        try container.encodeIfPresent(recipientIdGuid, forKey: .recipientIdGuid)
        try container.encodeIfPresent(tabs, forKey: .tabs)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        combined = try container.decodeIfPresent(String.self, forKey: .combined)
        errorDetails = try container.decodeIfPresent(ErrorDetails.self, forKey: .errorDetails)
        recipientId = try container.decodeIfPresent(String.self, forKey: .recipientId)
        recipientIdGuid = try container.decodeIfPresent(String.self, forKey: .recipientIdGuid)
        tabs = try container.decodeIfPresent(EnvelopeRecipientTabs.self, forKey: .tabs)
    }
}

extension RecipientUpdateResponse: Hashable {
    public static func == (lhs: RecipientUpdateResponse, rhs: RecipientUpdateResponse) -> Bool {
        lhs.combined == rhs.combined &&
            lhs.errorDetails == rhs.errorDetails &&
            lhs.recipientId == rhs.recipientId &&
            lhs.recipientIdGuid == rhs.recipientIdGuid &&
            lhs.tabs == rhs.tabs
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(combined?.hashValue)
        hasher.combine(errorDetails?.hashValue)
        hasher.combine(recipientId?.hashValue)
        hasher.combine(recipientIdGuid?.hashValue)
        hasher.combine(tabs?.hashValue)
    }
}
