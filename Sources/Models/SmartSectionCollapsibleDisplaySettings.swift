//
// SmartSectionCollapsibleDisplaySettings.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/**  */
public final class SmartSectionCollapsibleDisplaySettings: Content {
    /**  */
    public var arrowClosed: String?
    /**  */
    public var arrowColor: String?
    /**  */
    public var arrowLocation: String?
    /**  */
    public var arrowOpen: String?
    /**  */
    public var arrowSize: String?
    /**  */
    public var arrowStyle: String?
    /**  */
    public var containerStyle: String?
    /**  */
    public var labelStyle: String?
    /**  */
    public var onlyArrowIsClickable: Bool?
    /**  */
    public var outerLabelAndArrowStyle: String?

    public init(arrowClosed: String? = nil, arrowColor: String? = nil, arrowLocation: String? = nil, arrowOpen: String? = nil, arrowSize: String? = nil, arrowStyle: String? = nil, containerStyle: String? = nil, labelStyle: String? = nil, onlyArrowIsClickable: Bool? = nil, outerLabelAndArrowStyle: String? = nil) {
        self.arrowClosed = arrowClosed
        self.arrowColor = arrowColor
        self.arrowLocation = arrowLocation
        self.arrowOpen = arrowOpen
        self.arrowSize = arrowSize
        self.arrowStyle = arrowStyle
        self.containerStyle = containerStyle
        self.labelStyle = labelStyle
        self.onlyArrowIsClickable = onlyArrowIsClickable
        self.outerLabelAndArrowStyle = outerLabelAndArrowStyle
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case arrowClosed
        case arrowColor
        case arrowLocation
        case arrowOpen
        case arrowSize
        case arrowStyle
        case containerStyle
        case labelStyle
        case onlyArrowIsClickable
        case outerLabelAndArrowStyle
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(arrowClosed, forKey: .arrowClosed)
        try container.encodeIfPresent(arrowColor, forKey: .arrowColor)
        try container.encodeIfPresent(arrowLocation, forKey: .arrowLocation)
        try container.encodeIfPresent(arrowOpen, forKey: .arrowOpen)
        try container.encodeIfPresent(arrowSize, forKey: .arrowSize)
        try container.encodeIfPresent(arrowStyle, forKey: .arrowStyle)
        try container.encodeIfPresent(containerStyle, forKey: .containerStyle)
        try container.encodeIfPresent(labelStyle, forKey: .labelStyle)
        try container.encodeIfPresent(onlyArrowIsClickable, forKey: .onlyArrowIsClickable)
        try container.encodeIfPresent(outerLabelAndArrowStyle, forKey: .outerLabelAndArrowStyle)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        arrowClosed = try container.decodeIfPresent(String.self, forKey: .arrowClosed)
        arrowColor = try container.decodeIfPresent(String.self, forKey: .arrowColor)
        arrowLocation = try container.decodeIfPresent(String.self, forKey: .arrowLocation)
        arrowOpen = try container.decodeIfPresent(String.self, forKey: .arrowOpen)
        arrowSize = try container.decodeIfPresent(String.self, forKey: .arrowSize)
        arrowStyle = try container.decodeIfPresent(String.self, forKey: .arrowStyle)
        containerStyle = try container.decodeIfPresent(String.self, forKey: .containerStyle)
        labelStyle = try container.decodeIfPresent(String.self, forKey: .labelStyle)
        onlyArrowIsClickable = try container.decodeIfPresent(Bool.self, forKey: .onlyArrowIsClickable)
        outerLabelAndArrowStyle = try container.decodeIfPresent(String.self, forKey: .outerLabelAndArrowStyle)
    }
}

extension SmartSectionCollapsibleDisplaySettings: Hashable {
    public static func == (lhs: SmartSectionCollapsibleDisplaySettings, rhs: SmartSectionCollapsibleDisplaySettings) -> Bool {
        lhs.arrowClosed == rhs.arrowClosed &&
            lhs.arrowColor == rhs.arrowColor &&
            lhs.arrowLocation == rhs.arrowLocation &&
            lhs.arrowOpen == rhs.arrowOpen &&
            lhs.arrowSize == rhs.arrowSize &&
            lhs.arrowStyle == rhs.arrowStyle &&
            lhs.containerStyle == rhs.containerStyle &&
            lhs.labelStyle == rhs.labelStyle &&
            lhs.onlyArrowIsClickable == rhs.onlyArrowIsClickable &&
            lhs.outerLabelAndArrowStyle == rhs.outerLabelAndArrowStyle
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(arrowClosed?.hashValue)
        hasher.combine(arrowColor?.hashValue)
        hasher.combine(arrowLocation?.hashValue)
        hasher.combine(arrowOpen?.hashValue)
        hasher.combine(arrowSize?.hashValue)
        hasher.combine(arrowStyle?.hashValue)
        hasher.combine(containerStyle?.hashValue)
        hasher.combine(labelStyle?.hashValue)
        hasher.combine(onlyArrowIsClickable?.hashValue)
        hasher.combine(outerLabelAndArrowStyle?.hashValue)
    }
}
