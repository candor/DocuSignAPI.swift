//
// BillingPlans.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

/** Billing plans */
public final class BillingPlans: Content {
    public var billingAddress: AccountAddress?
    /** When set to **true**, the credit card address information is the same as that returned as the billing address. If false, then the billing address is considered a billing contact address, and the credit card address can be different. */
    public var billingAddressIsCreditCardAddress: String?
    public var billingPlan: AccountBillingPlan?
    public var creditCardInformation: CreditCardInformation?
    public var directDebitProcessorInformation: DirectDebitProcessorInformation?
    public var downgradePlanInformation: DowngradePlanUpdateResponse?
    /** The payment method used for the billing plan. Valid values are:  - `NotSupported` - `CreditCard` - `PurchaseOrder` - `Premium` - `Freemium` - `FreeTrial` - `AppStore` - `DigitalExternal` - `DirectDebit` */
    public var paymentMethod: String?
    public var paymentProcessorInformation: PaymentProcessorInformation?
    public var referralInformation: ReferralInformation?
    /** A list of billing plans that the current billing plan can be rolled into. */
    public var successorPlans: [BillingPlan]?

    public init(billingAddress: AccountAddress? = nil, billingAddressIsCreditCardAddress: String? = nil, billingPlan: AccountBillingPlan? = nil, creditCardInformation: CreditCardInformation? = nil, directDebitProcessorInformation: DirectDebitProcessorInformation? = nil, downgradePlanInformation: DowngradePlanUpdateResponse? = nil, paymentMethod: String? = nil, paymentProcessorInformation: PaymentProcessorInformation? = nil, referralInformation: ReferralInformation? = nil, successorPlans: [BillingPlan]? = nil) {
        self.billingAddress = billingAddress
        self.billingAddressIsCreditCardAddress = billingAddressIsCreditCardAddress
        self.billingPlan = billingPlan
        self.creditCardInformation = creditCardInformation
        self.directDebitProcessorInformation = directDebitProcessorInformation
        self.downgradePlanInformation = downgradePlanInformation
        self.paymentMethod = paymentMethod
        self.paymentProcessorInformation = paymentProcessorInformation
        self.referralInformation = referralInformation
        self.successorPlans = successorPlans
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case billingAddress
        case billingAddressIsCreditCardAddress
        case billingPlan
        case creditCardInformation
        case directDebitProcessorInformation
        case downgradePlanInformation
        case paymentMethod
        case paymentProcessorInformation
        case referralInformation
        case successorPlans
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(billingAddress, forKey: .billingAddress)
        try container.encodeIfPresent(billingAddressIsCreditCardAddress, forKey: .billingAddressIsCreditCardAddress)
        try container.encodeIfPresent(billingPlan, forKey: .billingPlan)
        try container.encodeIfPresent(creditCardInformation, forKey: .creditCardInformation)
        try container.encodeIfPresent(directDebitProcessorInformation, forKey: .directDebitProcessorInformation)
        try container.encodeIfPresent(downgradePlanInformation, forKey: .downgradePlanInformation)
        try container.encodeIfPresent(paymentMethod, forKey: .paymentMethod)
        try container.encodeIfPresent(paymentProcessorInformation, forKey: .paymentProcessorInformation)
        try container.encodeIfPresent(referralInformation, forKey: .referralInformation)
        try container.encodeIfPresent(successorPlans, forKey: .successorPlans)
    }

    // Decodable protocol methods

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        billingAddress = try container.decodeIfPresent(AccountAddress.self, forKey: .billingAddress)
        billingAddressIsCreditCardAddress = try container.decodeIfPresent(String.self, forKey: .billingAddressIsCreditCardAddress)
        billingPlan = try container.decodeIfPresent(AccountBillingPlan.self, forKey: .billingPlan)
        creditCardInformation = try container.decodeIfPresent(CreditCardInformation.self, forKey: .creditCardInformation)
        directDebitProcessorInformation = try container.decodeIfPresent(DirectDebitProcessorInformation.self, forKey: .directDebitProcessorInformation)
        downgradePlanInformation = try container.decodeIfPresent(DowngradePlanUpdateResponse.self, forKey: .downgradePlanInformation)
        paymentMethod = try container.decodeIfPresent(String.self, forKey: .paymentMethod)
        paymentProcessorInformation = try container.decodeIfPresent(PaymentProcessorInformation.self, forKey: .paymentProcessorInformation)
        referralInformation = try container.decodeIfPresent(ReferralInformation.self, forKey: .referralInformation)
        successorPlans = try container.decodeIfPresent([BillingPlan].self, forKey: .successorPlans)
    }
}

extension BillingPlans: Hashable {
    public static func == (lhs: BillingPlans, rhs: BillingPlans) -> Bool {
        lhs.billingAddress == rhs.billingAddress &&
            lhs.billingAddressIsCreditCardAddress == rhs.billingAddressIsCreditCardAddress &&
            lhs.billingPlan == rhs.billingPlan &&
            lhs.creditCardInformation == rhs.creditCardInformation &&
            lhs.directDebitProcessorInformation == rhs.directDebitProcessorInformation &&
            lhs.downgradePlanInformation == rhs.downgradePlanInformation &&
            lhs.paymentMethod == rhs.paymentMethod &&
            lhs.paymentProcessorInformation == rhs.paymentProcessorInformation &&
            lhs.referralInformation == rhs.referralInformation &&
            lhs.successorPlans == rhs.successorPlans
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(billingAddress?.hashValue)
        hasher.combine(billingAddressIsCreditCardAddress?.hashValue)
        hasher.combine(billingPlan?.hashValue)
        hasher.combine(creditCardInformation?.hashValue)
        hasher.combine(directDebitProcessorInformation?.hashValue)
        hasher.combine(downgradePlanInformation?.hashValue)
        hasher.combine(paymentMethod?.hashValue)
        hasher.combine(paymentProcessorInformation?.hashValue)
        hasher.combine(referralInformation?.hashValue)
        hasher.combine(successorPlans?.hashValue)
    }
}
