//
// AccountWatermarksAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

open class AccountWatermarksAPI {
    public enum WatermarkGetWatermark {
        case http200(value: Watermark?, raw: ClientResponse)
        case http400(value: ErrorDetails?, raw: ClientResponse)
        case http0(value: Watermark?, raw: ClientResponse)
    }

    /**
     Get watermark information.

     GET /v2.1/accounts/{accountId}/watermark

     - parameter accountId: (path) The external account number (int) or account ID GUID.
     - returns: `EventLoopFuture` of `WatermarkGetWatermark`
     */
    open class func watermarkGetWatermark(accountId: String, headers: HTTPHeaders = DocuSignAPI.customHeaders, beforeSend: (inout ClientRequest) throws -> Void = { _ in }) -> EventLoopFuture<WatermarkGetWatermark> {
        var path = "/v2.1/accounts/{accountId}/watermark"
        let accountIdPreEscape = String(describing: accountId)
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{accountId}", with: accountIdPostEscape, options: .literal, range: nil)
        let URLString = DocuSignAPI.basePath + path

        guard let apiClient = Configuration.apiClient else {
            fatalError("Configuration.apiClient is not set.")
        }

        return apiClient.send(.GET, headers: headers, to: URI(string: URLString)) { request in
            try Configuration.apiWrapper(&request)

            try beforeSend(&request)
        }.flatMapThrowing { response -> WatermarkGetWatermark in
            switch response.status.code {
            case 200:
                return .http200(value: try? response.content.decode(Watermark.self), raw: response)
            case 400:
                return .http400(value: try? response.content.decode(ErrorDetails.self), raw: response)
            default:
                return .http0(value: try? response.content.decode(Watermark.self), raw: response)
            }
        }
    }

    public enum WatermarkPreviewPutWatermarkPreview {
        case http200(value: Watermark?, raw: ClientResponse)
        case http400(value: ErrorDetails?, raw: ClientResponse)
        case http0(value: Watermark?, raw: ClientResponse)
    }

    /**
     Get watermark preview.

     PUT /v2.1/accounts/{accountId}/watermark/preview

     - parameter accountId: (path) The external account number (int) or account ID GUID.
     - parameter watermark: (body) When set to **true**, the account has the watermark feature enabled, and the envelope is not complete, then the watermark for the account is added to the PDF documents. This option can remove the watermark.  (optional)
     - returns: `EventLoopFuture` of `WatermarkPreviewPutWatermarkPreview`
     */
    open class func watermarkPreviewPutWatermarkPreview(accountId: String, watermark: Watermark? = nil, headers: HTTPHeaders = DocuSignAPI.customHeaders, beforeSend: (inout ClientRequest) throws -> Void = { _ in }) -> EventLoopFuture<WatermarkPreviewPutWatermarkPreview> {
        var path = "/v2.1/accounts/{accountId}/watermark/preview"
        let accountIdPreEscape = String(describing: accountId)
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{accountId}", with: accountIdPostEscape, options: .literal, range: nil)
        let URLString = DocuSignAPI.basePath + path

        guard let apiClient = Configuration.apiClient else {
            fatalError("Configuration.apiClient is not set.")
        }

        return apiClient.send(.PUT, headers: headers, to: URI(string: URLString)) { request in
            try Configuration.apiWrapper(&request)

            if let body = watermark {
                try request.content.encode(body)
            }

            try beforeSend(&request)
        }.flatMapThrowing { response -> WatermarkPreviewPutWatermarkPreview in
            switch response.status.code {
            case 200:
                return .http200(value: try? response.content.decode(Watermark.self), raw: response)
            case 400:
                return .http400(value: try? response.content.decode(ErrorDetails.self), raw: response)
            default:
                return .http0(value: try? response.content.decode(Watermark.self), raw: response)
            }
        }
    }

    public enum WatermarkPutWatermark {
        case http200(value: Watermark?, raw: ClientResponse)
        case http400(value: ErrorDetails?, raw: ClientResponse)
        case http0(value: Watermark?, raw: ClientResponse)
    }

    /**
     Update watermark information.

     PUT /v2.1/accounts/{accountId}/watermark

     - parameter accountId: (path) The external account number (int) or account ID GUID.
     - parameter watermark: (body) When set to **true**, the account has the watermark feature enabled, and the envelope is not complete, then the watermark for the account is added to the PDF documents. This option can remove the watermark.  (optional)
     - returns: `EventLoopFuture` of `WatermarkPutWatermark`
     */
    open class func watermarkPutWatermark(accountId: String, watermark: Watermark? = nil, headers: HTTPHeaders = DocuSignAPI.customHeaders, beforeSend: (inout ClientRequest) throws -> Void = { _ in }) -> EventLoopFuture<WatermarkPutWatermark> {
        var path = "/v2.1/accounts/{accountId}/watermark"
        let accountIdPreEscape = String(describing: accountId)
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{accountId}", with: accountIdPostEscape, options: .literal, range: nil)
        let URLString = DocuSignAPI.basePath + path

        guard let apiClient = Configuration.apiClient else {
            fatalError("Configuration.apiClient is not set.")
        }

        return apiClient.send(.PUT, headers: headers, to: URI(string: URLString)) { request in
            try Configuration.apiWrapper(&request)

            if let body = watermark {
                try request.content.encode(body)
            }

            try beforeSend(&request)
        }.flatMapThrowing { response -> WatermarkPutWatermark in
            switch response.status.code {
            case 200:
                return .http200(value: try? response.content.decode(Watermark.self), raw: response)
            case 400:
                return .http400(value: try? response.content.decode(ErrorDetails.self), raw: response)
            default:
                return .http0(value: try? response.content.decode(Watermark.self), raw: response)
            }
        }
    }
}
