//
// TemplatesAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import Vapor

open class TemplatesAPI {
    public enum NotificationGetTemplatesTemplateIdNotification {
        case http200(value: Notification?, raw: ClientResponse)
        case http400(value: ErrorDetails?, raw: ClientResponse)
        case http0(value: Notification?, raw: ClientResponse)
    }

    /**
     Gets template notification information.

     GET /v2.1/accounts/{accountId}/templates/{templateId}/notification

     Retrieves the envelope notification, reminders and expirations, information for an existing template.

     - parameter accountId: (path) The external account number (int) or account ID GUID.
     - parameter templateId: (path) The id of the template.
     - returns: `EventLoopFuture` of `NotificationGetTemplatesTemplateIdNotification`
     */
    open class func notificationGetTemplatesTemplateIdNotification(accountId: String, templateId: String, headers: HTTPHeaders = DocuSignAPI.customHeaders, beforeSend: (inout ClientRequest) throws -> Void = { _ in }) -> EventLoopFuture<NotificationGetTemplatesTemplateIdNotification> {
        var path = "/v2.1/accounts/{accountId}/templates/{templateId}/notification"
        let accountIdPreEscape = String(describing: accountId)
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{accountId}", with: accountIdPostEscape, options: .literal, range: nil)
        let templateIdPreEscape = String(describing: templateId)
        let templateIdPostEscape = templateIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{templateId}", with: templateIdPostEscape, options: .literal, range: nil)
        let URLString = DocuSignAPI.basePath + path

        guard let apiClient = Configuration.apiClient else {
            fatalError("Configuration.apiClient is not set.")
        }

        return apiClient.send(.GET, headers: headers, to: URI(string: URLString)) { request in
            try Configuration.apiWrapper(&request)

            try beforeSend(&request)
        }.flatMapThrowing { response -> NotificationGetTemplatesTemplateIdNotification in
            switch response.status.code {
            case 200:
                return .http200(value: try? response.content.decode(Notification.self), raw: response)
            case 400:
                return .http400(value: try? response.content.decode(ErrorDetails.self), raw: response)
            default:
                return .http0(value: try? response.content.decode(Notification.self), raw: response)
            }
        }
    }

    public enum NotificationPutTemplatesTemplateIdNotification {
        case http200(value: Notification?, raw: ClientResponse)
        case http400(value: ErrorDetails?, raw: ClientResponse)
        case http0(value: Notification?, raw: ClientResponse)
    }

    /**
     Updates the notification  structure for an existing template.

     PUT /v2.1/accounts/{accountId}/templates/{templateId}/notification

     Updates the notification structure for an existing template. Use this endpoint to set reminder and expiration notifications.

     - parameter accountId: (path) The external account number (int) or account ID GUID.
     - parameter templateId: (path) The id of the template.
     - parameter templateNotificationRequest: (body)  (optional)
     - returns: `EventLoopFuture` of `NotificationPutTemplatesTemplateIdNotification`
     */
    open class func notificationPutTemplatesTemplateIdNotification(accountId: String, templateId: String, templateNotificationRequest: TemplateNotificationRequest? = nil, headers: HTTPHeaders = DocuSignAPI.customHeaders, beforeSend: (inout ClientRequest) throws -> Void = { _ in }) -> EventLoopFuture<NotificationPutTemplatesTemplateIdNotification> {
        var path = "/v2.1/accounts/{accountId}/templates/{templateId}/notification"
        let accountIdPreEscape = String(describing: accountId)
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{accountId}", with: accountIdPostEscape, options: .literal, range: nil)
        let templateIdPreEscape = String(describing: templateId)
        let templateIdPostEscape = templateIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{templateId}", with: templateIdPostEscape, options: .literal, range: nil)
        let URLString = DocuSignAPI.basePath + path

        guard let apiClient = Configuration.apiClient else {
            fatalError("Configuration.apiClient is not set.")
        }

        return apiClient.send(.PUT, headers: headers, to: URI(string: URLString)) { request in
            try Configuration.apiWrapper(&request)

            if let body = templateNotificationRequest {
                try request.content.encode(body)
            }

            try beforeSend(&request)
        }.flatMapThrowing { response -> NotificationPutTemplatesTemplateIdNotification in
            switch response.status.code {
            case 200:
                return .http200(value: try? response.content.decode(Notification.self), raw: response)
            case 400:
                return .http400(value: try? response.content.decode(ErrorDetails.self), raw: response)
            default:
                return .http0(value: try? response.content.decode(Notification.self), raw: response)
            }
        }
    }

    public enum PagesDeleteTemplatePage {
        case http200(value: Void?, raw: ClientResponse)
        case http400(value: ErrorDetails?, raw: ClientResponse)
        case http0(value: Void?, raw: ClientResponse)
    }

    /**
     Deletes a page from a document in an template.

     DELETE /v2.1/accounts/{accountId}/templates/{templateId}/documents/{documentId}/pages/{pageNumber}

     Deletes a page from a document in a template based on the page number.

     - parameter accountId: (path) The external account number (int) or account ID GUID.
     - parameter documentId: (path) The `documentId` is set by the API client. It is an integer that falls between `1` and 2,147,483,647. The value is encoded as a string without commas. The values `1`, `2`, `3`, and so on are typically used to identify the first few documents in an envelope. Tab definitions include a `documentId` property that specifies the document on which to place the tab.
     - parameter pageNumber: (path) The page number being accessed.
     - parameter templateId: (path) The id of the template.
     - parameter pageRequest: (body)  (optional)
     - returns: `EventLoopFuture` of `PagesDeleteTemplatePage`
     */
    open class func pagesDeleteTemplatePage(accountId: String, documentId: String, pageNumber: String, templateId: String, pageRequest: PageRequest? = nil, headers: HTTPHeaders = DocuSignAPI.customHeaders, beforeSend: (inout ClientRequest) throws -> Void = { _ in }) -> EventLoopFuture<PagesDeleteTemplatePage> {
        var path = "/v2.1/accounts/{accountId}/templates/{templateId}/documents/{documentId}/pages/{pageNumber}"
        let accountIdPreEscape = String(describing: accountId)
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{accountId}", with: accountIdPostEscape, options: .literal, range: nil)
        let documentIdPreEscape = String(describing: documentId)
        let documentIdPostEscape = documentIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{documentId}", with: documentIdPostEscape, options: .literal, range: nil)
        let pageNumberPreEscape = String(describing: pageNumber)
        let pageNumberPostEscape = pageNumberPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{pageNumber}", with: pageNumberPostEscape, options: .literal, range: nil)
        let templateIdPreEscape = String(describing: templateId)
        let templateIdPostEscape = templateIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{templateId}", with: templateIdPostEscape, options: .literal, range: nil)
        let URLString = DocuSignAPI.basePath + path

        guard let apiClient = Configuration.apiClient else {
            fatalError("Configuration.apiClient is not set.")
        }

        return apiClient.send(.DELETE, headers: headers, to: URI(string: URLString)) { request in
            try Configuration.apiWrapper(&request)

            if let body = pageRequest {
                try request.content.encode(body)
            }

            try beforeSend(&request)
        }.flatMapThrowing { response -> PagesDeleteTemplatePage in
            switch response.status.code {
            case 200:
                return .http200(value: (), raw: response)
            case 400:
                return .http400(value: try? response.content.decode(ErrorDetails.self), raw: response)
            default:
                return .http0(value: (), raw: response)
            }
        }
    }

    public enum PagesGetTemplatePageImage {
        case http200(value: Data?, raw: ClientResponse)
        case http400(value: ErrorDetails?, raw: ClientResponse)
        case http0(value: Data?, raw: ClientResponse)
    }

    /**
     Gets a page image from a template for display.

     GET /v2.1/accounts/{accountId}/templates/{templateId}/documents/{documentId}/pages/{pageNumber}/page_image

     Retrieves a page image for display from the specified template.

     - parameter accountId: (path) The external account number (int) or account ID GUID.
     - parameter documentId: (path) The `documentId` is set by the API client. It is an integer that falls between `1` and 2,147,483,647. The value is encoded as a string without commas. The values `1`, `2`, `3`, and so on are typically used to identify the first few documents in an envelope. Tab definitions include a `documentId` property that specifies the document on which to place the tab.
     - parameter pageNumber: (path) The page number being accessed.
     - parameter templateId: (path) The id of the template.
     - parameter dpi: (query) The number of dots per inch (DPI) for the resulting images. Valid values are 1-310 DPI. The default value is 94. (optional)
     - parameter maxHeight: (query) Sets the maximum height of the returned images in pixels. (optional)
     - parameter maxWidth: (query) Sets the maximum width of the returned images in pixels. (optional)
     - parameter showChanges: (query)  (optional)
     - returns: `EventLoopFuture` of `PagesGetTemplatePageImage`
     */
    open class func pagesGetTemplatePageImage(accountId: String, documentId: String, pageNumber: String, templateId: String, dpi: String? = nil, maxHeight: String? = nil, maxWidth: String? = nil, showChanges: String? = nil, headers: HTTPHeaders = DocuSignAPI.customHeaders, beforeSend: (inout ClientRequest) throws -> Void = { _ in }) -> EventLoopFuture<PagesGetTemplatePageImage> {
        var path = "/v2.1/accounts/{accountId}/templates/{templateId}/documents/{documentId}/pages/{pageNumber}/page_image"
        let accountIdPreEscape = String(describing: accountId)
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{accountId}", with: accountIdPostEscape, options: .literal, range: nil)
        let documentIdPreEscape = String(describing: documentId)
        let documentIdPostEscape = documentIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{documentId}", with: documentIdPostEscape, options: .literal, range: nil)
        let pageNumberPreEscape = String(describing: pageNumber)
        let pageNumberPostEscape = pageNumberPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{pageNumber}", with: pageNumberPostEscape, options: .literal, range: nil)
        let templateIdPreEscape = String(describing: templateId)
        let templateIdPostEscape = templateIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{templateId}", with: templateIdPostEscape, options: .literal, range: nil)
        let URLString = DocuSignAPI.basePath + path

        guard let apiClient = Configuration.apiClient else {
            fatalError("Configuration.apiClient is not set.")
        }

        return apiClient.send(.GET, headers: headers, to: URI(string: URLString)) { request in
            try Configuration.apiWrapper(&request)

            struct QueryParams: Content {
                var dpi: String?
                var maxHeight: String?
                var maxWidth: String?
                var showChanges: String?
            }
            try request.query.encode(QueryParams(dpi: dpi, maxHeight: maxHeight, maxWidth: maxWidth, showChanges: showChanges))

            try beforeSend(&request)
        }.flatMapThrowing { response -> PagesGetTemplatePageImage in
            switch response.status.code {
            case 200:
                return .http200(value: Data(buffer: response.body ?? ByteBuffer()), raw: response)
            case 400:
                return .http400(value: try? response.content.decode(ErrorDetails.self), raw: response)
            default:
                return .http0(value: try? response.content.decode(Data.self), raw: response)
            }
        }
    }

    public enum PagesGetTemplatePageImages {
        case http200(value: PageImages?, raw: ClientResponse)
        case http400(value: ErrorDetails?, raw: ClientResponse)
        case http0(value: PageImages?, raw: ClientResponse)
    }

    /**
     Returns document page image(s) based on input.

     GET /v2.1/accounts/{accountId}/templates/{templateId}/documents/{documentId}/pages

     Returns images of the pages in a template document for display based on the parameters that you specify.

     - parameter accountId: (path) (Required) The external account number (int) or account ID GUID.
     - parameter documentId: (path) (Required) The ID of the document.
     - parameter templateId: (path) (Required) The ID of the template.
     - parameter count: (query) The maximum number of results to return. (optional)
     - parameter dpi: (query) The number of dots per inch (DPI) for the resulting images. Valid values are 1-310 DPI. The default value is 94. (optional)
     - parameter maxHeight: (query) Sets the maximum height of the returned images in pixels. (optional)
     - parameter maxWidth: (query) Sets the maximum width of the returned images in pixels. (optional)
     - parameter nocache: (query) If **true**, using cache is disabled and image information is retrieved from a database. **True** is the default value.  (optional)
     - parameter showChanges: (query) If **true**, changes display in the user interface. (optional)
     - parameter startPosition: (query) The position within the total result set from which to start returning values. The value **thumbnail** may be used to return the page image. (optional)
     - returns: `EventLoopFuture` of `PagesGetTemplatePageImages`
     */
    open class func pagesGetTemplatePageImages(accountId: String, documentId: String, templateId: String, count: String? = nil, dpi: String? = nil, maxHeight: String? = nil, maxWidth: String? = nil, nocache: String? = nil, showChanges: String? = nil, startPosition: String? = nil, headers: HTTPHeaders = DocuSignAPI.customHeaders, beforeSend: (inout ClientRequest) throws -> Void = { _ in }) -> EventLoopFuture<PagesGetTemplatePageImages> {
        var path = "/v2.1/accounts/{accountId}/templates/{templateId}/documents/{documentId}/pages"
        let accountIdPreEscape = String(describing: accountId)
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{accountId}", with: accountIdPostEscape, options: .literal, range: nil)
        let documentIdPreEscape = String(describing: documentId)
        let documentIdPostEscape = documentIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{documentId}", with: documentIdPostEscape, options: .literal, range: nil)
        let templateIdPreEscape = String(describing: templateId)
        let templateIdPostEscape = templateIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{templateId}", with: templateIdPostEscape, options: .literal, range: nil)
        let URLString = DocuSignAPI.basePath + path

        guard let apiClient = Configuration.apiClient else {
            fatalError("Configuration.apiClient is not set.")
        }

        return apiClient.send(.GET, headers: headers, to: URI(string: URLString)) { request in
            try Configuration.apiWrapper(&request)

            struct QueryParams: Content {
                var count: String?
                var dpi: String?
                var maxHeight: String?
                var maxWidth: String?
                var nocache: String?
                var showChanges: String?
                var startPosition: String?
            }
            try request.query.encode(QueryParams(count: count, dpi: dpi, maxHeight: maxHeight, maxWidth: maxWidth, nocache: nocache, showChanges: showChanges, startPosition: startPosition))

            try beforeSend(&request)
        }.flatMapThrowing { response -> PagesGetTemplatePageImages in
            switch response.status.code {
            case 200:
                return .http200(value: try? response.content.decode(PageImages.self), raw: response)
            case 400:
                return .http400(value: try? response.content.decode(ErrorDetails.self), raw: response)
            default:
                return .http0(value: try? response.content.decode(PageImages.self), raw: response)
            }
        }
    }

    public enum PagesPutTemplatePageImage {
        case http200(value: Void?, raw: ClientResponse)
        case http400(value: ErrorDetails?, raw: ClientResponse)
        case http0(value: Void?, raw: ClientResponse)
    }

    /**
     Rotates page image from a template for display.

     PUT /v2.1/accounts/{accountId}/templates/{templateId}/documents/{documentId}/pages/{pageNumber}/page_image

     Rotates page image from a template for display. The page image can be rotated to the left or right.

     - parameter accountId: (path) The external account number (int) or account ID GUID.
     - parameter documentId: (path) The `documentId` is set by the API client. It is an integer that falls between `1` and 2,147,483,647. The value is encoded as a string without commas. The values `1`, `2`, `3`, and so on are typically used to identify the first few documents in an envelope. Tab definitions include a `documentId` property that specifies the document on which to place the tab.
     - parameter pageNumber: (path) The page number being accessed.
     - parameter templateId: (path) The id of the template.
     - parameter pageRequest: (body)  (optional)
     - returns: `EventLoopFuture` of `PagesPutTemplatePageImage`
     */
    open class func pagesPutTemplatePageImage(accountId: String, documentId: String, pageNumber: String, templateId: String, pageRequest: PageRequest? = nil, headers: HTTPHeaders = DocuSignAPI.customHeaders, beforeSend: (inout ClientRequest) throws -> Void = { _ in }) -> EventLoopFuture<PagesPutTemplatePageImage> {
        var path = "/v2.1/accounts/{accountId}/templates/{templateId}/documents/{documentId}/pages/{pageNumber}/page_image"
        let accountIdPreEscape = String(describing: accountId)
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{accountId}", with: accountIdPostEscape, options: .literal, range: nil)
        let documentIdPreEscape = String(describing: documentId)
        let documentIdPostEscape = documentIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{documentId}", with: documentIdPostEscape, options: .literal, range: nil)
        let pageNumberPreEscape = String(describing: pageNumber)
        let pageNumberPostEscape = pageNumberPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{pageNumber}", with: pageNumberPostEscape, options: .literal, range: nil)
        let templateIdPreEscape = String(describing: templateId)
        let templateIdPostEscape = templateIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{templateId}", with: templateIdPostEscape, options: .literal, range: nil)
        let URLString = DocuSignAPI.basePath + path

        guard let apiClient = Configuration.apiClient else {
            fatalError("Configuration.apiClient is not set.")
        }

        return apiClient.send(.PUT, headers: headers, to: URI(string: URLString)) { request in
            try Configuration.apiWrapper(&request)

            if let body = pageRequest {
                try request.content.encode(body)
            }

            try beforeSend(&request)
        }.flatMapThrowing { response -> PagesPutTemplatePageImage in
            switch response.status.code {
            case 200:
                return .http200(value: (), raw: response)
            case 400:
                return .http400(value: try? response.content.decode(ErrorDetails.self), raw: response)
            default:
                return .http0(value: (), raw: response)
            }
        }
    }

    public enum TemplatesDeleteTemplatePart {
        case http200(value: GroupInformation?, raw: ClientResponse)
        case http400(value: ErrorDetails?, raw: ClientResponse)
        case http0(value: GroupInformation?, raw: ClientResponse)
    }

    /**
     Removes a member group's sharing permissions for a template.

     DELETE /v2.1/accounts/{accountId}/templates/{templateId}/{templatePart}

     Removes a member group's sharing permissions for a specified template.

     - parameter accountId: (path) The external account number (int) or account ID GUID.
     - parameter templateId: (path) The id of the template.
     - parameter templatePart: (path) Currently, the only defined part is **groups**.
     - parameter groupInformation: (body)  (optional)
     - returns: `EventLoopFuture` of `TemplatesDeleteTemplatePart`
     */
    open class func templatesDeleteTemplatePart(accountId: String, templateId: String, templatePart: String, groupInformation: GroupInformation? = nil, headers: HTTPHeaders = DocuSignAPI.customHeaders, beforeSend: (inout ClientRequest) throws -> Void = { _ in }) -> EventLoopFuture<TemplatesDeleteTemplatePart> {
        var path = "/v2.1/accounts/{accountId}/templates/{templateId}/{templatePart}"
        let accountIdPreEscape = String(describing: accountId)
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{accountId}", with: accountIdPostEscape, options: .literal, range: nil)
        let templateIdPreEscape = String(describing: templateId)
        let templateIdPostEscape = templateIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{templateId}", with: templateIdPostEscape, options: .literal, range: nil)
        let templatePartPreEscape = String(describing: templatePart)
        let templatePartPostEscape = templatePartPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{templatePart}", with: templatePartPostEscape, options: .literal, range: nil)
        let URLString = DocuSignAPI.basePath + path

        guard let apiClient = Configuration.apiClient else {
            fatalError("Configuration.apiClient is not set.")
        }

        return apiClient.send(.DELETE, headers: headers, to: URI(string: URLString)) { request in
            try Configuration.apiWrapper(&request)

            if let body = groupInformation {
                try request.content.encode(body)
            }

            try beforeSend(&request)
        }.flatMapThrowing { response -> TemplatesDeleteTemplatePart in
            switch response.status.code {
            case 200:
                return .http200(value: try? response.content.decode(GroupInformation.self), raw: response)
            case 400:
                return .http400(value: try? response.content.decode(ErrorDetails.self), raw: response)
            default:
                return .http0(value: try? response.content.decode(GroupInformation.self), raw: response)
            }
        }
    }

    public enum TemplatesGetTemplate {
        case http200(value: EnvelopeTemplate?, raw: ClientResponse)
        case http400(value: ErrorDetails?, raw: ClientResponse)
        case http0(value: EnvelopeTemplate?, raw: ClientResponse)
    }

    /**
     Gets a specific template associated with a specified account.

     GET /v2.1/accounts/{accountId}/templates/{templateId}

     Retrieves the definition of the specified template.

     - parameter accountId: (path) The external account number (int) or account ID GUID.
     - parameter templateId: (path) The id of the template.
     - parameter include: (query) A comma-separated list of additional template attributes to include in the response. Valid values are:  - `powerforms`: Includes information about PowerForms. - `tabs`: Includes information about tabs. - `documents`: Includes information about documents. - `favorite_template_status`: : Includes the template `favoritedByMe` property in the response. **Note**: You can mark a template as a favorite only in eSignature v2.1. (optional)
     - returns: `EventLoopFuture` of `TemplatesGetTemplate`
     */
    open class func templatesGetTemplate(accountId: String, templateId: String, include: String? = nil, headers: HTTPHeaders = DocuSignAPI.customHeaders, beforeSend: (inout ClientRequest) throws -> Void = { _ in }) -> EventLoopFuture<TemplatesGetTemplate> {
        var path = "/v2.1/accounts/{accountId}/templates/{templateId}"
        let accountIdPreEscape = String(describing: accountId)
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{accountId}", with: accountIdPostEscape, options: .literal, range: nil)
        let templateIdPreEscape = String(describing: templateId)
        let templateIdPostEscape = templateIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{templateId}", with: templateIdPostEscape, options: .literal, range: nil)
        let URLString = DocuSignAPI.basePath + path

        guard let apiClient = Configuration.apiClient else {
            fatalError("Configuration.apiClient is not set.")
        }

        return apiClient.send(.GET, headers: headers, to: URI(string: URLString)) { request in
            try Configuration.apiWrapper(&request)

            struct QueryParams: Content {
                var include: String?
            }
            try request.query.encode(QueryParams(include: include))

            try beforeSend(&request)
        }.flatMapThrowing { response -> TemplatesGetTemplate in
            switch response.status.code {
            case 200:
                return .http200(value: try? response.content.decode(EnvelopeTemplate.self), raw: response)
            case 400:
                return .http400(value: try? response.content.decode(ErrorDetails.self), raw: response)
            default:
                return .http0(value: try? response.content.decode(EnvelopeTemplate.self), raw: response)
            }
        }
    }

    public enum TemplatesGetTemplates {
        case http200(value: EnvelopeTemplateResults?, raw: ClientResponse)
        case http400(value: ErrorDetails?, raw: ClientResponse)
        case http0(value: EnvelopeTemplateResults?, raw: ClientResponse)
    }

    /**
     Gets template definitions.

     GET /v2.1/accounts/{accountId}/templates

     Retrieves the list of templates for the specified account. The request can be limited to a specific folder.

     - parameter accountId: (path) The external account number (int) or account ID GUID.
     - parameter count: (query) The number of records to return in the cache. (optional)
     - parameter createdFromDate: (query) Lists templates created on or after this date. (optional)
     - parameter createdToDate: (query) Lists templates modified before this date. (optional)
     - parameter folderIds: (query) A comma-separated list of folder id GUIDs. (optional)
     - parameter folderTypes: (query) The type of folder to return templates for. Possible values are:  - `templates`: Templates in the **My Templates** folder.   Templates in the **Shared Templates**  and **All Template** folders (if the request id from and Admin) are excluded. - `templates_root`: Templates in the root level of the **My Templates** folder, but not in an actual folder. Note that the **My Templates** folder is not a real folder. - `recylebin`: Templates that have been deleted.  (optional)
     - parameter fromDate: (query) Start of the search date range. Only returns templates created on or after this date/time. If no value is specified, there is no limit on the earliest date created. (optional)
     - parameter include: (query) A comma-separated list of additional template attributes to include in the response. Valid values are:  - `powerforms`: Includes details about the PowerForms associated with the templates. - `documents`: Includes information about template documents. - `folders`: Includes information about the folder that holds the template. - `favorite_template_status`: Includes the template `favoritedByMe` property. **Note**: You can mark a template as a favorite only in eSignature v2.1. - `advanced_templates`: Includes information about advanced templates. - `recipients`: Includes information about template recipients. - `custom_fields`: Includes information about template custom fields. - `notifications`: Includes information about the notification settings for templates. (optional)
     - parameter isDownload: (query) When set to **true**, downloads the templates listed in `template_ids` as a collection of JSON definitions in a single zip file.  The `Content-Disposition` header is set in the response. The value of the header provides the filename of the file.  The default is **false**.  **Note**: This parameter only works when you specify a list of templates in the `template_ids` parameter. (optional)
     - parameter modifiedFromDate: (query) Lists templates modified on or after this date. (optional)
     - parameter modifiedToDate: (query) Lists templates modified before this date. (optional)
     - parameter order: (query) Specifies the sort order of the search results. Valid values are:  - `asc`: Ascending (A to Z) - `desc`: Descending (Z to A) (optional)
     - parameter orderBy: (query) Specifies how the search results are listed. Valid values are:  - `name`: template name - `modified`: date/time template was last modified - `used`: date/time the template was last used. (optional)
     - parameter searchFields: (query) A comma-separated list of additional template properties to search.   - `sender`: Include sender name and email in the search. - `recipients`: Include recipient names and emails in the search. - `envelope`: Not used in template searches.  (optional)
     - parameter searchText: (query) The search text to use to search the names of templates. (optional)
     - parameter sharedByMe: (query) If **true**, the response only includes templates shared by the user. If false, the response only returns template not shared by the user. If not specified, the response is not affected. (optional)
     - parameter startPosition: (query) The starting zero-based index position for the first template to show in the response. This value must be greater than or equal to `0` (zero). (optional)
     - parameter templateIds: (query) A comma-separated list of template ids to download. This value is valid only when `is_download` is **true**. (optional)
     - parameter toDate: (query) The end of a search date range in UTC DateTime format. When you use this parameter, only templates created up to this date and time are returned.  **Note**: If this property is null, the value defaults to the current date. (optional)
     - parameter usedFromDate: (query) Start of the search date range. Only returns templates used or edited on or after this date/time. If no value is specified, there is no limit on the earliest date used. (optional)
     - parameter usedToDate: (query) End of the search date range. Only returns templates used or edited up to this date/time. If no value is provided, this defaults to the current date. (optional)
     - parameter userFilter: (query) Filters the templates in the response. Valid values are:   - `owned_by_me`: Results include only templates owned by the user. - `shared_with_me`: Results include only templates owned by the user.   - `all`:  Results include all templates owned or shared with the user. (optional)
     - parameter userId: (query) The id of the user. (optional)
     - returns: `EventLoopFuture` of `TemplatesGetTemplates`
     */
    open class func templatesGetTemplates(accountId: String, count: String? = nil, createdFromDate: String? = nil, createdToDate: String? = nil, folderIds: String? = nil, folderTypes: String? = nil, fromDate: String? = nil, include: String? = nil, isDownload: String? = nil, modifiedFromDate: String? = nil, modifiedToDate: String? = nil, order: String? = nil, orderBy: String? = nil, searchFields: String? = nil, searchText: String? = nil, sharedByMe: String? = nil, startPosition: String? = nil, templateIds: String? = nil, toDate: String? = nil, usedFromDate: String? = nil, usedToDate: String? = nil, userFilter: String? = nil, userId: String? = nil, headers: HTTPHeaders = DocuSignAPI.customHeaders, beforeSend: (inout ClientRequest) throws -> Void = { _ in }) -> EventLoopFuture<TemplatesGetTemplates> {
        var path = "/v2.1/accounts/{accountId}/templates"
        let accountIdPreEscape = String(describing: accountId)
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{accountId}", with: accountIdPostEscape, options: .literal, range: nil)
        let URLString = DocuSignAPI.basePath + path

        guard let apiClient = Configuration.apiClient else {
            fatalError("Configuration.apiClient is not set.")
        }

        return apiClient.send(.GET, headers: headers, to: URI(string: URLString)) { request in
            try Configuration.apiWrapper(&request)

            struct QueryParams: Content {
                var count: String?
                var createdFromDate: String?
                var createdToDate: String?
                var folderIds: String?
                var folderTypes: String?
                var fromDate: String?
                var include: String?
                var isDownload: String?
                var modifiedFromDate: String?
                var modifiedToDate: String?
                var order: String?
                var orderBy: String?
                var searchFields: String?
                var searchText: String?
                var sharedByMe: String?
                var startPosition: String?
                var templateIds: String?
                var toDate: String?
                var usedFromDate: String?
                var usedToDate: String?
                var userFilter: String?
                var userId: String?
            }
            try request.query.encode(QueryParams(count: count, createdFromDate: createdFromDate, createdToDate: createdToDate, folderIds: folderIds, folderTypes: folderTypes, fromDate: fromDate, include: include, isDownload: isDownload, modifiedFromDate: modifiedFromDate, modifiedToDate: modifiedToDate, order: order, orderBy: orderBy, searchFields: searchFields, searchText: searchText, sharedByMe: sharedByMe, startPosition: startPosition, templateIds: templateIds, toDate: toDate, usedFromDate: usedFromDate, usedToDate: usedToDate, userFilter: userFilter, userId: userId))

            try beforeSend(&request)
        }.flatMapThrowing { response -> TemplatesGetTemplates in
            switch response.status.code {
            case 200:
                return .http200(value: try? response.content.decode(EnvelopeTemplateResults.self), raw: response)
            case 400:
                return .http400(value: try? response.content.decode(ErrorDetails.self), raw: response)
            default:
                return .http0(value: try? response.content.decode(EnvelopeTemplateResults.self), raw: response)
            }
        }
    }

    public enum TemplatesPostTemplates {
        case http201(value: TemplateSummary?, raw: ClientResponse)
        case http400(value: ErrorDetails?, raw: ClientResponse)
        case http0(value: TemplateSummary?, raw: ClientResponse)
    }

    /**
     Creates one or more templates.

     POST /v2.1/accounts/{accountId}/templates

     Creates one or more template definitions, using a multipart request for each template.  Templates help streamline the sending process when you frequently send the same or similar documents, or send different documents to the same group of people.  When you create a template, you define placeholder roles. Rather than specifying a person, you specify a role that regularly participates in a transaction that uses the template. Then, when you create or send an envelope based on the template, you assign actual recipients to the template roles. The recipients automatically inherit all of the workflow that is defined for that role in the template, such as the tabs and routing information.  For code examples and more information, see [REST API Templates](https://developers.docusign.com/esign-rest-api/guides/features/templates#sending-from-a-template).  ## Template Email Subject Merge Fields  Placeholder roles have associated merge fields that personalize the email notification that DocuSign sends. For example, the template automatically personalizes the email message by adding placeholders for the recipient's name and email address within the email subject line, based on the recipient's role. When the sender adds the name and email information for the recipient and sends the envelope, the recipient information is automatically merged into the appropriate fields in the email subject line.  Both the sender and the recipients will see the information in the email subject line for any emails associated with the template. This provides an easy way for senders to organize their envelope emails without having to open an envelope to find out who the recipient is.  **Warning: If merging the recipient information into the subject line causes the subject line to exceed 100 characters, then any characters over the 100 character limit are not included in the subject line. For cases where you expect the recipient name or email to be long, you should consider placing the merge field at the start of the email subject.**  To insert a recipient's name into the subject line, add the following text in the `emailSubject` property when you create the template:  `[[<roleName>_UserName]]`  Example:  `\"emailSubject\":\"[[Signer 1_UserName]], Please sign this NDA\",`  To add a recipient's email address in the subject line, add the following text in the `emailSubject` property when you create the template or send an envelope from the template:  `[[<roleName>_Email]]`  Example:  `\"emailSubject\":\"[[Signer 1_Email]], Please sign this NDA\",`  In these examples, the role name specified in the template  is “Signer 1”.  When the envelope is sent, the placeholder will be dynamically substituted with the recipient's name or email.  ## Creating multiple templates  To create multiple templates, you provide a zip file of JSON files. You can also use the Templates::ListTemplates method with the `is_download` query parameter to download a zip file containing your existing templates and use that as a guide. The API supports both .zip and .gzip file formats as input.  You also need to set the following headers:  - `Content-Length` - `Content-Type` - `Content-Disposition`  Example:   `Content-Length: 71068`  `Content-Type: application/zip`  `Content-Disposition: file; filename=\"DocuSignTemplates_Nov_25_2019_20_40_21.zip\"; fileExtension=.zip`

     - parameter accountId: (path) (Required) The external account number (int) or account ID GUID.
     - parameter envelopeTemplate: (body)  (optional)
     - returns: `EventLoopFuture` of `TemplatesPostTemplates`
     */
    open class func templatesPostTemplates(accountId: String, envelopeTemplate: EnvelopeTemplate? = nil, headers: HTTPHeaders = DocuSignAPI.customHeaders, beforeSend: (inout ClientRequest) throws -> Void = { _ in }) -> EventLoopFuture<TemplatesPostTemplates> {
        var path = "/v2.1/accounts/{accountId}/templates"
        let accountIdPreEscape = String(describing: accountId)
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{accountId}", with: accountIdPostEscape, options: .literal, range: nil)
        let URLString = DocuSignAPI.basePath + path

        guard let apiClient = Configuration.apiClient else {
            fatalError("Configuration.apiClient is not set.")
        }

        return apiClient.send(.POST, headers: headers, to: URI(string: URLString)) { request in
            try Configuration.apiWrapper(&request)

            if let body = envelopeTemplate {
                try request.content.encode(body)
            }

            try beforeSend(&request)
        }.flatMapThrowing { response -> TemplatesPostTemplates in
            switch response.status.code {
            case 201:
                return .http201(value: try? response.content.decode(TemplateSummary.self), raw: response)
            case 400:
                return .http400(value: try? response.content.decode(ErrorDetails.self), raw: response)
            default:
                return .http0(value: try? response.content.decode(TemplateSummary.self), raw: response)
            }
        }
    }

    public enum TemplatesPutTemplate {
        case http200(value: TemplateUpdateSummary?, raw: ClientResponse)
        case http400(value: ErrorDetails?, raw: ClientResponse)
        case http0(value: TemplateUpdateSummary?, raw: ClientResponse)
    }

    /**
     Updates an existing template.

     PUT /v2.1/accounts/{accountId}/templates/{templateId}

     Updates an existing template.

     - parameter accountId: (path) The external account number (int) or account ID GUID.
     - parameter templateId: (path) The id of the template.
     - parameter envelopeTemplate: (body)  (optional)
     - returns: `EventLoopFuture` of `TemplatesPutTemplate`
     */
    open class func templatesPutTemplate(accountId: String, templateId: String, envelopeTemplate: EnvelopeTemplate? = nil, headers: HTTPHeaders = DocuSignAPI.customHeaders, beforeSend: (inout ClientRequest) throws -> Void = { _ in }) -> EventLoopFuture<TemplatesPutTemplate> {
        var path = "/v2.1/accounts/{accountId}/templates/{templateId}"
        let accountIdPreEscape = String(describing: accountId)
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{accountId}", with: accountIdPostEscape, options: .literal, range: nil)
        let templateIdPreEscape = String(describing: templateId)
        let templateIdPostEscape = templateIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{templateId}", with: templateIdPostEscape, options: .literal, range: nil)
        let URLString = DocuSignAPI.basePath + path

        guard let apiClient = Configuration.apiClient else {
            fatalError("Configuration.apiClient is not set.")
        }

        return apiClient.send(.PUT, headers: headers, to: URI(string: URLString)) { request in
            try Configuration.apiWrapper(&request)

            if let body = envelopeTemplate {
                try request.content.encode(body)
            }

            try beforeSend(&request)
        }.flatMapThrowing { response -> TemplatesPutTemplate in
            switch response.status.code {
            case 200:
                return .http200(value: try? response.content.decode(TemplateUpdateSummary.self), raw: response)
            case 400:
                return .http400(value: try? response.content.decode(ErrorDetails.self), raw: response)
            default:
                return .http0(value: try? response.content.decode(TemplateUpdateSummary.self), raw: response)
            }
        }
    }

    public enum TemplatesPutTemplatePart {
        case http200(value: GroupInformation?, raw: ClientResponse)
        case http400(value: ErrorDetails?, raw: ClientResponse)
        case http0(value: GroupInformation?, raw: ClientResponse)
    }

    /**
     Shares a template with a group.

     PUT /v2.1/accounts/{accountId}/templates/{templateId}/{templatePart}

     Shares a template with the specified members group.  **Note**: For a newer version of this functionality, see [Accounts::Update Shared Access](https://developers.docusign.com/esign-rest-api/reference/Accounts/Accounts/updateSharedAccess).

     - parameter accountId: (path) The external account number (int) or account ID GUID.
     - parameter templateId: (path) The id of the template.
     - parameter templatePart: (path) Currently, the only defined part is **groups**.
     - parameter groupInformation: (body)  (optional)
     - returns: `EventLoopFuture` of `TemplatesPutTemplatePart`
     */
    open class func templatesPutTemplatePart(accountId: String, templateId: String, templatePart: String, groupInformation: GroupInformation? = nil, headers: HTTPHeaders = DocuSignAPI.customHeaders, beforeSend: (inout ClientRequest) throws -> Void = { _ in }) -> EventLoopFuture<TemplatesPutTemplatePart> {
        var path = "/v2.1/accounts/{accountId}/templates/{templateId}/{templatePart}"
        let accountIdPreEscape = String(describing: accountId)
        let accountIdPostEscape = accountIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{accountId}", with: accountIdPostEscape, options: .literal, range: nil)
        let templateIdPreEscape = String(describing: templateId)
        let templateIdPostEscape = templateIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{templateId}", with: templateIdPostEscape, options: .literal, range: nil)
        let templatePartPreEscape = String(describing: templatePart)
        let templatePartPostEscape = templatePartPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{templatePart}", with: templatePartPostEscape, options: .literal, range: nil)
        let URLString = DocuSignAPI.basePath + path

        guard let apiClient = Configuration.apiClient else {
            fatalError("Configuration.apiClient is not set.")
        }

        return apiClient.send(.PUT, headers: headers, to: URI(string: URLString)) { request in
            try Configuration.apiWrapper(&request)

            if let body = groupInformation {
                try request.content.encode(body)
            }

            try beforeSend(&request)
        }.flatMapThrowing { response -> TemplatesPutTemplatePart in
            switch response.status.code {
            case 200:
                return .http200(value: try? response.content.decode(GroupInformation.self), raw: response)
            case 400:
                return .http400(value: try? response.content.decode(ErrorDetails.self), raw: response)
            default:
                return .http0(value: try? response.content.decode(GroupInformation.self), raw: response)
            }
        }
    }
}
