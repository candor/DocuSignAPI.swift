//
// ConnectConfigurations.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import AnyCodable
import Foundation
import Vapor

/** Contains information about a DocuSign Connect configuration. */
public final class ConnectConfigurations: Content, Hashable {
    /** When set to **true**, data is sent to the urlToPublishTo web address. This option can be set to false to stop sending data while maintaining the Connect configuration information. */
    public var allowEnvelopePublish: String?
    /** When set to **true**  (default), DocuSign sends data to the designated Salesforce account through Connect. */
    public var allowSalesforcePublish: String?
    /** When set to **true**, the tracked envelope and recipient events for all users, including users that are added a later time, are sent through Connect. */
    public var allUsers: String?
    /** If you are using merge fields, this property specifies the type of the merge field. The only supported value is `salesforce`. */
    public var configurationType: String?
    /** The DocuSign-generated ID for the Connect configuration. This property is read only. */
    public var connectId: String?
    /** When set to **true**, Connect logging is turned on. We recommend that you enable this functionality, which helps you troubleshoot any issues.   You can have a maximum of 100 active logs in your account. You can view the entries in active logs in the **Logs** tab in the console. */
    public var enableLog: String?
    /** An array of strings that lists envelope-related events to track through Connect. The possible event values are:   - `sent`: An envelope has the status `sent` in the following scenarios:    - When the envelope has been sent to recipients.    - When using remote signing, this event is triggered when the email notification with a link to the documents is sent to at least one recipient.    - When using embedded signing, this event is triggered when the link is ready for the recipient to sign the envelope.     An envelope remains in this state until all recipients have viewed or taken action on the envelope.  - `delivered`: This status is triggered when all recipients have opened the envelope, selected the **Continue** button in the interface, and viewed the documents. - `completed`: This status is triggered when all recipients have completed their assigned actions on an envelope. - `declined`: This status is triggered when a recipient has declined to sign the envelope. - `voided`: The voided status indicates that the sender has voided the envelope.  **Note**: In previous versions of the API, this value was a single comma-separated string.  */
    public var envelopeEvents: [String]?
    public var eventData: ConnectEventData?
    /** The id of an external folder. */
    public var externalFolderId: String?
    /** The label for an external folder. */
    public var externalFolderLabel: String?
    /** When set to **true**, the Connect Service includes the Certificate of Completion with completed envelopes.  */
    public var includeCertificateOfCompletion: String?
    /** When set to **true**, a certificate for a SOAP header is included in messages sent through Connect. */
    public var includeCertSoapHeader: String?
    /** When set to **true**, the Document Fields associated with the envelope's documents are included in the notification messages. Document Fields are optional custom name-value pairs added to documents using the API.  */
    public var includeDocumentFields: String?
    /** When set to **true**, Connect attaches the envelope documents to the XML payloads of your event notification messages.  **Note**: Consider resources and scaling when adding documents to your event payloads. Documents attached to these messages are sent in base64 XML element nodes, which are larger than binary document data. This can significantly increase your payload size, opening up windows for failure. If you include documents, you must build your application to scale in these situations.  */
    public var includeDocuments: String?
    /** When set to **true**, Connect will include the voidedReason for voided envelopes. */
    public var includeEnvelopeVoidReason: String?
    /** When set to **true**, a Hash-based Message Authentication Code (HMAC) signature is included in messages sent through Connect. For more information, see [Using HMAC Security with DocuSign Connect](https://developers.docusign.com/esign-rest-api/guides/connect-hmac). */
    public var includeHMAC: String?
    /** When set to **true**, Connect will include the sender account as Custom Field in the data. */
    public var includeSenderAccountasCustomField: String?
    /** When set to **true**, Connect will include the envelope time zone information. */
    public var includeTimeZoneInformation: String?
    /** The name of the Connect configuration. The name helps identify the configuration in the list. */
    public var name: String?
    /** The user's encrypted password hash. */
    public var password: String?
    /** An array of strings that lists of recipient-related events that trigger a notification to your webhook Connect listener. The possible event values are:  - `sent`: If a recipient type is set to receive an email notification to take action on an envelope, the recipient status is set to `sent` upon delivery of the email. - `delivered`: The recipient has viewed the documents in the envelope. This recipient status does not indicate email delivery of the documents in the envelope. - `completed`: The recipient has completed their assigned actions on an envelope. - `declined`: The recipient has declined to sign a document in the envelope. - `authenticationfailed`: At least one signer has failed the authentication check on the document. If this occurs, you have two options:    - Send a reminder to the recipients, which provides the signer with another chance to access and pass the authentication.    - Correct the document and modify the authentication setting. - `autoresponded`: The recipient's email system sent back an automatic response. This status is only used when **Send-on-behalf-of** is turned off for the account.  **Note**: In previous versions of the API, this value was a single comma-separated string.  */
    public var recipientEvents: [String]?
    /** When set to **true**, [Mutual TLS](https://developers.docusign.com/esign-rest-api/guides/mutual-tls-intro) authentication is enabled. */
    public var requireMutualTls: String?
    /** When set to **true**, event delivery acknowledgements are enabled for your Connect configuration.  DocuSign Connect awaits a valid 200 response from your application acknowledging that it received a message. If you do not acknowledge receiving an event notification message within 100 seconds, DocuSign treats the message as a failure and places it into a failure queue. It is imperative that you acknowledge successful receipt of Connect events as they occur by sending a 200 event back.  #### When set to **true** and Send Individual Messages (SIM) mode is activated  If the HTTP status response to a notification message is not in the range of 200-299, then the message delivery failed, and the configuration is marked as down.  The message will be queued and retried once per day. While a Connect configuration is marked down, subsequent notifications will not be tried. Instead they will be immediately queued with the reason `Pending`. When a message succeeds, all queued messages for the configuration will be tried immediately, in order.  There is a maximum of ten retries. Alternately, you can use **Republish Connect Information** to manually republish the notification.  #### When set to **true** and SIM mode is not activated  If the HTTP Status response to a notification message is not in the range of 200-299,  then the message delivery failed, and the message is queued.  The message will be retried after at least a day the next time a subsequent message is successfully sent to this configuration (subscription).  Subsequent notifications will be tried when they occur. There is a maximum of ten retries. Alternately, you can use **Republish Connect Information** to manually republish the notification.  #### When set to **false**  When `requiresAcknowledgement` is set to **false** and you do not acknowledge receiving an event notification message within 100 seconds, DocuSign treats the message as a failure and determines that the server is unavailable. It does not retry to send the notification message, and you must handle the failure manually.   */
    public var requiresAcknowledgement: String?
    /** The version of the Salesforce API that you are using. */
    public var salesforceApiVersion: String?
    /**  */
    public var salesforceAuthcode: String?
    /**  */
    public var salesforceCallBackUrl: String?
    /** When set to **true**, DocuSign can use documents in your Salesforce account for sending and signing. */
    public var salesforceDocumentsAsContentFiles: String?
    /**  */
    public var senderOverride: String?
    /** This property sets the items that are available for selection when adding or editing Connect objects.  */
    public var senderSelectableItems: [String]?
    /** An array of Salesforce objects. */
    public var sfObjects: [ConnectSalesforceObject]?
    /** When set to **true**, Mutual TLS will be enabled for notifications. Mutual TLS must be initiated by the listener (the customer's web server) during the TLS handshake protocol.  */
    public var signMessageWithX509Certificate: String?
    /** The namespace of the SOAP interface.  **Note**: If `useSoapInterface` is set to **true**, you must set this value. */
    public var soapNamespace: String?
    /** The endpoint to which Connect should send webhook notification messages via an HTTPS POST request. The URL must start with `https`. The customer's web server must use an SSL/TLS certificate whose CA is in the Microsoft list of trusted CAs. Self-signed certificates are not acceptable, but you can use free certificates from Let's Encrypt. */
    public var urlToPublishTo: String?
    /** A comma-separated list of userIds. This sets the users associated with the tracked envelope and recipient events. When a tracked event occurs for a set user, the a notification message is sent to your Connect listener.  **Note**: If allUsers is set to `false` then you must provide a list of user ids. */
    public var userIds: [String]?
    /** The name of the user. */
    public var userName: String?
    /** When set to **true**, indicates that the `urlToPublishTo` property contains a SOAP endpoint. */
    public var useSoapInterface: String?

    public init(allowEnvelopePublish: String? = nil, allowSalesforcePublish: String? = nil, allUsers: String? = nil, configurationType: String? = nil, connectId: String? = nil, enableLog: String? = nil, envelopeEvents: [String]? = nil, eventData: ConnectEventData? = nil, externalFolderId: String? = nil, externalFolderLabel: String? = nil, includeCertificateOfCompletion: String? = nil, includeCertSoapHeader: String? = nil, includeDocumentFields: String? = nil, includeDocuments: String? = nil, includeEnvelopeVoidReason: String? = nil, includeHMAC: String? = nil, includeSenderAccountasCustomField: String? = nil, includeTimeZoneInformation: String? = nil, name: String? = nil, password: String? = nil, recipientEvents: [String]? = nil, requireMutualTls: String? = nil, requiresAcknowledgement: String? = nil, salesforceApiVersion: String? = nil, salesforceAuthcode: String? = nil, salesforceCallBackUrl: String? = nil, salesforceDocumentsAsContentFiles: String? = nil, senderOverride: String? = nil, senderSelectableItems: [String]? = nil, sfObjects: [ConnectSalesforceObject]? = nil, signMessageWithX509Certificate: String? = nil, soapNamespace: String? = nil, urlToPublishTo: String? = nil, userIds: [String]? = nil, userName: String? = nil, useSoapInterface: String? = nil) {
        self.allowEnvelopePublish = allowEnvelopePublish
        self.allowSalesforcePublish = allowSalesforcePublish
        self.allUsers = allUsers
        self.configurationType = configurationType
        self.connectId = connectId
        self.enableLog = enableLog
        self.envelopeEvents = envelopeEvents
        self.eventData = eventData
        self.externalFolderId = externalFolderId
        self.externalFolderLabel = externalFolderLabel
        self.includeCertificateOfCompletion = includeCertificateOfCompletion
        self.includeCertSoapHeader = includeCertSoapHeader
        self.includeDocumentFields = includeDocumentFields
        self.includeDocuments = includeDocuments
        self.includeEnvelopeVoidReason = includeEnvelopeVoidReason
        self.includeHMAC = includeHMAC
        self.includeSenderAccountasCustomField = includeSenderAccountasCustomField
        self.includeTimeZoneInformation = includeTimeZoneInformation
        self.name = name
        self.password = password
        self.recipientEvents = recipientEvents
        self.requireMutualTls = requireMutualTls
        self.requiresAcknowledgement = requiresAcknowledgement
        self.salesforceApiVersion = salesforceApiVersion
        self.salesforceAuthcode = salesforceAuthcode
        self.salesforceCallBackUrl = salesforceCallBackUrl
        self.salesforceDocumentsAsContentFiles = salesforceDocumentsAsContentFiles
        self.senderOverride = senderOverride
        self.senderSelectableItems = senderSelectableItems
        self.sfObjects = sfObjects
        self.signMessageWithX509Certificate = signMessageWithX509Certificate
        self.soapNamespace = soapNamespace
        self.urlToPublishTo = urlToPublishTo
        self.userIds = userIds
        self.userName = userName
        self.useSoapInterface = useSoapInterface
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case allowEnvelopePublish
        case allowSalesforcePublish
        case allUsers
        case configurationType
        case connectId
        case enableLog
        case envelopeEvents
        case eventData
        case externalFolderId
        case externalFolderLabel
        case includeCertificateOfCompletion
        case includeCertSoapHeader
        case includeDocumentFields
        case includeDocuments
        case includeEnvelopeVoidReason
        case includeHMAC
        case includeSenderAccountasCustomField
        case includeTimeZoneInformation
        case name
        case password
        case recipientEvents
        case requireMutualTls
        case requiresAcknowledgement
        case salesforceApiVersion
        case salesforceAuthcode
        case salesforceCallBackUrl
        case salesforceDocumentsAsContentFiles
        case senderOverride
        case senderSelectableItems
        case sfObjects
        case signMessageWithX509Certificate
        case soapNamespace
        case urlToPublishTo
        case userIds
        case userName
        case useSoapInterface
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(allowEnvelopePublish, forKey: .allowEnvelopePublish)
        try container.encodeIfPresent(allowSalesforcePublish, forKey: .allowSalesforcePublish)
        try container.encodeIfPresent(allUsers, forKey: .allUsers)
        try container.encodeIfPresent(configurationType, forKey: .configurationType)
        try container.encodeIfPresent(connectId, forKey: .connectId)
        try container.encodeIfPresent(enableLog, forKey: .enableLog)
        try container.encodeIfPresent(envelopeEvents, forKey: .envelopeEvents)
        try container.encodeIfPresent(eventData, forKey: .eventData)
        try container.encodeIfPresent(externalFolderId, forKey: .externalFolderId)
        try container.encodeIfPresent(externalFolderLabel, forKey: .externalFolderLabel)
        try container.encodeIfPresent(includeCertificateOfCompletion, forKey: .includeCertificateOfCompletion)
        try container.encodeIfPresent(includeCertSoapHeader, forKey: .includeCertSoapHeader)
        try container.encodeIfPresent(includeDocumentFields, forKey: .includeDocumentFields)
        try container.encodeIfPresent(includeDocuments, forKey: .includeDocuments)
        try container.encodeIfPresent(includeEnvelopeVoidReason, forKey: .includeEnvelopeVoidReason)
        try container.encodeIfPresent(includeHMAC, forKey: .includeHMAC)
        try container.encodeIfPresent(includeSenderAccountasCustomField, forKey: .includeSenderAccountasCustomField)
        try container.encodeIfPresent(includeTimeZoneInformation, forKey: .includeTimeZoneInformation)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(password, forKey: .password)
        try container.encodeIfPresent(recipientEvents, forKey: .recipientEvents)
        try container.encodeIfPresent(requireMutualTls, forKey: .requireMutualTls)
        try container.encodeIfPresent(requiresAcknowledgement, forKey: .requiresAcknowledgement)
        try container.encodeIfPresent(salesforceApiVersion, forKey: .salesforceApiVersion)
        try container.encodeIfPresent(salesforceAuthcode, forKey: .salesforceAuthcode)
        try container.encodeIfPresent(salesforceCallBackUrl, forKey: .salesforceCallBackUrl)
        try container.encodeIfPresent(salesforceDocumentsAsContentFiles, forKey: .salesforceDocumentsAsContentFiles)
        try container.encodeIfPresent(senderOverride, forKey: .senderOverride)
        try container.encodeIfPresent(senderSelectableItems, forKey: .senderSelectableItems)
        try container.encodeIfPresent(sfObjects, forKey: .sfObjects)
        try container.encodeIfPresent(signMessageWithX509Certificate, forKey: .signMessageWithX509Certificate)
        try container.encodeIfPresent(soapNamespace, forKey: .soapNamespace)
        try container.encodeIfPresent(urlToPublishTo, forKey: .urlToPublishTo)
        try container.encodeIfPresent(userIds, forKey: .userIds)
        try container.encodeIfPresent(userName, forKey: .userName)
        try container.encodeIfPresent(useSoapInterface, forKey: .useSoapInterface)
    }

    public static func == (lhs: ConnectConfigurations, rhs: ConnectConfigurations) -> Bool {
        lhs.allowEnvelopePublish == rhs.allowEnvelopePublish &&
            lhs.allowSalesforcePublish == rhs.allowSalesforcePublish &&
            lhs.allUsers == rhs.allUsers &&
            lhs.configurationType == rhs.configurationType &&
            lhs.connectId == rhs.connectId &&
            lhs.enableLog == rhs.enableLog &&
            lhs.envelopeEvents == rhs.envelopeEvents &&
            lhs.eventData == rhs.eventData &&
            lhs.externalFolderId == rhs.externalFolderId &&
            lhs.externalFolderLabel == rhs.externalFolderLabel &&
            lhs.includeCertificateOfCompletion == rhs.includeCertificateOfCompletion &&
            lhs.includeCertSoapHeader == rhs.includeCertSoapHeader &&
            lhs.includeDocumentFields == rhs.includeDocumentFields &&
            lhs.includeDocuments == rhs.includeDocuments &&
            lhs.includeEnvelopeVoidReason == rhs.includeEnvelopeVoidReason &&
            lhs.includeHMAC == rhs.includeHMAC &&
            lhs.includeSenderAccountasCustomField == rhs.includeSenderAccountasCustomField &&
            lhs.includeTimeZoneInformation == rhs.includeTimeZoneInformation &&
            lhs.name == rhs.name &&
            lhs.password == rhs.password &&
            lhs.recipientEvents == rhs.recipientEvents &&
            lhs.requireMutualTls == rhs.requireMutualTls &&
            lhs.requiresAcknowledgement == rhs.requiresAcknowledgement &&
            lhs.salesforceApiVersion == rhs.salesforceApiVersion &&
            lhs.salesforceAuthcode == rhs.salesforceAuthcode &&
            lhs.salesforceCallBackUrl == rhs.salesforceCallBackUrl &&
            lhs.salesforceDocumentsAsContentFiles == rhs.salesforceDocumentsAsContentFiles &&
            lhs.senderOverride == rhs.senderOverride &&
            lhs.senderSelectableItems == rhs.senderSelectableItems &&
            lhs.sfObjects == rhs.sfObjects &&
            lhs.signMessageWithX509Certificate == rhs.signMessageWithX509Certificate &&
            lhs.soapNamespace == rhs.soapNamespace &&
            lhs.urlToPublishTo == rhs.urlToPublishTo &&
            lhs.userIds == rhs.userIds &&
            lhs.userName == rhs.userName &&
            lhs.useSoapInterface == rhs.useSoapInterface
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(allowEnvelopePublish?.hashValue)
        hasher.combine(allowSalesforcePublish?.hashValue)
        hasher.combine(allUsers?.hashValue)
        hasher.combine(configurationType?.hashValue)
        hasher.combine(connectId?.hashValue)
        hasher.combine(enableLog?.hashValue)
        hasher.combine(envelopeEvents?.hashValue)
        hasher.combine(eventData?.hashValue)
        hasher.combine(externalFolderId?.hashValue)
        hasher.combine(externalFolderLabel?.hashValue)
        hasher.combine(includeCertificateOfCompletion?.hashValue)
        hasher.combine(includeCertSoapHeader?.hashValue)
        hasher.combine(includeDocumentFields?.hashValue)
        hasher.combine(includeDocuments?.hashValue)
        hasher.combine(includeEnvelopeVoidReason?.hashValue)
        hasher.combine(includeHMAC?.hashValue)
        hasher.combine(includeSenderAccountasCustomField?.hashValue)
        hasher.combine(includeTimeZoneInformation?.hashValue)
        hasher.combine(name?.hashValue)
        hasher.combine(password?.hashValue)
        hasher.combine(recipientEvents?.hashValue)
        hasher.combine(requireMutualTls?.hashValue)
        hasher.combine(requiresAcknowledgement?.hashValue)
        hasher.combine(salesforceApiVersion?.hashValue)
        hasher.combine(salesforceAuthcode?.hashValue)
        hasher.combine(salesforceCallBackUrl?.hashValue)
        hasher.combine(salesforceDocumentsAsContentFiles?.hashValue)
        hasher.combine(senderOverride?.hashValue)
        hasher.combine(senderSelectableItems?.hashValue)
        hasher.combine(sfObjects?.hashValue)
        hasher.combine(signMessageWithX509Certificate?.hashValue)
        hasher.combine(soapNamespace?.hashValue)
        hasher.combine(urlToPublishTo?.hashValue)
        hasher.combine(userIds?.hashValue)
        hasher.combine(userName?.hashValue)
        hasher.combine(useSoapInterface?.hashValue)
    }
}
