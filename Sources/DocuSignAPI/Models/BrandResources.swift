//
// BrandResources.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import AnyCodable
import Foundation
import Vapor

/** Information about the resource files that the brand uses for the email, signing, sending, and captive (embedded) signing experiences. */
public final class BrandResources: Content, Hashable {
    public var createdByUserInfo: UserInfo?
    /** The date and time that the brand resource was created. */
    public var createdDate: String?
    /** Deprecated. */
    public var dataNotSavedNotInMaster: [String]?
    public var modifiedByUserInfo: UserInfo?
    /** The date on which this user record was last modified. */
    public var modifiedDate: String?
    /** This property is returned in the response to the [AccountBrands::listResources][listResources] request. It contains a list of any email templates that have been modified to differ from the master resource files.  [listResources]: /esign-rest-api/reference/Accounts/AccountBrands/listResources */
    public var modifiedTemplates: [String]?
    /** The type of brand resource file. A brand uses a different resource file to control each of the following experiences:  - Sending (`sending`) - Signing (`signing`) - Email messages (`email`) - Captive (embedded) signing (`signing_captive`)  You can modify the default email messages and formats in these files and upload them to your brand to customize the user experience. */
    public var resourcesContentType: String?
    /** The URI for the brand resource file. */
    public var resourcesContentUri: String?

    public init(createdByUserInfo: UserInfo? = nil, createdDate: String? = nil, dataNotSavedNotInMaster: [String]? = nil, modifiedByUserInfo: UserInfo? = nil, modifiedDate: String? = nil, modifiedTemplates: [String]? = nil, resourcesContentType: String? = nil, resourcesContentUri: String? = nil) {
        self.createdByUserInfo = createdByUserInfo
        self.createdDate = createdDate
        self.dataNotSavedNotInMaster = dataNotSavedNotInMaster
        self.modifiedByUserInfo = modifiedByUserInfo
        self.modifiedDate = modifiedDate
        self.modifiedTemplates = modifiedTemplates
        self.resourcesContentType = resourcesContentType
        self.resourcesContentUri = resourcesContentUri
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case createdByUserInfo
        case createdDate
        case dataNotSavedNotInMaster
        case modifiedByUserInfo
        case modifiedDate
        case modifiedTemplates
        case resourcesContentType
        case resourcesContentUri
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(createdByUserInfo, forKey: .createdByUserInfo)
        try container.encodeIfPresent(createdDate, forKey: .createdDate)
        try container.encodeIfPresent(dataNotSavedNotInMaster, forKey: .dataNotSavedNotInMaster)
        try container.encodeIfPresent(modifiedByUserInfo, forKey: .modifiedByUserInfo)
        try container.encodeIfPresent(modifiedDate, forKey: .modifiedDate)
        try container.encodeIfPresent(modifiedTemplates, forKey: .modifiedTemplates)
        try container.encodeIfPresent(resourcesContentType, forKey: .resourcesContentType)
        try container.encodeIfPresent(resourcesContentUri, forKey: .resourcesContentUri)
    }

    public static func == (lhs: BrandResources, rhs: BrandResources) -> Bool {
        lhs.createdByUserInfo == rhs.createdByUserInfo &&
            lhs.createdDate == rhs.createdDate &&
            lhs.dataNotSavedNotInMaster == rhs.dataNotSavedNotInMaster &&
            lhs.modifiedByUserInfo == rhs.modifiedByUserInfo &&
            lhs.modifiedDate == rhs.modifiedDate &&
            lhs.modifiedTemplates == rhs.modifiedTemplates &&
            lhs.resourcesContentType == rhs.resourcesContentType &&
            lhs.resourcesContentUri == rhs.resourcesContentUri
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(createdByUserInfo?.hashValue)
        hasher.combine(createdDate?.hashValue)
        hasher.combine(dataNotSavedNotInMaster?.hashValue)
        hasher.combine(modifiedByUserInfo?.hashValue)
        hasher.combine(modifiedDate?.hashValue)
        hasher.combine(modifiedTemplates?.hashValue)
        hasher.combine(resourcesContentType?.hashValue)
        hasher.combine(resourcesContentUri?.hashValue)
    }
}
