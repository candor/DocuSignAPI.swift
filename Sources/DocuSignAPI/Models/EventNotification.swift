//
// EventNotification.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import AnyCodable
import Foundation
import Vapor

/** Register a Connect webhook for a specific envelope */
public final class EventNotification: Content, Hashable {
    /** A list of envelope-level event statuses that will trigger Connect to send updates to the endpoint specified in the `url` property.   To receive notifications, you must include either an `envelopeEvents` node or a `recipientEvents` node. You do not need to specify both. */
    public var envelopeEvents: [EnvelopeEvent]?
    public var eventData: ConnectEventData?
    /** When set to **true**, the Connect Service includes the Certificate of Completion with completed envelopes.  */
    public var includeCertificateOfCompletion: String?
    /** When set to **true**, the Connect service will digitally sign the XML data. The signature will be included in the XML message. */
    public var includeCertificateWithSoap: String?
    /** When set to **true**, the Document Fields associated with the envelope's documents are included in the notification messages. Document Fields are optional custom name-value pairs added to documents using the API.  */
    public var includeDocumentFields: String?
    /** When set to **true**, the XML webhook messages will include the envelope's PDF documents. Including the PDF documents will greatly increase the size of the notification messages. Ensure that your listener can handle incoming messages that are 25MB or larger.  */
    public var includeDocuments: String?
    /** When set to **true**, if the envelope is voided, the Connect Service notification will include the void reason, as entered by the person that voided the envelope.  */
    public var includeEnvelopeVoidReason: String?
    /**  */
    public var includeHMAC: String?
    /** When set to **true**, Connect will include the sender account as Custom Field in the data. */
    public var includeSenderAccountAsCustomField: String?
    /** When set to **true**, the envelope's time zone information is included in the webhook messages.  */
    public var includeTimeZone: String?
    /** When set to **true**, the webhook messages are logged. They can be viewed on the DocuSign Administration Web Tool in the Connect section. Logged messages can also be downloaded via the [ConnectEvents resource](https://developers.docusign.com/esign-rest-api/reference/Connect/ConnectEvents). */
    public var loggingEnabled: String?
    /** An array of recipient event statuses that will trigger Connect to send notifications to your webhook listener at the url endpoint specified in the `url` property.   To receive notifications, you must include either an `envelopeEvents` node or a `recipientEvents` node. You do not need to specify both. */
    public var recipientEvents: [RecipientEvent]?
    /** When set to **true**, the DocuSign Connect service checks that the message was received and retries on failures.  */
    public var requireAcknowledgment: String?
    /** When set to **true**, Mutual TLS will be enabled for notifications. Mutual TLS must be initiated by the listener (the customer's web server) during the TLS handshake protocol.  */
    public var signMessageWithX509Cert: String?
    /** The namespace of the SOAP interface.  The namespace value must be set if useSoapInterface is set to true. */
    public var soapNameSpace: String?
    /** The endpoint to which webhook notification messages are sent via an HTTPS POST request. The url must start with https. The customer's web server must use an SSL/TLS certificate whose CA is in the Microsoft list of trusted CAs. Self-signed certificates are not ok. Free certificates from Let's Encrypt can be used. */
    public var url: String?
    /** When set to **true**, the notifications are sent to your endpoint as SOAP requests.  */
    public var useSoapInterface: String?

    public init(envelopeEvents: [EnvelopeEvent]? = nil, eventData: ConnectEventData? = nil, includeCertificateOfCompletion: String? = nil, includeCertificateWithSoap: String? = nil, includeDocumentFields: String? = nil, includeDocuments: String? = nil, includeEnvelopeVoidReason: String? = nil, includeHMAC: String? = nil, includeSenderAccountAsCustomField: String? = nil, includeTimeZone: String? = nil, loggingEnabled: String? = nil, recipientEvents: [RecipientEvent]? = nil, requireAcknowledgment: String? = nil, signMessageWithX509Cert: String? = nil, soapNameSpace: String? = nil, url: String? = nil, useSoapInterface: String? = nil) {
        self.envelopeEvents = envelopeEvents
        self.eventData = eventData
        self.includeCertificateOfCompletion = includeCertificateOfCompletion
        self.includeCertificateWithSoap = includeCertificateWithSoap
        self.includeDocumentFields = includeDocumentFields
        self.includeDocuments = includeDocuments
        self.includeEnvelopeVoidReason = includeEnvelopeVoidReason
        self.includeHMAC = includeHMAC
        self.includeSenderAccountAsCustomField = includeSenderAccountAsCustomField
        self.includeTimeZone = includeTimeZone
        self.loggingEnabled = loggingEnabled
        self.recipientEvents = recipientEvents
        self.requireAcknowledgment = requireAcknowledgment
        self.signMessageWithX509Cert = signMessageWithX509Cert
        self.soapNameSpace = soapNameSpace
        self.url = url
        self.useSoapInterface = useSoapInterface
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case envelopeEvents
        case eventData
        case includeCertificateOfCompletion
        case includeCertificateWithSoap
        case includeDocumentFields
        case includeDocuments
        case includeEnvelopeVoidReason
        case includeHMAC
        case includeSenderAccountAsCustomField
        case includeTimeZone
        case loggingEnabled
        case recipientEvents
        case requireAcknowledgment
        case signMessageWithX509Cert
        case soapNameSpace
        case url
        case useSoapInterface
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(envelopeEvents, forKey: .envelopeEvents)
        try container.encodeIfPresent(eventData, forKey: .eventData)
        try container.encodeIfPresent(includeCertificateOfCompletion, forKey: .includeCertificateOfCompletion)
        try container.encodeIfPresent(includeCertificateWithSoap, forKey: .includeCertificateWithSoap)
        try container.encodeIfPresent(includeDocumentFields, forKey: .includeDocumentFields)
        try container.encodeIfPresent(includeDocuments, forKey: .includeDocuments)
        try container.encodeIfPresent(includeEnvelopeVoidReason, forKey: .includeEnvelopeVoidReason)
        try container.encodeIfPresent(includeHMAC, forKey: .includeHMAC)
        try container.encodeIfPresent(includeSenderAccountAsCustomField, forKey: .includeSenderAccountAsCustomField)
        try container.encodeIfPresent(includeTimeZone, forKey: .includeTimeZone)
        try container.encodeIfPresent(loggingEnabled, forKey: .loggingEnabled)
        try container.encodeIfPresent(recipientEvents, forKey: .recipientEvents)
        try container.encodeIfPresent(requireAcknowledgment, forKey: .requireAcknowledgment)
        try container.encodeIfPresent(signMessageWithX509Cert, forKey: .signMessageWithX509Cert)
        try container.encodeIfPresent(soapNameSpace, forKey: .soapNameSpace)
        try container.encodeIfPresent(url, forKey: .url)
        try container.encodeIfPresent(useSoapInterface, forKey: .useSoapInterface)
    }

    public static func == (lhs: EventNotification, rhs: EventNotification) -> Bool {
        lhs.envelopeEvents == rhs.envelopeEvents &&
            lhs.eventData == rhs.eventData &&
            lhs.includeCertificateOfCompletion == rhs.includeCertificateOfCompletion &&
            lhs.includeCertificateWithSoap == rhs.includeCertificateWithSoap &&
            lhs.includeDocumentFields == rhs.includeDocumentFields &&
            lhs.includeDocuments == rhs.includeDocuments &&
            lhs.includeEnvelopeVoidReason == rhs.includeEnvelopeVoidReason &&
            lhs.includeHMAC == rhs.includeHMAC &&
            lhs.includeSenderAccountAsCustomField == rhs.includeSenderAccountAsCustomField &&
            lhs.includeTimeZone == rhs.includeTimeZone &&
            lhs.loggingEnabled == rhs.loggingEnabled &&
            lhs.recipientEvents == rhs.recipientEvents &&
            lhs.requireAcknowledgment == rhs.requireAcknowledgment &&
            lhs.signMessageWithX509Cert == rhs.signMessageWithX509Cert &&
            lhs.soapNameSpace == rhs.soapNameSpace &&
            lhs.url == rhs.url &&
            lhs.useSoapInterface == rhs.useSoapInterface
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(envelopeEvents?.hashValue)
        hasher.combine(eventData?.hashValue)
        hasher.combine(includeCertificateOfCompletion?.hashValue)
        hasher.combine(includeCertificateWithSoap?.hashValue)
        hasher.combine(includeDocumentFields?.hashValue)
        hasher.combine(includeDocuments?.hashValue)
        hasher.combine(includeEnvelopeVoidReason?.hashValue)
        hasher.combine(includeHMAC?.hashValue)
        hasher.combine(includeSenderAccountAsCustomField?.hashValue)
        hasher.combine(includeTimeZone?.hashValue)
        hasher.combine(loggingEnabled?.hashValue)
        hasher.combine(recipientEvents?.hashValue)
        hasher.combine(requireAcknowledgment?.hashValue)
        hasher.combine(signMessageWithX509Cert?.hashValue)
        hasher.combine(soapNameSpace?.hashValue)
        hasher.combine(url?.hashValue)
        hasher.combine(useSoapInterface?.hashValue)
    }
}
