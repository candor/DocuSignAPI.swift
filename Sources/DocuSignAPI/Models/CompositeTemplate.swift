//
// CompositeTemplate.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import AnyCodable
import Foundation
import Vapor

/** This object contains information about a [composite template][composite], which you can use to to apply multiple templates to a single envelope, combine templates with PDF forms, and combine templates with documents from cloud sources.  [composite]: https://developers.docusign.com/esign-rest-api/guides/features/templates#composite-templates */
public final class CompositeTemplate: Content, Hashable {
    /** The id of this composite template. This id is used as a reference when adding document object information. If used, the document's `content-disposition` must include the composite template ID to which the document should be added. If a composite template ID is not specified in the content-disposition, the document is applied based on the value of the `documentId` property only. If no document object is specified, the composite template inherits the first document. */
    public var compositeTemplateId: String?
    public var document: Document?
    /**  Zero or more inline templates and their position in the overlay. If supplied, they are overlaid into the envelope in the order of their Sequence value. */
    public var inlineTemplates: [InlineTemplate]?
    /** A number representing the sequence in which to apply the template that contains the PDF metadata.  Example: `4` */
    public var pdfMetaDataTemplateSequence: String?
    /** Zero or more server-side templates and their position in the overlay. If supplied, they are overlaid into the envelope in the order of their Sequence value */
    public var serverTemplates: [ServerTemplate]?

    public init(compositeTemplateId: String? = nil, document: Document? = nil, inlineTemplates: [InlineTemplate]? = nil, pdfMetaDataTemplateSequence: String? = nil, serverTemplates: [ServerTemplate]? = nil) {
        self.compositeTemplateId = compositeTemplateId
        self.document = document
        self.inlineTemplates = inlineTemplates
        self.pdfMetaDataTemplateSequence = pdfMetaDataTemplateSequence
        self.serverTemplates = serverTemplates
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case compositeTemplateId
        case document
        case inlineTemplates
        case pdfMetaDataTemplateSequence
        case serverTemplates
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(compositeTemplateId, forKey: .compositeTemplateId)
        try container.encodeIfPresent(document, forKey: .document)
        try container.encodeIfPresent(inlineTemplates, forKey: .inlineTemplates)
        try container.encodeIfPresent(pdfMetaDataTemplateSequence, forKey: .pdfMetaDataTemplateSequence)
        try container.encodeIfPresent(serverTemplates, forKey: .serverTemplates)
    }

    public static func == (lhs: CompositeTemplate, rhs: CompositeTemplate) -> Bool {
        lhs.compositeTemplateId == rhs.compositeTemplateId &&
            lhs.document == rhs.document &&
            lhs.inlineTemplates == rhs.inlineTemplates &&
            lhs.pdfMetaDataTemplateSequence == rhs.pdfMetaDataTemplateSequence &&
            lhs.serverTemplates == rhs.serverTemplates
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(compositeTemplateId?.hashValue)
        hasher.combine(document?.hashValue)
        hasher.combine(inlineTemplates?.hashValue)
        hasher.combine(pdfMetaDataTemplateSequence?.hashValue)
        hasher.combine(serverTemplates?.hashValue)
    }
}
