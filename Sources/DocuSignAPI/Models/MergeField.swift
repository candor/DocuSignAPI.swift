//
// MergeField.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import AnyCodable
import Foundation
import Vapor

/** Contains information for transfering values between Salesforce data fields and DocuSign Tabs. */
public final class MergeField: Content, Hashable {
    /** When **true**, the sender can modify the value of the `mergeField` tab during the sending process. */
    public var allowSenderToEdit: String?
    public var allowSenderToEditMetadata: PropertyMetadata?
    /** If you are using merge fields, this property specifies the type of the merge field. The only supported value is `salesforce`. */
    public var configurationType: String?
    public var configurationTypeMetadata: PropertyMetadata?
    /** Sets the object associated with the custom tab. Currently this is the Salesforce Object. */
    public var path: String?
    /** Reserved for DocuSign. */
    public var pathExtended: [PathExtendedElement]?
    public var pathExtendedMetadata: PropertyMetadata?
    public var pathMetadata: PropertyMetadata?
    /** Specifies the row number in a Salesforce table that the merge field value corresponds to. */
    public var row: String?
    public var rowMetadata: PropertyMetadata?
    /** When **true**, data entered into the merge field during Signing will update the mapped Salesforce field. */
    public var writeBack: String?
    public var writeBackMetadata: PropertyMetadata?

    public init(allowSenderToEdit: String? = nil, allowSenderToEditMetadata: PropertyMetadata? = nil, configurationType: String? = nil, configurationTypeMetadata: PropertyMetadata? = nil, path: String? = nil, pathExtended: [PathExtendedElement]? = nil, pathExtendedMetadata: PropertyMetadata? = nil, pathMetadata: PropertyMetadata? = nil, row: String? = nil, rowMetadata: PropertyMetadata? = nil, writeBack: String? = nil, writeBackMetadata: PropertyMetadata? = nil) {
        self.allowSenderToEdit = allowSenderToEdit
        self.allowSenderToEditMetadata = allowSenderToEditMetadata
        self.configurationType = configurationType
        self.configurationTypeMetadata = configurationTypeMetadata
        self.path = path
        self.pathExtended = pathExtended
        self.pathExtendedMetadata = pathExtendedMetadata
        self.pathMetadata = pathMetadata
        self.row = row
        self.rowMetadata = rowMetadata
        self.writeBack = writeBack
        self.writeBackMetadata = writeBackMetadata
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case allowSenderToEdit
        case allowSenderToEditMetadata
        case configurationType
        case configurationTypeMetadata
        case path
        case pathExtended
        case pathExtendedMetadata
        case pathMetadata
        case row
        case rowMetadata
        case writeBack
        case writeBackMetadata
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(allowSenderToEdit, forKey: .allowSenderToEdit)
        try container.encodeIfPresent(allowSenderToEditMetadata, forKey: .allowSenderToEditMetadata)
        try container.encodeIfPresent(configurationType, forKey: .configurationType)
        try container.encodeIfPresent(configurationTypeMetadata, forKey: .configurationTypeMetadata)
        try container.encodeIfPresent(path, forKey: .path)
        try container.encodeIfPresent(pathExtended, forKey: .pathExtended)
        try container.encodeIfPresent(pathExtendedMetadata, forKey: .pathExtendedMetadata)
        try container.encodeIfPresent(pathMetadata, forKey: .pathMetadata)
        try container.encodeIfPresent(row, forKey: .row)
        try container.encodeIfPresent(rowMetadata, forKey: .rowMetadata)
        try container.encodeIfPresent(writeBack, forKey: .writeBack)
        try container.encodeIfPresent(writeBackMetadata, forKey: .writeBackMetadata)
    }

    public static func == (lhs: MergeField, rhs: MergeField) -> Bool {
        lhs.allowSenderToEdit == rhs.allowSenderToEdit &&
            lhs.allowSenderToEditMetadata == rhs.allowSenderToEditMetadata &&
            lhs.configurationType == rhs.configurationType &&
            lhs.configurationTypeMetadata == rhs.configurationTypeMetadata &&
            lhs.path == rhs.path &&
            lhs.pathExtended == rhs.pathExtended &&
            lhs.pathExtendedMetadata == rhs.pathExtendedMetadata &&
            lhs.pathMetadata == rhs.pathMetadata &&
            lhs.row == rhs.row &&
            lhs.rowMetadata == rhs.rowMetadata &&
            lhs.writeBack == rhs.writeBack &&
            lhs.writeBackMetadata == rhs.writeBackMetadata
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(allowSenderToEdit?.hashValue)
        hasher.combine(allowSenderToEditMetadata?.hashValue)
        hasher.combine(configurationType?.hashValue)
        hasher.combine(configurationTypeMetadata?.hashValue)
        hasher.combine(path?.hashValue)
        hasher.combine(pathExtended?.hashValue)
        hasher.combine(pathExtendedMetadata?.hashValue)
        hasher.combine(pathMetadata?.hashValue)
        hasher.combine(row?.hashValue)
        hasher.combine(rowMetadata?.hashValue)
        hasher.combine(writeBack?.hashValue)
        hasher.combine(writeBackMetadata?.hashValue)
    }
}
