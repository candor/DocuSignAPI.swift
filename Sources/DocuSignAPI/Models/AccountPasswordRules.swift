//
// AccountPasswordRules.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import AnyCodable
import Foundation
import Vapor

/** Contains details about the password rules for an account. */
public final class AccountPasswordRules: Content, Hashable {
    /** When set to **true**, passwords expire. The default value is `false`. */
    public var expirePassword: String?
    /** The number of days before passwords expire. To use this property, the `expirePassword` property must be set to **true**. */
    public var expirePasswordDays: String?
    public var expirePasswordDaysMetadata: AccountPasswordExpirePasswordDays?
    /** The number of minutes a user is locked out of the system after three (?) failed login attempts. The default value is `2`. */
    public var lockoutDurationMinutes: String?
    public var lockoutDurationMinutesMetadata: AccountPasswordLockoutDurationMinutes?
    /** The interval associated with the user lockout after a failed login attempt.  Possible values are: (?????)  - `minutes` (default) - `hours` - `days` */
    public var lockoutDurationType: String?
    public var lockoutDurationTypeMetadata: AccountPasswordLockoutDurationType?
    /** The minimum number of days after a password is set before it can be changed. This value can be `0` or more days. The default value is `0`. */
    public var minimumPasswordAgeDays: String?
    public var minimumPasswordAgeDaysMetadata: AccountPasswordMinimumPasswordAgeDays?
    /** The minimum number of characters in the password. This value must be a number between `6` and `15`. The default value is `6`. */
    public var minimumPasswordLength: String?
    public var minimumPasswordLengthMetadata: AccountMinimumPasswordLength?
    /** When set to **true**, passwords must include a digit. The default value is `false`. */
    public var passwordIncludeDigit: String?
    /** When set to **true**, passwords must include either a digit or a special character. The default value is `false`.  **Note**: Passwords cannot include angle brackets (`<` `>`) or spaces. */
    public var passwordIncludeDigitOrSpecialCharacter: String?
    /** When set to **true**, passwords must include a lowercase letter. The default value is `false`. */
    public var passwordIncludeLowerCase: String?
    /** When set to **true**, passwords must include a special character. The default value is `false`.  **Note**: Passwords cannot include angle brackets (`<` `>`) or spaces. */
    public var passwordIncludeSpecialCharacter: String?
    /** When set to **true**, passwords must include an uppercase letter. The default value is `false`. */
    public var passwordIncludeUpperCase: String?
    /** The type of password strength. Possible values are:  - `basic`: The minimum password length is 6 characters with no other password requirements. - `medium`: The minimum password length is 7 characters. Passwords must also have one uppercase letter, one lowercase letter, and one number or special character. - `strong`: The minimum password length is 9 characters. Passwords must also have one uppercase letter, one lowercase letter, one number, and one special character. - `custom`: This option enables you to customize password requirements, including the following properties:     - `minimumPasswordLength`    - `minimumPasswordAgeDays`    - `passwordIncludeDigit`    - `passwordIncludeDigitOrSpecialCharacter`    - `passwordIncludeLowerCase`    - `passwordIncludeSpecialCharacter`    - `passwordIncludeUpperCase`    - `questionsRequired` */
    public var passwordStrengthType: String?
    public var passwordStrengthTypeMetadata: AccountPasswordStrengthType?
    /** The number of security questions required to confirm the userâ€™s identity before the user can reset their password. The default value is `0`. */
    public var questionsRequired: String?
    public var questionsRequiredMetadata: AccountPasswordQuestionsRequired?

    public init(expirePassword: String? = nil, expirePasswordDays: String? = nil, expirePasswordDaysMetadata: AccountPasswordExpirePasswordDays? = nil, lockoutDurationMinutes: String? = nil, lockoutDurationMinutesMetadata: AccountPasswordLockoutDurationMinutes? = nil, lockoutDurationType: String? = nil, lockoutDurationTypeMetadata: AccountPasswordLockoutDurationType? = nil, minimumPasswordAgeDays: String? = nil, minimumPasswordAgeDaysMetadata: AccountPasswordMinimumPasswordAgeDays? = nil, minimumPasswordLength: String? = nil, minimumPasswordLengthMetadata: AccountMinimumPasswordLength? = nil, passwordIncludeDigit: String? = nil, passwordIncludeDigitOrSpecialCharacter: String? = nil, passwordIncludeLowerCase: String? = nil, passwordIncludeSpecialCharacter: String? = nil, passwordIncludeUpperCase: String? = nil, passwordStrengthType: String? = nil, passwordStrengthTypeMetadata: AccountPasswordStrengthType? = nil, questionsRequired: String? = nil, questionsRequiredMetadata: AccountPasswordQuestionsRequired? = nil) {
        self.expirePassword = expirePassword
        self.expirePasswordDays = expirePasswordDays
        self.expirePasswordDaysMetadata = expirePasswordDaysMetadata
        self.lockoutDurationMinutes = lockoutDurationMinutes
        self.lockoutDurationMinutesMetadata = lockoutDurationMinutesMetadata
        self.lockoutDurationType = lockoutDurationType
        self.lockoutDurationTypeMetadata = lockoutDurationTypeMetadata
        self.minimumPasswordAgeDays = minimumPasswordAgeDays
        self.minimumPasswordAgeDaysMetadata = minimumPasswordAgeDaysMetadata
        self.minimumPasswordLength = minimumPasswordLength
        self.minimumPasswordLengthMetadata = minimumPasswordLengthMetadata
        self.passwordIncludeDigit = passwordIncludeDigit
        self.passwordIncludeDigitOrSpecialCharacter = passwordIncludeDigitOrSpecialCharacter
        self.passwordIncludeLowerCase = passwordIncludeLowerCase
        self.passwordIncludeSpecialCharacter = passwordIncludeSpecialCharacter
        self.passwordIncludeUpperCase = passwordIncludeUpperCase
        self.passwordStrengthType = passwordStrengthType
        self.passwordStrengthTypeMetadata = passwordStrengthTypeMetadata
        self.questionsRequired = questionsRequired
        self.questionsRequiredMetadata = questionsRequiredMetadata
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case expirePassword
        case expirePasswordDays
        case expirePasswordDaysMetadata
        case lockoutDurationMinutes
        case lockoutDurationMinutesMetadata
        case lockoutDurationType
        case lockoutDurationTypeMetadata
        case minimumPasswordAgeDays
        case minimumPasswordAgeDaysMetadata
        case minimumPasswordLength
        case minimumPasswordLengthMetadata
        case passwordIncludeDigit
        case passwordIncludeDigitOrSpecialCharacter
        case passwordIncludeLowerCase
        case passwordIncludeSpecialCharacter
        case passwordIncludeUpperCase
        case passwordStrengthType
        case passwordStrengthTypeMetadata
        case questionsRequired
        case questionsRequiredMetadata
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(expirePassword, forKey: .expirePassword)
        try container.encodeIfPresent(expirePasswordDays, forKey: .expirePasswordDays)
        try container.encodeIfPresent(expirePasswordDaysMetadata, forKey: .expirePasswordDaysMetadata)
        try container.encodeIfPresent(lockoutDurationMinutes, forKey: .lockoutDurationMinutes)
        try container.encodeIfPresent(lockoutDurationMinutesMetadata, forKey: .lockoutDurationMinutesMetadata)
        try container.encodeIfPresent(lockoutDurationType, forKey: .lockoutDurationType)
        try container.encodeIfPresent(lockoutDurationTypeMetadata, forKey: .lockoutDurationTypeMetadata)
        try container.encodeIfPresent(minimumPasswordAgeDays, forKey: .minimumPasswordAgeDays)
        try container.encodeIfPresent(minimumPasswordAgeDaysMetadata, forKey: .minimumPasswordAgeDaysMetadata)
        try container.encodeIfPresent(minimumPasswordLength, forKey: .minimumPasswordLength)
        try container.encodeIfPresent(minimumPasswordLengthMetadata, forKey: .minimumPasswordLengthMetadata)
        try container.encodeIfPresent(passwordIncludeDigit, forKey: .passwordIncludeDigit)
        try container.encodeIfPresent(passwordIncludeDigitOrSpecialCharacter, forKey: .passwordIncludeDigitOrSpecialCharacter)
        try container.encodeIfPresent(passwordIncludeLowerCase, forKey: .passwordIncludeLowerCase)
        try container.encodeIfPresent(passwordIncludeSpecialCharacter, forKey: .passwordIncludeSpecialCharacter)
        try container.encodeIfPresent(passwordIncludeUpperCase, forKey: .passwordIncludeUpperCase)
        try container.encodeIfPresent(passwordStrengthType, forKey: .passwordStrengthType)
        try container.encodeIfPresent(passwordStrengthTypeMetadata, forKey: .passwordStrengthTypeMetadata)
        try container.encodeIfPresent(questionsRequired, forKey: .questionsRequired)
        try container.encodeIfPresent(questionsRequiredMetadata, forKey: .questionsRequiredMetadata)
    }

    public static func == (lhs: AccountPasswordRules, rhs: AccountPasswordRules) -> Bool {
        lhs.expirePassword == rhs.expirePassword &&
            lhs.expirePasswordDays == rhs.expirePasswordDays &&
            lhs.expirePasswordDaysMetadata == rhs.expirePasswordDaysMetadata &&
            lhs.lockoutDurationMinutes == rhs.lockoutDurationMinutes &&
            lhs.lockoutDurationMinutesMetadata == rhs.lockoutDurationMinutesMetadata &&
            lhs.lockoutDurationType == rhs.lockoutDurationType &&
            lhs.lockoutDurationTypeMetadata == rhs.lockoutDurationTypeMetadata &&
            lhs.minimumPasswordAgeDays == rhs.minimumPasswordAgeDays &&
            lhs.minimumPasswordAgeDaysMetadata == rhs.minimumPasswordAgeDaysMetadata &&
            lhs.minimumPasswordLength == rhs.minimumPasswordLength &&
            lhs.minimumPasswordLengthMetadata == rhs.minimumPasswordLengthMetadata &&
            lhs.passwordIncludeDigit == rhs.passwordIncludeDigit &&
            lhs.passwordIncludeDigitOrSpecialCharacter == rhs.passwordIncludeDigitOrSpecialCharacter &&
            lhs.passwordIncludeLowerCase == rhs.passwordIncludeLowerCase &&
            lhs.passwordIncludeSpecialCharacter == rhs.passwordIncludeSpecialCharacter &&
            lhs.passwordIncludeUpperCase == rhs.passwordIncludeUpperCase &&
            lhs.passwordStrengthType == rhs.passwordStrengthType &&
            lhs.passwordStrengthTypeMetadata == rhs.passwordStrengthTypeMetadata &&
            lhs.questionsRequired == rhs.questionsRequired &&
            lhs.questionsRequiredMetadata == rhs.questionsRequiredMetadata
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(expirePassword?.hashValue)
        hasher.combine(expirePasswordDays?.hashValue)
        hasher.combine(expirePasswordDaysMetadata?.hashValue)
        hasher.combine(lockoutDurationMinutes?.hashValue)
        hasher.combine(lockoutDurationMinutesMetadata?.hashValue)
        hasher.combine(lockoutDurationType?.hashValue)
        hasher.combine(lockoutDurationTypeMetadata?.hashValue)
        hasher.combine(minimumPasswordAgeDays?.hashValue)
        hasher.combine(minimumPasswordAgeDaysMetadata?.hashValue)
        hasher.combine(minimumPasswordLength?.hashValue)
        hasher.combine(minimumPasswordLengthMetadata?.hashValue)
        hasher.combine(passwordIncludeDigit?.hashValue)
        hasher.combine(passwordIncludeDigitOrSpecialCharacter?.hashValue)
        hasher.combine(passwordIncludeLowerCase?.hashValue)
        hasher.combine(passwordIncludeSpecialCharacter?.hashValue)
        hasher.combine(passwordIncludeUpperCase?.hashValue)
        hasher.combine(passwordStrengthType?.hashValue)
        hasher.combine(passwordStrengthTypeMetadata?.hashValue)
        hasher.combine(questionsRequired?.hashValue)
        hasher.combine(questionsRequiredMetadata?.hashValue)
    }
}
