//
// WorkspaceItem.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import AnyCodable
import Foundation
import Vapor

/** This object represents an item in a workspace, which can be either a file or folder. */
public final class WorkspaceItem: Content, Hashable {
    public var callerAuthorization: WorkspaceUserAuthorization?
    /** If the item is a file, this property specifies the content type of the file. */
    public var contentType: String?
    /** The UTC DateTime when the workspace user authorization was created. */
    public var created: String?
    /** The id of the user who created the workspace item. */
    public var createdById: String?
    public var createdByInformation: WorkspaceUser?
    /** The file extension of a file item. */
    public var `extension`: String?
    /** The size of the file in bytes. */
    public var fileSize: String?
    /** The URI for retrieving the file. */
    public var fileUri: String?
    /** A unique ID for the Salesforce object. */
    public var id: String?
    /**  When **true**, the item is public. */
    public var isPublic: String?
    /** The UTC date and time that the comment was last updated.  **Note**: This can only be done by the creator. */
    public var lastModified: String?
    /** The id of the user who last modified the item. */
    public var lastModifiedById: String?
    public var lastModifiedByInformation: WorkspaceUser?
    /** The name of the file or folder. */
    public var name: String?
    /** The number of pages in a file. */
    public var pageCount: String?
    /** The id of the parent folder, or the special value `root` for the root folder. */
    public var parentFolderId: String?
    /** The URI of the parent folder. */
    public var parentFolderUri: String?
    /** A 64-byte, Secure Hash Algorithm 256 (SHA256) checksum that the caller computes across the entirety of the original content of a file. DocuSign compares this value to its own computation. If the two values are not equal, the original content and received content are not the same and the upload is refused. */
    public var sha256: String?
    /** The height of the thumbnail image. */
    public var thumbHeight: String?
    public var thumbnail: Page?
    /** The width of the thumbnail image. */
    public var thumbWidth: String?
    /**  */
    public var type: String?
    /** A URI containing the user ID. */
    public var uri: String?
    public var userAuthorization: WorkspaceUserAuthorization?

    public init(callerAuthorization: WorkspaceUserAuthorization? = nil, contentType: String? = nil, created: String? = nil, createdById: String? = nil, createdByInformation: WorkspaceUser? = nil, extension: String? = nil, fileSize: String? = nil, fileUri: String? = nil, id: String? = nil, isPublic: String? = nil, lastModified: String? = nil, lastModifiedById: String? = nil, lastModifiedByInformation: WorkspaceUser? = nil, name: String? = nil, pageCount: String? = nil, parentFolderId: String? = nil, parentFolderUri: String? = nil, sha256: String? = nil, thumbHeight: String? = nil, thumbnail: Page? = nil, thumbWidth: String? = nil, type: String? = nil, uri: String? = nil, userAuthorization: WorkspaceUserAuthorization? = nil) {
        self.callerAuthorization = callerAuthorization
        self.contentType = contentType
        self.created = created
        self.createdById = createdById
        self.createdByInformation = createdByInformation
        self.extension = `extension`
        self.fileSize = fileSize
        self.fileUri = fileUri
        self.id = id
        self.isPublic = isPublic
        self.lastModified = lastModified
        self.lastModifiedById = lastModifiedById
        self.lastModifiedByInformation = lastModifiedByInformation
        self.name = name
        self.pageCount = pageCount
        self.parentFolderId = parentFolderId
        self.parentFolderUri = parentFolderUri
        self.sha256 = sha256
        self.thumbHeight = thumbHeight
        self.thumbnail = thumbnail
        self.thumbWidth = thumbWidth
        self.type = type
        self.uri = uri
        self.userAuthorization = userAuthorization
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case callerAuthorization
        case contentType
        case created
        case createdById
        case createdByInformation
        case `extension`
        case fileSize
        case fileUri
        case id
        case isPublic
        case lastModified
        case lastModifiedById
        case lastModifiedByInformation
        case name
        case pageCount
        case parentFolderId
        case parentFolderUri
        case sha256
        case thumbHeight
        case thumbnail
        case thumbWidth
        case type
        case uri
        case userAuthorization
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(callerAuthorization, forKey: .callerAuthorization)
        try container.encodeIfPresent(contentType, forKey: .contentType)
        try container.encodeIfPresent(created, forKey: .created)
        try container.encodeIfPresent(createdById, forKey: .createdById)
        try container.encodeIfPresent(createdByInformation, forKey: .createdByInformation)
        try container.encodeIfPresent(`extension`, forKey: .extension)
        try container.encodeIfPresent(fileSize, forKey: .fileSize)
        try container.encodeIfPresent(fileUri, forKey: .fileUri)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(isPublic, forKey: .isPublic)
        try container.encodeIfPresent(lastModified, forKey: .lastModified)
        try container.encodeIfPresent(lastModifiedById, forKey: .lastModifiedById)
        try container.encodeIfPresent(lastModifiedByInformation, forKey: .lastModifiedByInformation)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(pageCount, forKey: .pageCount)
        try container.encodeIfPresent(parentFolderId, forKey: .parentFolderId)
        try container.encodeIfPresent(parentFolderUri, forKey: .parentFolderUri)
        try container.encodeIfPresent(sha256, forKey: .sha256)
        try container.encodeIfPresent(thumbHeight, forKey: .thumbHeight)
        try container.encodeIfPresent(thumbnail, forKey: .thumbnail)
        try container.encodeIfPresent(thumbWidth, forKey: .thumbWidth)
        try container.encodeIfPresent(type, forKey: .type)
        try container.encodeIfPresent(uri, forKey: .uri)
        try container.encodeIfPresent(userAuthorization, forKey: .userAuthorization)
    }

    public static func == (lhs: WorkspaceItem, rhs: WorkspaceItem) -> Bool {
        lhs.callerAuthorization == rhs.callerAuthorization &&
            lhs.contentType == rhs.contentType &&
            lhs.created == rhs.created &&
            lhs.createdById == rhs.createdById &&
            lhs.createdByInformation == rhs.createdByInformation &&
            lhs.extension == rhs.extension &&
            lhs.fileSize == rhs.fileSize &&
            lhs.fileUri == rhs.fileUri &&
            lhs.id == rhs.id &&
            lhs.isPublic == rhs.isPublic &&
            lhs.lastModified == rhs.lastModified &&
            lhs.lastModifiedById == rhs.lastModifiedById &&
            lhs.lastModifiedByInformation == rhs.lastModifiedByInformation &&
            lhs.name == rhs.name &&
            lhs.pageCount == rhs.pageCount &&
            lhs.parentFolderId == rhs.parentFolderId &&
            lhs.parentFolderUri == rhs.parentFolderUri &&
            lhs.sha256 == rhs.sha256 &&
            lhs.thumbHeight == rhs.thumbHeight &&
            lhs.thumbnail == rhs.thumbnail &&
            lhs.thumbWidth == rhs.thumbWidth &&
            lhs.type == rhs.type &&
            lhs.uri == rhs.uri &&
            lhs.userAuthorization == rhs.userAuthorization
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(callerAuthorization?.hashValue)
        hasher.combine(contentType?.hashValue)
        hasher.combine(created?.hashValue)
        hasher.combine(createdById?.hashValue)
        hasher.combine(createdByInformation?.hashValue)
        hasher.combine(`extension`?.hashValue)
        hasher.combine(fileSize?.hashValue)
        hasher.combine(fileUri?.hashValue)
        hasher.combine(id?.hashValue)
        hasher.combine(isPublic?.hashValue)
        hasher.combine(lastModified?.hashValue)
        hasher.combine(lastModifiedById?.hashValue)
        hasher.combine(lastModifiedByInformation?.hashValue)
        hasher.combine(name?.hashValue)
        hasher.combine(pageCount?.hashValue)
        hasher.combine(parentFolderId?.hashValue)
        hasher.combine(parentFolderUri?.hashValue)
        hasher.combine(sha256?.hashValue)
        hasher.combine(thumbHeight?.hashValue)
        hasher.combine(thumbnail?.hashValue)
        hasher.combine(thumbWidth?.hashValue)
        hasher.combine(type?.hashValue)
        hasher.combine(uri?.hashValue)
        hasher.combine(userAuthorization?.hashValue)
    }
}
