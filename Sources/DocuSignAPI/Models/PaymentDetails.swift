//
// PaymentDetails.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import AnyCodable
import Foundation
import Vapor

/** When a formula tab has a &#x60;paymentDetails&#x60; property, the formula tab is a payment item. See [Requesting Payments Along with Signatures][paymentguide] in the DocuSign Support Center to learn more about payments.  [paymentguide]:     https://support.docusign.com/en/guides/requesting-payments-along-with-signatures  */
public final class PaymentDetails: Content, Hashable {
    /** An array of accepted payment methods:  * `CreditCard` * `ApplePay` * `AndroidPay` * `BankAccount`  For example, if you only accept credit cards and ACH transfers, you would set this property to:  `'[\"BankAccount\", \"CreditCard\"]'`  Do not specify `BankAccount` (ACH) if you are also using in-person signing.  */
    public var allowedPaymentMethods: [String]?
    /** The GUID set by the payment gateway (such as Stripe) that identifies a transaction. The `chargeId` is created when authorizing a payment and must be referenced when completing a payment. */
    public var chargeId: String?
    /** Specifies the three-letter [ISO 4217][ISO4217] currency code for the payment.  Supported currencies are:  * AUD: Australian dollar * CAD: Canadian dollar * EUR: Euro * GBP: Great Britain pound * USD: United States dollar  Specifying any other ISO 4217 code for payments is an error.  [ISO4217]:          https://en.wikipedia.org/wiki/ISO_4217  */
    public var currencyCode: String?
    public var currencyCodeMetadata: PropertyMetadata?
    /** The customer ID. */
    public var customerId: String?
    /** This is a sender-defined field that passes any extra metadata about the payment that will show up in the Authorize.net transaction under **Description** in the merchant gateway portal. The custom metadata will be recorded in downloaded Authorize.net reports.   The following example shows what the **Description** field of the transaction will look like:   `<envelopeID>, <customMetadata>` */
    public var customMetadata: String?
    /** A sender-defined field that specifies whether custom metadata is required for the transaction. When set to **true**, custom metadata is required. This property only applies if you are using an Authorize.net payment gateway account. */
    public var customMetadataRequired: Bool?
    /** A GUID that identifies the payment gateway connected to the sender's DocuSign account.  There is no public API for connecting payment gateway accounts You must connect and manage payment gateway accounts through the DocuSign Admin console and through your chosen payment gateway.  You can get the gateway account ID in the Payments section of the DocuSign Admin console.   [paymentgateways]:  https://support.docusign.com/en/guides/managing-payment-gateways  */
    public var gatewayAccountId: String?
    public var gatewayAccountIdMetadata: PropertyMetadata?
    /** Display name of the gateway connected to sender's Docusign account.  Possible values are: Stripe, Braintree, Authorize.Net. */
    public var gatewayDisplayName: String?
    /** Name of the gateway connected to sender's DocuSign account.  Possible values are:  * `Stripe` * `Braintree` * `AuthorizeDotNet` */
    public var gatewayName: String?
    /** A payment formula can have one or more line items that provide detail about individual items in a payment request.  The list of line items are returned as metadata to the payment gateway.  */
    public var lineItems: [PaymentLineItem]?
    /** This property specifies how the signer's collected payment details will be used.  Possible values:  - `authorize`: The payment details will be used to collect payment. This is the default value. - `save`: The signer's payment method (credit card or bank account) will be saved to the sender's payment gateway. - `save_and_authorize`: The signer's payment method (credit card or bank account) will be saved to the sender's payment gateway and will also be used to collect payment. */
    public var paymentOption: String?
    /** The payment source ID. */
    public var paymentSourceId: String?
    /** This read-only property describes the status of a payment.  * `new`<br>   This is a new payment request.   The envelope has been created,   but no payment authorizations have been made.  * `auth_complete`<br>   A recipient has entered their credit card information,   but the envelope has not been completed.   The card has not been charged.  * `payment_complete`<br>   The recipient's card has been charged.  * `payment_capture_failed`<br>   Final charge failed.   This can happen when too much time   passes between authorizing the payment   and completing the document.  * `future_payment_saved` <br> The recipient's payment method has been saved to the sender's payment gateway.  */
    public var status: String?
    public var total: Money?

    public init(allowedPaymentMethods: [String]? = nil, chargeId: String? = nil, currencyCode: String? = nil, currencyCodeMetadata: PropertyMetadata? = nil, customerId: String? = nil, customMetadata: String? = nil, customMetadataRequired: Bool? = nil, gatewayAccountId: String? = nil, gatewayAccountIdMetadata: PropertyMetadata? = nil, gatewayDisplayName: String? = nil, gatewayName: String? = nil, lineItems: [PaymentLineItem]? = nil, paymentOption: String? = nil, paymentSourceId: String? = nil, status: String? = nil, total: Money? = nil) {
        self.allowedPaymentMethods = allowedPaymentMethods
        self.chargeId = chargeId
        self.currencyCode = currencyCode
        self.currencyCodeMetadata = currencyCodeMetadata
        self.customerId = customerId
        self.customMetadata = customMetadata
        self.customMetadataRequired = customMetadataRequired
        self.gatewayAccountId = gatewayAccountId
        self.gatewayAccountIdMetadata = gatewayAccountIdMetadata
        self.gatewayDisplayName = gatewayDisplayName
        self.gatewayName = gatewayName
        self.lineItems = lineItems
        self.paymentOption = paymentOption
        self.paymentSourceId = paymentSourceId
        self.status = status
        self.total = total
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case allowedPaymentMethods
        case chargeId
        case currencyCode
        case currencyCodeMetadata
        case customerId
        case customMetadata
        case customMetadataRequired
        case gatewayAccountId
        case gatewayAccountIdMetadata
        case gatewayDisplayName
        case gatewayName
        case lineItems
        case paymentOption
        case paymentSourceId
        case status
        case total
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(allowedPaymentMethods, forKey: .allowedPaymentMethods)
        try container.encodeIfPresent(chargeId, forKey: .chargeId)
        try container.encodeIfPresent(currencyCode, forKey: .currencyCode)
        try container.encodeIfPresent(currencyCodeMetadata, forKey: .currencyCodeMetadata)
        try container.encodeIfPresent(customerId, forKey: .customerId)
        try container.encodeIfPresent(customMetadata, forKey: .customMetadata)
        try container.encodeIfPresent(customMetadataRequired, forKey: .customMetadataRequired)
        try container.encodeIfPresent(gatewayAccountId, forKey: .gatewayAccountId)
        try container.encodeIfPresent(gatewayAccountIdMetadata, forKey: .gatewayAccountIdMetadata)
        try container.encodeIfPresent(gatewayDisplayName, forKey: .gatewayDisplayName)
        try container.encodeIfPresent(gatewayName, forKey: .gatewayName)
        try container.encodeIfPresent(lineItems, forKey: .lineItems)
        try container.encodeIfPresent(paymentOption, forKey: .paymentOption)
        try container.encodeIfPresent(paymentSourceId, forKey: .paymentSourceId)
        try container.encodeIfPresent(status, forKey: .status)
        try container.encodeIfPresent(total, forKey: .total)
    }

    public static func == (lhs: PaymentDetails, rhs: PaymentDetails) -> Bool {
        lhs.allowedPaymentMethods == rhs.allowedPaymentMethods &&
            lhs.chargeId == rhs.chargeId &&
            lhs.currencyCode == rhs.currencyCode &&
            lhs.currencyCodeMetadata == rhs.currencyCodeMetadata &&
            lhs.customerId == rhs.customerId &&
            lhs.customMetadata == rhs.customMetadata &&
            lhs.customMetadataRequired == rhs.customMetadataRequired &&
            lhs.gatewayAccountId == rhs.gatewayAccountId &&
            lhs.gatewayAccountIdMetadata == rhs.gatewayAccountIdMetadata &&
            lhs.gatewayDisplayName == rhs.gatewayDisplayName &&
            lhs.gatewayName == rhs.gatewayName &&
            lhs.lineItems == rhs.lineItems &&
            lhs.paymentOption == rhs.paymentOption &&
            lhs.paymentSourceId == rhs.paymentSourceId &&
            lhs.status == rhs.status &&
            lhs.total == rhs.total
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(allowedPaymentMethods?.hashValue)
        hasher.combine(chargeId?.hashValue)
        hasher.combine(currencyCode?.hashValue)
        hasher.combine(currencyCodeMetadata?.hashValue)
        hasher.combine(customerId?.hashValue)
        hasher.combine(customMetadata?.hashValue)
        hasher.combine(customMetadataRequired?.hashValue)
        hasher.combine(gatewayAccountId?.hashValue)
        hasher.combine(gatewayAccountIdMetadata?.hashValue)
        hasher.combine(gatewayDisplayName?.hashValue)
        hasher.combine(gatewayName?.hashValue)
        hasher.combine(lineItems?.hashValue)
        hasher.combine(paymentOption?.hashValue)
        hasher.combine(paymentSourceId?.hashValue)
        hasher.combine(status?.hashValue)
        hasher.combine(total?.hashValue)
    }
}
