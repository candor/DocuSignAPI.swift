//
// SignatureUserDef.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import AnyCodable
import Foundation
import Vapor

/**  */
public final class SignatureUserDef: Content, Hashable {
    /** Boolean that specifies whether the signature is the default signature for the user. */
    public var isDefault: String?
    /** Indicates whether the property is editable. Valid values are:  - `editable` - `read_only` */
    public var rights: String?
    /** The ID of the user to access. Generally this is the ID of the current authenticated user, but if the authenticated user is an Administrator on the account, `userId` can represent another user whom the Administrator is accessing.  */
    public var userId: String?

    public init(isDefault: String? = nil, rights: String? = nil, userId: String? = nil) {
        self.isDefault = isDefault
        self.rights = rights
        self.userId = userId
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case isDefault
        case rights
        case userId
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(isDefault, forKey: .isDefault)
        try container.encodeIfPresent(rights, forKey: .rights)
        try container.encodeIfPresent(userId, forKey: .userId)
    }

    public static func == (lhs: SignatureUserDef, rhs: SignatureUserDef) -> Bool {
        lhs.isDefault == rhs.isDefault &&
            lhs.rights == rhs.rights &&
            lhs.userId == rhs.userId
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(isDefault?.hashValue)
        hasher.combine(rights?.hashValue)
        hasher.combine(userId?.hashValue)
    }
}
