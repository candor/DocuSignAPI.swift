//
// BillingCharge.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import AnyCodable
import Foundation
import Vapor

/** Contains information about a billing charge. */
public final class BillingCharge: Content, Hashable {
    /** Reserved: TBD */
    public var allowedQuantity: String?
    /** Reserved: TBD */
    public var blocked: String?
    /** Provides information on what services the charge item is for.  The following table provides a description of the different chargeName values available at this time.  | chargeName | Description | | --- | --- | | id_check | ID Check Charge | | in_person_signing | In Person Signing charge | | envelopes Included | Sent Envelopes for the account | | age_verify | Age verification check | | ofac | OFAC Check | | id_confirm | ID confirmation check | | student_authentication | STAN PIN authentication check | | wet_sign_fax | Pages for returning signed documents by fax | | attachment_fax | Pages for returning attachments by fax | | phone_authentication | Phone authentication charge | | powerforms | PowerForm envelopes sent | | signer_payments | Payment processing charge | | outbound_fax | Send by fax charge | | bulk_recipient_envelopes | Bulk Recipient Envelopes sent | | sms_authentications | SMS authentication charge | | saml_authentications | SAML authentication charge | | express_signer_certificate | DocuSign Express Certificate charge | | personal_signer_certificate | Personal Signer Certificate charge | | safe_certificate | SAFE BioPharma Signer Certificate charge | | seats | Included active seats charge | | open_trust_certificate | OpenTrust Signer Certificate charge | */
    public var chargeName: String?
    /** Reserved: TBD */
    public var chargeType: String?
    /** Reserved: TBD */
    public var chargeUnitOfMeasure: String?
    /**  */
    public var discounts: [BillingDiscount]?
    /**  */
    public var firstEffectiveDate: String?
    /**  */
    public var includedQuantity: String?
    /** Reserved: TBD */
    public var incrementalQuantity: String?
    /**  */
    public var lastEffectiveDate: String?
    /**  */
    public var prices: [BillingPrice]?
    /** Reserved: TBD */
    public var unitPrice: String?
    /**  */
    public var usedQuantity: String?

    public init(allowedQuantity: String? = nil, blocked: String? = nil, chargeName: String? = nil, chargeType: String? = nil, chargeUnitOfMeasure: String? = nil, discounts: [BillingDiscount]? = nil, firstEffectiveDate: String? = nil, includedQuantity: String? = nil, incrementalQuantity: String? = nil, lastEffectiveDate: String? = nil, prices: [BillingPrice]? = nil, unitPrice: String? = nil, usedQuantity: String? = nil) {
        self.allowedQuantity = allowedQuantity
        self.blocked = blocked
        self.chargeName = chargeName
        self.chargeType = chargeType
        self.chargeUnitOfMeasure = chargeUnitOfMeasure
        self.discounts = discounts
        self.firstEffectiveDate = firstEffectiveDate
        self.includedQuantity = includedQuantity
        self.incrementalQuantity = incrementalQuantity
        self.lastEffectiveDate = lastEffectiveDate
        self.prices = prices
        self.unitPrice = unitPrice
        self.usedQuantity = usedQuantity
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case allowedQuantity
        case blocked
        case chargeName
        case chargeType
        case chargeUnitOfMeasure
        case discounts
        case firstEffectiveDate
        case includedQuantity
        case incrementalQuantity
        case lastEffectiveDate
        case prices
        case unitPrice
        case usedQuantity
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(allowedQuantity, forKey: .allowedQuantity)
        try container.encodeIfPresent(blocked, forKey: .blocked)
        try container.encodeIfPresent(chargeName, forKey: .chargeName)
        try container.encodeIfPresent(chargeType, forKey: .chargeType)
        try container.encodeIfPresent(chargeUnitOfMeasure, forKey: .chargeUnitOfMeasure)
        try container.encodeIfPresent(discounts, forKey: .discounts)
        try container.encodeIfPresent(firstEffectiveDate, forKey: .firstEffectiveDate)
        try container.encodeIfPresent(includedQuantity, forKey: .includedQuantity)
        try container.encodeIfPresent(incrementalQuantity, forKey: .incrementalQuantity)
        try container.encodeIfPresent(lastEffectiveDate, forKey: .lastEffectiveDate)
        try container.encodeIfPresent(prices, forKey: .prices)
        try container.encodeIfPresent(unitPrice, forKey: .unitPrice)
        try container.encodeIfPresent(usedQuantity, forKey: .usedQuantity)
    }

    public static func == (lhs: BillingCharge, rhs: BillingCharge) -> Bool {
        lhs.allowedQuantity == rhs.allowedQuantity &&
            lhs.blocked == rhs.blocked &&
            lhs.chargeName == rhs.chargeName &&
            lhs.chargeType == rhs.chargeType &&
            lhs.chargeUnitOfMeasure == rhs.chargeUnitOfMeasure &&
            lhs.discounts == rhs.discounts &&
            lhs.firstEffectiveDate == rhs.firstEffectiveDate &&
            lhs.includedQuantity == rhs.includedQuantity &&
            lhs.incrementalQuantity == rhs.incrementalQuantity &&
            lhs.lastEffectiveDate == rhs.lastEffectiveDate &&
            lhs.prices == rhs.prices &&
            lhs.unitPrice == rhs.unitPrice &&
            lhs.usedQuantity == rhs.usedQuantity
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(allowedQuantity?.hashValue)
        hasher.combine(blocked?.hashValue)
        hasher.combine(chargeName?.hashValue)
        hasher.combine(chargeType?.hashValue)
        hasher.combine(chargeUnitOfMeasure?.hashValue)
        hasher.combine(discounts?.hashValue)
        hasher.combine(firstEffectiveDate?.hashValue)
        hasher.combine(includedQuantity?.hashValue)
        hasher.combine(incrementalQuantity?.hashValue)
        hasher.combine(lastEffectiveDate?.hashValue)
        hasher.combine(prices?.hashValue)
        hasher.combine(unitPrice?.hashValue)
        hasher.combine(usedQuantity?.hashValue)
    }
}
