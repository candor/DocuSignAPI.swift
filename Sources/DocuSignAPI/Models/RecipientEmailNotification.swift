//
// RecipientEmailNotification.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import AnyCodable
import Foundation
import Vapor

/**  */
public final class RecipientEmailNotification: Content, Hashable {
    /** The body of the email message. */
    public var emailBody: String?
    public var emailBodyMetadata: PropertyMetadata?
    /** The subject line for the email notification. */
    public var emailSubject: String?
    public var emailSubjectMetadata: PropertyMetadata?
    /** The language to use for the standard email format and signing view for a recipient.  For example, in the recipient's email notification, this setting affects elements such as the standard introductory text describing the request to sign. It also determines the language used for buttons and tabs in both the email notification and the signing experience.  **Note**: This setting affects only DocuSign standard text. Any custom text that you enter for the `emailBody` and `emailSubject` of the notification is not translated, and appears exactly as you enter it.   To retrieve the possible values, use the [Accounts::listSupportedLanguages][ListLang] method.  [ListLang]: /esign/restapi/Accounts/Accounts/listSupportedLanguages/ */
    public var supportedLanguage: String?
    public var supportedLanguageMetadata: PropertyMetadata?

    public init(emailBody: String? = nil, emailBodyMetadata: PropertyMetadata? = nil, emailSubject: String? = nil, emailSubjectMetadata: PropertyMetadata? = nil, supportedLanguage: String? = nil, supportedLanguageMetadata: PropertyMetadata? = nil) {
        self.emailBody = emailBody
        self.emailBodyMetadata = emailBodyMetadata
        self.emailSubject = emailSubject
        self.emailSubjectMetadata = emailSubjectMetadata
        self.supportedLanguage = supportedLanguage
        self.supportedLanguageMetadata = supportedLanguageMetadata
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case emailBody
        case emailBodyMetadata
        case emailSubject
        case emailSubjectMetadata
        case supportedLanguage
        case supportedLanguageMetadata
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(emailBody, forKey: .emailBody)
        try container.encodeIfPresent(emailBodyMetadata, forKey: .emailBodyMetadata)
        try container.encodeIfPresent(emailSubject, forKey: .emailSubject)
        try container.encodeIfPresent(emailSubjectMetadata, forKey: .emailSubjectMetadata)
        try container.encodeIfPresent(supportedLanguage, forKey: .supportedLanguage)
        try container.encodeIfPresent(supportedLanguageMetadata, forKey: .supportedLanguageMetadata)
    }

    public static func == (lhs: RecipientEmailNotification, rhs: RecipientEmailNotification) -> Bool {
        lhs.emailBody == rhs.emailBody &&
            lhs.emailBodyMetadata == rhs.emailBodyMetadata &&
            lhs.emailSubject == rhs.emailSubject &&
            lhs.emailSubjectMetadata == rhs.emailSubjectMetadata &&
            lhs.supportedLanguage == rhs.supportedLanguage &&
            lhs.supportedLanguageMetadata == rhs.supportedLanguageMetadata
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(emailBody?.hashValue)
        hasher.combine(emailBodyMetadata?.hashValue)
        hasher.combine(emailSubject?.hashValue)
        hasher.combine(emailSubjectMetadata?.hashValue)
        hasher.combine(supportedLanguage?.hashValue)
        hasher.combine(supportedLanguageMetadata?.hashValue)
    }
}
