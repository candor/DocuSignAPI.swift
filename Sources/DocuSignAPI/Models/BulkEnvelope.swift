//
// BulkEnvelope.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import AnyCodable
import Foundation
import Vapor

/**  */
public final class BulkEnvelope: Content, Hashable {
    /** The row of the recipient in the CSV file used to create the bulk recipient list. */
    public var bulkRecipientRow: String?
    /** Indicates the status of the bulk send operation. Returned values can be: - `queued` - `processing` - `sent` - `failed` */
    public var bulkStatus: String?
    /** The email address of the recipient assigned to this envelope transaction. */
    public var email: String?
    /** GUID of the bulk envelope. */
    public var envelopeId: String?
    /** The URI for retrieving the envelope or envelopes. */
    public var envelopeUri: String?
    public var errorDetails: ErrorDetails?
    /** The name of the recipient assigned to this envelope transaction. */
    public var name: String?
    /** The date and time on which the bulk envelope was created. */
    public var submittedDateTime: String?
    /** Identifier for the envelope transaction. The ID is a sender-generated value and is valid in the DocuSign system for 7 days. We recommend that you use a transaction ID for offline signing to ensure that an envelope is not sent multiple times. You can use the transaction ID to determine an envelope's status (queued, processing, sent, or failed) in cases where the Internet connection is lost before envelope status is returned. */
    public var transactionId: String?

    public init(bulkRecipientRow: String? = nil, bulkStatus: String? = nil, email: String? = nil, envelopeId: String? = nil, envelopeUri: String? = nil, errorDetails: ErrorDetails? = nil, name: String? = nil, submittedDateTime: String? = nil, transactionId: String? = nil) {
        self.bulkRecipientRow = bulkRecipientRow
        self.bulkStatus = bulkStatus
        self.email = email
        self.envelopeId = envelopeId
        self.envelopeUri = envelopeUri
        self.errorDetails = errorDetails
        self.name = name
        self.submittedDateTime = submittedDateTime
        self.transactionId = transactionId
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case bulkRecipientRow
        case bulkStatus
        case email
        case envelopeId
        case envelopeUri
        case errorDetails
        case name
        case submittedDateTime
        case transactionId
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(bulkRecipientRow, forKey: .bulkRecipientRow)
        try container.encodeIfPresent(bulkStatus, forKey: .bulkStatus)
        try container.encodeIfPresent(email, forKey: .email)
        try container.encodeIfPresent(envelopeId, forKey: .envelopeId)
        try container.encodeIfPresent(envelopeUri, forKey: .envelopeUri)
        try container.encodeIfPresent(errorDetails, forKey: .errorDetails)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(submittedDateTime, forKey: .submittedDateTime)
        try container.encodeIfPresent(transactionId, forKey: .transactionId)
    }

    public static func == (lhs: BulkEnvelope, rhs: BulkEnvelope) -> Bool {
        lhs.bulkRecipientRow == rhs.bulkRecipientRow &&
            lhs.bulkStatus == rhs.bulkStatus &&
            lhs.email == rhs.email &&
            lhs.envelopeId == rhs.envelopeId &&
            lhs.envelopeUri == rhs.envelopeUri &&
            lhs.errorDetails == rhs.errorDetails &&
            lhs.name == rhs.name &&
            lhs.submittedDateTime == rhs.submittedDateTime &&
            lhs.transactionId == rhs.transactionId
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(bulkRecipientRow?.hashValue)
        hasher.combine(bulkStatus?.hashValue)
        hasher.combine(email?.hashValue)
        hasher.combine(envelopeId?.hashValue)
        hasher.combine(envelopeUri?.hashValue)
        hasher.combine(errorDetails?.hashValue)
        hasher.combine(name?.hashValue)
        hasher.combine(submittedDateTime?.hashValue)
        hasher.combine(transactionId?.hashValue)
    }
}
