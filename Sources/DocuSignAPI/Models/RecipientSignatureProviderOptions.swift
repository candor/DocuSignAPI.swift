//
// RecipientSignatureProviderOptions.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import AnyCodable
import Foundation
import Vapor

/** Option settings for the signature provider. Different providers require or use different options. [The current provider list and the options they require.](https://developers.docusign.com/esign-rest-api/guides/standards-based-signatures) */
public final class RecipientSignatureProviderOptions: Content, Hashable {
    /** Reserved for DocuSign. */
    public var cpfNumber: String?
    public var cpfNumberMetadata: PropertyMetadata?
    /** A pre-shared secret that the signer must enter to complete the signing process. Eg last six digits of the signer's government ID or Social Security number. Or a newly created pre-shared secret for the transaction. Note: some signature providers may require an exact (case-sensitive) match if alphabetic characters are included in the field. */
    public var oneTimePassword: String?
    public var oneTimePasswordMetadata: PropertyMetadata?
    /** The role or capacity of the signing recipient. Examples: Manager, Approver, etc. */
    public var signerRole: String?
    public var signerRoleMetadata: PropertyMetadata?
    /** The mobile phone number used to send the recipient an access code for the signing ceremony. Format: a string starting with +, then the country code followed by the full mobile phone number without any spaces or special characters. Omit leading zeroes before a city code. Examples: +14155551234, +97235551234, +33505551234. */
    public var sms: String?
    public var smsMetadata: PropertyMetadata?

    public init(cpfNumber: String? = nil, cpfNumberMetadata: PropertyMetadata? = nil, oneTimePassword: String? = nil, oneTimePasswordMetadata: PropertyMetadata? = nil, signerRole: String? = nil, signerRoleMetadata: PropertyMetadata? = nil, sms: String? = nil, smsMetadata: PropertyMetadata? = nil) {
        self.cpfNumber = cpfNumber
        self.cpfNumberMetadata = cpfNumberMetadata
        self.oneTimePassword = oneTimePassword
        self.oneTimePasswordMetadata = oneTimePasswordMetadata
        self.signerRole = signerRole
        self.signerRoleMetadata = signerRoleMetadata
        self.sms = sms
        self.smsMetadata = smsMetadata
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case cpfNumber
        case cpfNumberMetadata
        case oneTimePassword
        case oneTimePasswordMetadata
        case signerRole
        case signerRoleMetadata
        case sms
        case smsMetadata
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(cpfNumber, forKey: .cpfNumber)
        try container.encodeIfPresent(cpfNumberMetadata, forKey: .cpfNumberMetadata)
        try container.encodeIfPresent(oneTimePassword, forKey: .oneTimePassword)
        try container.encodeIfPresent(oneTimePasswordMetadata, forKey: .oneTimePasswordMetadata)
        try container.encodeIfPresent(signerRole, forKey: .signerRole)
        try container.encodeIfPresent(signerRoleMetadata, forKey: .signerRoleMetadata)
        try container.encodeIfPresent(sms, forKey: .sms)
        try container.encodeIfPresent(smsMetadata, forKey: .smsMetadata)
    }

    public static func == (lhs: RecipientSignatureProviderOptions, rhs: RecipientSignatureProviderOptions) -> Bool {
        lhs.cpfNumber == rhs.cpfNumber &&
            lhs.cpfNumberMetadata == rhs.cpfNumberMetadata &&
            lhs.oneTimePassword == rhs.oneTimePassword &&
            lhs.oneTimePasswordMetadata == rhs.oneTimePasswordMetadata &&
            lhs.signerRole == rhs.signerRole &&
            lhs.signerRoleMetadata == rhs.signerRoleMetadata &&
            lhs.sms == rhs.sms &&
            lhs.smsMetadata == rhs.smsMetadata
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(cpfNumber?.hashValue)
        hasher.combine(cpfNumberMetadata?.hashValue)
        hasher.combine(oneTimePassword?.hashValue)
        hasher.combine(oneTimePasswordMetadata?.hashValue)
        hasher.combine(signerRole?.hashValue)
        hasher.combine(signerRoleMetadata?.hashValue)
        hasher.combine(sms?.hashValue)
        hasher.combine(smsMetadata?.hashValue)
    }
}
