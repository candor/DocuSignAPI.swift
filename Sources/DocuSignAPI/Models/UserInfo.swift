//
// UserInfo.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import AnyCodable
import Foundation
import Vapor

/**  */
public final class UserInfo: Content, Hashable {
    /** The external account number (int) or account ID GUID. */
    public var accountId: String?
    /** The name on the account. */
    public var accountName: String?
    /** Access code provided to the user to activate the account. */
    public var activationAccessCode: String?
    /** The user's email address. */
    public var email: String?
    public var errorDetails: ErrorDetails?
    /** Boolean value that indicates whether the user is currently logged in or not. */
    public var loginStatus: String?
    /** The user's membership ID. */
    public var membershipId: String?
    /** When set to **true**, specifies that an activation email be sent to the user. */
    public var sendActivationEmail: String?
    /** A URI containing the user ID. */
    public var uri: String?
    /** The ID of the user to access. Generally this is the ID of the current authenticated user, but if the authenticated user is an Administrator on the account, `userId` can represent another user whom the Administrator is accessing.  */
    public var userId: String?
    /** The name of the user. */
    public var userName: String?
    /** Status of the user's account. One of:  - `ActivationRequired` - `ActivationSent` - `Active` - `Closed` - `Disabled`  */
    public var userStatus: String?
    /** The type of user, for example `CompanyUser`. */
    public var userType: String?

    public init(accountId: String? = nil, accountName: String? = nil, activationAccessCode: String? = nil, email: String? = nil, errorDetails: ErrorDetails? = nil, loginStatus: String? = nil, membershipId: String? = nil, sendActivationEmail: String? = nil, uri: String? = nil, userId: String? = nil, userName: String? = nil, userStatus: String? = nil, userType: String? = nil) {
        self.accountId = accountId
        self.accountName = accountName
        self.activationAccessCode = activationAccessCode
        self.email = email
        self.errorDetails = errorDetails
        self.loginStatus = loginStatus
        self.membershipId = membershipId
        self.sendActivationEmail = sendActivationEmail
        self.uri = uri
        self.userId = userId
        self.userName = userName
        self.userStatus = userStatus
        self.userType = userType
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case accountId
        case accountName
        case activationAccessCode
        case email
        case errorDetails
        case loginStatus
        case membershipId
        case sendActivationEmail
        case uri
        case userId
        case userName
        case userStatus
        case userType
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(accountId, forKey: .accountId)
        try container.encodeIfPresent(accountName, forKey: .accountName)
        try container.encodeIfPresent(activationAccessCode, forKey: .activationAccessCode)
        try container.encodeIfPresent(email, forKey: .email)
        try container.encodeIfPresent(errorDetails, forKey: .errorDetails)
        try container.encodeIfPresent(loginStatus, forKey: .loginStatus)
        try container.encodeIfPresent(membershipId, forKey: .membershipId)
        try container.encodeIfPresent(sendActivationEmail, forKey: .sendActivationEmail)
        try container.encodeIfPresent(uri, forKey: .uri)
        try container.encodeIfPresent(userId, forKey: .userId)
        try container.encodeIfPresent(userName, forKey: .userName)
        try container.encodeIfPresent(userStatus, forKey: .userStatus)
        try container.encodeIfPresent(userType, forKey: .userType)
    }

    public static func == (lhs: UserInfo, rhs: UserInfo) -> Bool {
        lhs.accountId == rhs.accountId &&
            lhs.accountName == rhs.accountName &&
            lhs.activationAccessCode == rhs.activationAccessCode &&
            lhs.email == rhs.email &&
            lhs.errorDetails == rhs.errorDetails &&
            lhs.loginStatus == rhs.loginStatus &&
            lhs.membershipId == rhs.membershipId &&
            lhs.sendActivationEmail == rhs.sendActivationEmail &&
            lhs.uri == rhs.uri &&
            lhs.userId == rhs.userId &&
            lhs.userName == rhs.userName &&
            lhs.userStatus == rhs.userStatus &&
            lhs.userType == rhs.userType
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(accountId?.hashValue)
        hasher.combine(accountName?.hashValue)
        hasher.combine(activationAccessCode?.hashValue)
        hasher.combine(email?.hashValue)
        hasher.combine(errorDetails?.hashValue)
        hasher.combine(loginStatus?.hashValue)
        hasher.combine(membershipId?.hashValue)
        hasher.combine(sendActivationEmail?.hashValue)
        hasher.combine(uri?.hashValue)
        hasher.combine(userId?.hashValue)
        hasher.combine(userName?.hashValue)
        hasher.combine(userStatus?.hashValue)
        hasher.combine(userType?.hashValue)
    }
}
